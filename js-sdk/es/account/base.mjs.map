{"version":3,"sources":["../../src/account/base.js"],"names":["stampit","messageToHash","verifyMessage","verifyMessageCrypto","hash","buildTx","decode","TX_TYPE","getNetworkId","isAccountBase","acc","find","f","signTransaction","tx","opt","prefixes","innerTx","push","rlpBinaryTx","txWithNetworkId","concat","from","join","signatures","sign","encodedTx","signed","signMessage","message","returnHex","sig","toString","signature","address","init","networkId","methods","required"],"mappings":"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","sourcesContent":["/*\n * ISC License (ISC)\n * Copyright (c) 2018 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * AccountBase module\n * @module @aeternity/aepp-sdk/es/account/base\n * @export AccountBase\n * @export isAccountBase\n */\n\nimport stampit from '@stamp/it'\nimport { required } from '@stamp/required'\nimport { messageToHash, verifyMessage as verifyMessageCrypto, hash } from '../utils/crypto'\nimport { buildTx } from '../tx/builder'\nimport { decode } from '../tx/builder/helpers'\nimport { TX_TYPE } from '../tx/builder/schema'\nimport { getNetworkId } from '../node'\n\n/**\n * Check is provided object looks like an instance of AccountBase\n * @rtype (Object) => Boolean\n * @param {Object} acc - Object to check\n * @return {Boolean}\n */\nexport const isAccountBase = (acc) => !['sign', 'address'].find(f => typeof acc[f] !== 'function')\n\n/**\n * Sign encoded transaction\n * @instance\n * @category async\n * @rtype (tx: String) => tx: Promise[String], throws: Error\n * @param {String} tx - Transaction to sign\n * @param {Object} opt - Options\n * @param {Object} [opt.innerTx] - Sign as inner transaction for PayingFor\n * @return {String} Signed transaction\n */\nasync function signTransaction (tx, opt = {}) {\n  const prefixes = [this.getNetworkId(opt)]\n  if (opt.innerTx) prefixes.push('inner_tx')\n  const rlpBinaryTx = decode(tx, 'tx')\n  const txWithNetworkId = Buffer.concat([Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)])\n\n  const signatures = [await this.sign(txWithNetworkId, opt)]\n  return buildTx({ encodedTx: rlpBinaryTx, signatures }, TX_TYPE.signed).tx\n}\n\n/**\n * Get network Id\n * @instance\n * @function getNetworkId\n * @category async\n * @rtype () => networkId: String\n * @return {String} Network Id\n */\n\n/**\n * Sign message\n * @instance\n * @category async\n * @rtype (msg: String) => signature: Promise[String], throws: Error\n * @param {String} message - Message to sign\n * @param {Object} opt - Options\n * @return {String} Signature\n */\nasync function signMessage (message, opt = { returnHex: false }) {\n  const sig = await this.sign(messageToHash(message), opt)\n  return opt.returnHex ? Buffer.from(sig).toString('hex') : sig\n}\n\n/**\n * Verify message\n * @instance\n * @category async\n * @rtype (\n *   msg: String, signature: String, publicKey: String\n * ) => signature: Promise[String], throws: Error\n * @param {String} message - Message to verify\n * @param {String} signature - Signature\n * @param {Object} opt - Options\n * @return {Boolean}\n */\nasync function verifyMessage (message, signature, opt = {}) {\n  return verifyMessageCrypto(\n    message,\n    typeof signature === 'string' ? Buffer.from(signature, 'hex') : signature,\n    decode(await this.address(opt))\n  )\n}\n\n/**\n * AccountBase Stamp\n *\n * Attempting to create instances from the Stamp without overwriting all\n * abstract methods using composition will result in an exception.\n *\n * Account is one of the three basic building blocks of an\n * {@link module:@aeternity/aepp-sdk/es/ae--Ae} client and provides access to a\n * signing key pair.\n * @function\n * @alias module:@aeternity/aepp-sdk/es/account\n * @rtype Stamp\n * @param {Object} [options={}] - Initializer object\n * @param {String} options.networkId - NETWORK_ID using for signing transaction's\n * @return {Object} Account instance\n */\nexport default stampit({\n  init ({ networkId }) { // NETWORK_ID using for signing transaction's\n    if (!this.networkId && networkId) {\n      this.networkId = networkId\n    }\n  },\n  methods: { signTransaction, getNetworkId, signMessage, verifyMessage }\n}, required({\n  methods: {\n    sign: required,\n    address: required\n  }\n}))\n\n/**\n * Sign data blob\n * @function sign\n * @instance\n * @abstract\n * @category async\n * @rtype (data: String) => data: Promise[String]\n * @param {String} data - Data blob to sign\n * @return {String} Signed data blob\n */\n\n/**\n * Obtain account address\n * @function address\n * @instance\n * @abstract\n * @category async\n * @rtype () => address: Promise[String]\n * @return {String} Public account address\n */\n"],"file":"base.mjs"}