{"version":3,"sources":["../../src/channel/index.js"],"names":["AsyncInit","snakeToPascal","buildTx","unpackTx","TX_TYPE","handlers","eventEmitters","status","channelStatus","state","channelState","initialize","enqueueAction","send","channelId","call","disconnect","channelDisconnect","fsmId","channelFsmId","snakeToPascalObjKeys","obj","Object","entries","reduce","result","key","val","on","event","callback","get","off","removeListener","round","txType","tx","encodedTx","channelCreate","channelOffChain","channelWithdraw","channelDeposit","parseInt","id","update","from","to","amount","sign","metadata","Promise","resolve","reject","channel","handler","channelOpen","jsonrpc","method","params","meta","awaitingOffChainTx","poi","accounts","contracts","balances","fromEntries","map","item","account","balance","leave","awaitingLeave","shutdown","awaitingShutdownTx","withdraw","onOnChainTx","onOwnWithdrawLocked","onWithdrawLocked","awaitingWithdrawTx","deposit","onOwnDepositLocked","onDepositLocked","awaitingDepositTx","createContract","code","callData","vmVersion","abiVersion","call_data","vm_version","abi_version","awaitingNewContractTx","callContract","contract","contract_id","awaitingCallContractUpdateTx","forceProgress","gas","gasPrice","nonce","gas_price","awaitingCallContractForceProgressUpdate","callContractStatic","getContractCall","caller","caller_id","getContractState","pubkey","cleanContractCalls","awaitingCallsPruned","sendMessage","message","recipient","info","JSON","stringify","doSend","onStatusChanged","setTimeout","reconnect","options","txParams","Channel","reconnectTx","channelReconnect","compose","init","existingFsmId","awaitingReconnection","awaitingConnection","methods","statics"],"mappings":"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","sourcesContent":["/*\n * ISC License (ISC)\n * Copyright (c) 2018 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * Channel module\n * @module @aeternity/aepp-sdk/es/channel/index\n * @export Channel\n * @example import { Channel } from '@aeternity/aepp-sdk'\n */\n\nimport AsyncInit from '../utils/async-init'\nimport { snakeToPascal } from '../utils/string'\nimport { buildTx, unpackTx } from '../tx/builder'\nimport { TX_TYPE } from '../tx/builder/schema'\nimport * as handlers from './handlers'\nimport {\n  eventEmitters,\n  status as channelStatus,\n  state as channelState,\n  initialize,\n  enqueueAction,\n  send,\n  channelId,\n  call,\n  disconnect as channelDisconnect,\n  fsmId as channelFsmId\n} from './internal'\n\nfunction snakeToPascalObjKeys (obj) {\n  return Object.entries(obj).reduce((result, [key, val]) => ({\n    ...result,\n    [snakeToPascal(key)]: val\n  }), {})\n}\n\n/**\n * Register event listener function\n *\n * Possible events:\n *\n *   - \"error\"\n *   - \"onChainTx\"\n *   - \"ownWithdrawLocked\"\n *   - \"withdrawLocked\"\n *   - \"ownDepositLocked\"\n *   - \"depositLocked\"\n *\n * @param {String} event - Event name\n * @param {Function} callback - Callback function\n */\nfunction on (event, callback) {\n  eventEmitters.get(this).on(event, callback)\n}\n\n/**\n * Remove event listener function\n *\n * @param {String} event - Event name\n * @param {Function} callback - Callback function\n */\nfunction off (event, callback) {\n  eventEmitters.get(this).removeListener(event, callback)\n}\n\n/**\n * Close the connection\n */\nfunction disconnect () {\n  return channelDisconnect(this)\n}\n\n/**\n * Get current status\n *\n * @return {String}\n */\nfunction status () {\n  return channelStatus.get(this)\n}\n\n/**\n * Get current state\n *\n * @return {Promise<Object>}\n */\nasync function state () {\n  return snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}))\n}\n\n/**\n * Get current round\n *\n * If round cannot be determined (for example when channel has not been opened)\n * it will return `null`.\n *\n * @return {Number}\n */\nfunction round () {\n  const state = channelState.get(this)\n  if (!state) {\n    return null\n  }\n  const { txType, tx } = unpackTx(channelState.get(this)).tx.encodedTx\n  switch (txType) {\n    case TX_TYPE.channelCreate:\n      return 1\n    case TX_TYPE.channelOffChain:\n    case TX_TYPE.channelWithdraw:\n    case TX_TYPE.channelDeposit:\n      return parseInt(tx.round, 10)\n    default:\n      return null\n  }\n}\n\n/**\n * Get channel id\n *\n * @return {String}\n */\nfunction id () {\n  return channelId.get(this)\n}\n\n/**\n * Get channel's fsm id\n *\n * @return {String}\n */\nfunction fsmId () {\n  return channelFsmId.get(this)\n}\n\n/**\n * Trigger a transfer update\n *\n * The transfer update is moving tokens from one channel account to another.\n * The update is a change to be applied on top of the latest state.\n *\n * Sender and receiver are the channel parties. Both the initiator and responder\n * can take those roles. Any public key outside of the channel is considered invalid.\n *\n * @param {String} from - Sender's public address\n * @param {String} to - Receiver's public address\n * @param {Number} amount - Transaction amount\n * @param {Function} sign - Function which verifies and signs offchain transaction\n * @param {Array<String>} metadata\n * @return {Promise<Object>}\n * @example channel.update(\n *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   10,\n *   async (tx) => await account.signTransaction(tx)\n * ).then(({ accepted, signedTx }) =>\n *   if (accepted) {\n *     console.log('Update has been accepted')\n *   }\n * )\n */\nfunction update (from, to, amount, sign, metadata) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, {\n          jsonrpc: '2.0',\n          method: 'channels.update.new',\n          params: { from, to, amount, meta: metadata }\n        })\n        return {\n          handler: handlers.awaitingOffChainTx,\n          state: {\n            resolve,\n            reject,\n            sign\n          }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Get proof of inclusion\n *\n * If a certain address of an account or a contract is not found\n * in the state tree - the response is an error.\n *\n * @param {Object} addresses\n * @param {Array<String>} [addresses.accounts] - List of account addresses to include in poi\n * @param {Array<String>} [addresses.contracts] - List of contract addresses to include in poi\n * @return {Promise<String>}\n * @example channel.poi({\n *   accounts: [\n *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n *   ],\n *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']\n * }).then(poi => console.log(poi))\n */\nasync function poi ({ accounts, contracts }) {\n  return (await call(this, 'channels.get.poi', { accounts, contracts })).poi\n}\n\n/**\n * Get balances\n *\n * The accounts paramcontains a list of addresses to fetch balances of.\n * Those can be either account balances or a contract ones, encoded as an account addresses.\n *\n * If a certain account address had not being found in the state tree - it is simply\n * skipped in the response.\n *\n * @param {Array<String>} accounts - List of addresses to fetch balances from\n * @return {Promise<Object>}\n * @example channel.balances([\n *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'\n * ]).then(balances =>\n *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])\n * )\n */\nasync function balances (accounts) {\n  return Object.fromEntries(\n    (await call(this, 'channels.get.balances', { accounts }))\n      .map(item => [item.account, item.balance])\n  )\n}\n\n/**\n * Leave channel\n *\n * It is possible to leave a channel and then later reestablish the channel\n * off-chain state and continue operation. When a leave method is called,\n * the channel fsm passes it on to the peer fsm, reports the current mutually\n * signed state and then terminates.\n *\n * The channel can be reestablished by instantiating another Channel instance\n * with two extra params: existingChannelId and offchainTx (returned from leave\n * method as channelId and signedTx respectively).\n *\n * @return {Promise<Object>}\n * @example channel.leave().then(({ channelId, signedTx }) => {\n *   console.log(channelId)\n *   console.log(signedTx)\n * })\n */\nfunction leave () {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, { jsonrpc: '2.0', method: 'channels.leave', params: {} })\n        return {\n          handler: handlers.awaitingLeave,\n          state: { resolve, reject }\n        }\n      })\n  })\n}\n\n/**\n * Trigger mutual close\n *\n * At any moment after the channel is opened, a closing procedure can be triggered.\n * This can be done by either of the parties. The process is similar to the off-chain updates.\n *\n * @param {Function} sign - Function which verifies and signs mutual close transaction\n * @return {Promise<String>}\n * @example channel.shutdown(\n *   async (tx) => await account.signTransaction(tx)\n * ).then(tx => console.log('on_chain_tx', tx))\n */\nfunction shutdown (sign) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, { jsonrpc: '2.0', method: 'channels.shutdown', params: {} })\n        return {\n          handler: handlers.awaitingShutdownTx,\n          state: {\n            sign,\n            resolve,\n            reject\n          }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Withdraw tokens from the channel\n *\n * After the channel had been opened any of the participants can initiate a withdrawal.\n * The process closely resembles the update. The most notable difference is that the\n * transaction has been co-signed: it is channel_withdraw_tx and after the procedure\n * is finished - it is being posted on-chain.\n *\n * Any of the participants can initiate a withdrawal. The only requirements are:\n *\n *   - Channel is already opened\n *   - No off-chain update/deposit/withdrawal is currently being performed\n *   - Channel is not being closed or in a solo closing state\n *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed\n *     the available balance on the channel (minus the channel_reserve)\n *\n * After the other party had signed the withdraw transaction, the transaction is posted\n * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n * After computing transaction hash it can be tracked on the chain: entering the mempool,\n * block inclusion and a number of confirmations.\n *\n * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called\n * (without any arguments).\n *\n * When the other party had confirmed that the block height needed is reached\n * onWithdrawLocked callback is called (without any arguments).\n *\n * @param {Number} amount - Amount of tokens to withdraw\n * @param {Function} sign - Function which verifies and signs withdraw transaction\n * @param {Object} [callbacks]\n * @param {Function} [callbacks.onOnChainTx] - Called when withdraw transaction has been posted\n * on chain\n * @param {Function} [callbacks.onOwnWithdrawLocked]\n * @param {Function} [callbacks.onWithdrawLocked]\n * @return {Promise<Object>}\n * @example channel.withdraw(\n *   100,\n *   async (tx) => await account.signTransaction(tx),\n *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n * ).then(({ accepted, signedTx }) => {\n *   if (accepted) {\n *     console.log('Withdrawal has been accepted')\n *   } else {\n *     console.log('Withdrawal has been rejected')\n *   }\n * })\n */\nfunction withdraw (amount, sign, { onOnChainTx, onOwnWithdrawLocked, onWithdrawLocked } = {}) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, { jsonrpc: '2.0', method: 'channels.withdraw', params: { amount } })\n        return {\n          handler: handlers.awaitingWithdrawTx,\n          state: {\n            sign,\n            resolve,\n            reject,\n            onOnChainTx,\n            onOwnWithdrawLocked,\n            onWithdrawLocked\n          }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Deposit tokens into the channel\n *\n * After the channel had been opened any of the participants can initiate a deposit.\n * The process closely resembles the update. The most notable difference is that the\n * transaction has been co-signed: it is channel_deposit_tx and after the procedure\n * is finished - it is being posted on-chain.\n *\n * Any of the participants can initiate a deposit. The only requirements are:\n *\n *   - Channel is already opened\n *   - No off-chain update/deposit/withdrawal is currently being performed\n *   - Channel is not being closed or in a solo closing state\n *   - The deposit amount must be equal to or greater than zero, and cannot exceed\n *     the available balance on the channel (minus the channel_reserve)\n *\n * After the other party had signed the deposit transaction, the transaction is posted\n * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n * After computing transaction hash it can be tracked on the chain: entering the mempool,\n * block inclusion and a number of confirmations.\n *\n * After the minimum_depth block confirmations onOwnDepositLocked callback is called\n * (without any arguments).\n *\n * When the other party had confirmed that the block height needed is reached\n * onDepositLocked callback is called (without any arguments).\n *\n * @param {Number} amount - Amount of tokens to deposit\n * @param {Function} sign - Function which verifies and signs deposit transaction\n * @param {Object} [callbacks]\n * @param {Function} [callbacks.onOnChainTx] - Called when deposit transaction has been posted\n * on chain\n * @param {Function} [callbacks.onOwnDepositLocked]\n * @param {Function} [callbacks.onDepositLocked]\n * @return {Promise<Object>}\n * @example channel.deposit(\n *   100,\n *   async (tx) => await account.signTransaction(tx),\n *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n * ).then(({ accepted, state }) => {\n *   if (accepted) {\n *     console.log('Deposit has been accepted')\n *     console.log('The new state is:', state)\n *   } else {\n *     console.log('Deposit has been rejected')\n *   }\n * })\n */\nfunction deposit (amount, sign, { onOnChainTx, onOwnDepositLocked, onDepositLocked } = {}) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, { jsonrpc: '2.0', method: 'channels.deposit', params: { amount } })\n        return {\n          handler: handlers.awaitingDepositTx,\n          state: {\n            sign,\n            resolve,\n            reject,\n            onOnChainTx,\n            onOwnDepositLocked,\n            onDepositLocked\n          }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Trigger create contract update\n *\n * The create contract update is creating a contract inside the channel's internal state tree.\n * The update is a change to be applied on top of the latest state.\n *\n * That would create a contract with the poster being the owner of it. Poster commits initially\n * a deposit amount of tokens to the new contract.\n *\n * @param {Object} options\n * @param {String} options.code - Api encoded compiled AEVM byte code\n * @param {String} options.callData - Api encoded compiled AEVM call data for the code\n * @param {Number} options.deposit - Initial amount the owner of the contract commits to it\n * @param {Number} options.vmVersion - Version of the Virtual Machine\n * @param {Number} options.abiVersion - Version of the Application Binary Interface\n * @param {Function} sign - Function which verifies and signs create contract transaction\n * @return {Promise<Object>}\n * @example channel.createContract({\n *   code: 'cb_HKtpipK4aCgYb17wZ...',\n *   callData: 'cb_1111111111111111...',\n *   deposit: 10,\n *   vmVersion: 3,\n *   abiVersion: 1\n * }).then(({ accepted, signedTx, address }) => {\n *   if (accepted) {\n *     console.log('New contract has been created')\n *     console.log('Contract address:', address)\n *   } else {\n *     console.log('New contract has been rejected')\n *   }\n * })\n */\nfunction createContract ({ code, callData, deposit, vmVersion, abiVersion }, sign) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, {\n          jsonrpc: '2.0',\n          method: 'channels.update.new_contract',\n          params: {\n            code,\n            call_data: callData,\n            deposit,\n            vm_version: vmVersion,\n            abi_version: abiVersion\n          }\n        })\n        return {\n          handler: handlers.awaitingNewContractTx,\n          state: {\n            sign,\n            resolve,\n            reject\n          }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Trigger call a contract update\n *\n * The call contract update is calling a preexisting contract inside the channel's\n * internal state tree. The update is a change to be applied on top of the latest state.\n *\n * That would call a contract with the poster being the caller of it. Poster commits\n * an amount of tokens to the contract.\n *\n * The call would also create a call object inside the channel state tree. It contains\n * the result of the contract call.\n *\n * It is worth mentioning that the gas is not consumed, because this is an off-chain\n * contract call. It would be consumed if it were a on-chain one. This could happen\n * if a call with a similar computation amount is to be forced on-chain.\n *\n * @param {Object} options\n * @param {String} [options.amount] - Amount the caller of the contract commits to it\n * @param {String} [options.callData] - ABI encoded compiled AEVM call data for the code\n * @param {Number} [options.contract] - Address of the contract to call\n * @param {Number} [options.abiVersion] - Version of the ABI\n * @param {Function} sign - Function which verifies and signs contract call transaction\n * @return {Promise<Object>}\n * @example channel.callContract({\n *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n *   callData: 'cb_1111111111111111...',\n *   amount: 0,\n *   abiVersion: 1\n * }).then(({ accepted, signedTx }) => {\n *   if (accepted) {\n *     console.log('Contract called succesfully')\n *   } else {\n *     console.log('Contract call has been rejected')\n *   }\n * })\n */\nfunction callContract ({ amount, callData, contract, abiVersion }, sign) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, {\n          jsonrpc: '2.0',\n          method: 'channels.update.call_contract',\n          params: {\n            amount,\n            call_data: callData,\n            contract_id: contract,\n            abi_version: abiVersion\n          }\n        })\n        return {\n          handler: handlers.awaitingCallContractUpdateTx,\n          state: { resolve, reject, sign }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Trigger a force progress contract call\n * This call is going on-chain\n * @param {Object} options\n * @param {String} [options.amount] - Amount the caller of the contract commits to it\n * @param {String} [options.callData] - ABI encoded compiled AEVM call data for the code\n * @param {Number} [options.contract] - Address of the contract to call\n * @param {Number} [options.abiVersion] - Version of the ABI\n * @param {Number} [options.gasPrice=1000000000] - Gas price\n * @param {Number} [options.gas=1000000] - Gas limit\n * @param {Function} sign - Function which verifies and signs contract force progress transaction\n * @param {{ onOnChainTxL: Function }} callbacks\n * @return {Promise<Object>}\n * @example channel.forceProgress({\n *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n *   callData: 'cb_1111111111111111...',\n *   amount: 0,\n *   abiVersion: 1,\n *   gasPrice: 1000005554\n * }).then(({ accepted, signedTx }) => {\n *   if (accepted) {\n *     console.log('Contract force progress call successful')\n *   } else {\n *     console.log('Contract force progress call has been rejected')\n *   }\n * })\n */\nfunction forceProgress (\n  { amount, callData, contract, abiVersion, gas = 1000000, gasPrice = 1000000000, nonce },\n  sign,\n  { onOnChainTx } = {}\n) {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, {\n          jsonrpc: '2.0',\n          method: 'channels.force_progress',\n          params: {\n            amount,\n            call_data: callData,\n            contract_id: contract,\n            abi_version: abiVersion,\n            gas_price: gasPrice,\n            gas\n          }\n        })\n        return {\n          handler: handlers.awaitingCallContractForceProgressUpdate,\n          state: { resolve, reject, sign, onOnChainTx }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Call contract using dry-run\n *\n * In order to get the result of a potential contract call, one might need to\n * dry-run a contract call. It takes the exact same arguments as a call would\n * and returns the call object.\n *\n * The call is executed in the channel's state but it does not impact the state\n * whatsoever. It uses as an environment the latest channel's state and the current\n * top of the blockchain as seen by the node.\n *\n * @param {Object} options\n * @param {String} [options.amount] - Amount the caller of the contract commits to it\n * @param {String} [options.callData] - ABI encoded compiled AEVM call data for the code\n * @param {Number} [options.contract] - Address of the contract to call\n * @param {Number} [options.abiVersion] - Version of the ABI\n * @return {Promise<Object>}\n * @example channel.callContractStatic({\n  *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n  *   callData: 'cb_1111111111111111...',\n  *   amount: 0,\n  *   abiVersion: 1\n  * }).then(({ returnValue, gasUsed }) => {\n  *   console.log('Returned value:', returnValue)\n  *   console.log('Gas used:', gasUsed)\n  * })\n  */\nasync function callContractStatic ({ amount, callData, contract, abiVersion }) {\n  return snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {\n    amount,\n    call_data: callData,\n    contract_id: contract,\n    abi_version: abiVersion\n  }))\n}\n\n/**\n * Get contract call result\n *\n * The combination of a caller, contract and a round of execution determines the\n * contract call. Providing an incorrect set of those results in an error response.\n *\n * @param {Object} options\n * @param {String} [options.caller] - Address of contract caller\n * @param {String} [options.contract] - Address of the contract\n * @param {Number} [options.round] - Round when contract was called\n * @return {Promise<Object>}\n * @example channel.getContractCall({\n *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n *   round: 3\n * }).then(({ returnType, returnValue }) => {\n *   if (returnType === 'ok') console.log(returnValue)\n * })\n */\nasync function getContractCall ({ caller, contract, round }) {\n  return snakeToPascalObjKeys(\n    await call(this, 'channels.get.contract_call', {\n      caller_id: caller,\n      contract_id: contract,\n      round\n    })\n  )\n}\n\n/**\n * Get contract latest state\n *\n * @param {String} contract - Address of the contract\n * @return {Promise<Object>}\n * @example channel.getContractState(\n *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'\n * ).then(({ contract }) => {\n *   console.log('deposit:', contract.deposit)\n * })\n */\nasync function getContractState (contract) {\n  const result = await call(this, 'channels.get.contract', { pubkey: contract })\n  return snakeToPascalObjKeys({\n    ...result,\n    contract: snakeToPascalObjKeys(result.contract)\n  })\n}\n\n/**\n * Clean up all locally stored contract calls\n *\n * Contract calls are kept locally in order for the participant to be able to look them up.\n * They consume memory and in order for the participant to free it - one can prune all messages.\n * This cleans up all locally stored contract calls and those will no longer be available for\n * fetching and inspection.\n *\n * @return {Promise}\n */\nfunction cleanContractCalls () {\n  return new Promise((resolve, reject) => {\n    enqueueAction(\n      this,\n      (channel, state) => state.handler === handlers.channelOpen,\n      (channel, state) => {\n        send(channel, {\n          jsonrpc: '2.0',\n          method: 'channels.clean_contract_calls',\n          params: {}\n        })\n        return {\n          handler: handlers.awaitingCallsPruned,\n          state: { resolve, reject }\n        }\n      }\n    )\n  })\n}\n\n/**\n * Send generic message\n *\n * If message is an object it will be serialized into JSON string\n * before sending.\n *\n * If there is ongoing update that has not yet been finished the message\n * will be sent after that update is finalized.\n *\n * @param {String|Object} message\n * @param {String} recipient - Address of the recipient\n * @example channel.sendMessage(\n *   'hello world',\n *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'\n * )\n */\nfunction sendMessage (message, recipient) {\n  let info = message\n  if (typeof message === 'object') {\n    info = JSON.stringify(message)\n  }\n  const doSend = (channel) => send(channel, {\n    jsonrpc: '2.0',\n    method: 'channels.message',\n    params: { info, to: recipient }\n  })\n  if (this.status() === 'connecting') {\n    const onStatusChanged = (status) => {\n      if (status !== 'connecting') {\n        // For some reason we can't immediately send a message when connection is\n        // established. Thus we wait 500ms which seems to work.\n        setTimeout(() => doSend(this), 500)\n        this.off('statusChanged', onStatusChanged)\n      }\n    }\n    this.on('statusChanged', onStatusChanged)\n  } else {\n    doSend(this)\n  }\n}\n\nasync function reconnect (options, txParams) {\n  const { sign } = options\n\n  return Channel({\n    ...options,\n    reconnectTx: await sign('reconnect', buildTx(txParams, TX_TYPE.channelReconnect).tx)\n  })\n}\n\n/**\n * Channel\n *\n * @function\n * @alias module:@aeternity/aepp-sdk/es/channel/index\n * @rtype Channel\n * @param {Object} options - Channel params\n * @param {String} options.url - Channel url (for example: \"ws://localhost:3001\")\n * @param {String} options.role - Participant role (\"initiator\" or \"responder\")\n * @param {String} options.initiatorId - Initiator's public key\n * @param {String} options.responderId - Responder's public key\n * @param {Number} options.pushAmount - Initial deposit in favour of the responder by the initiator\n * @param {Number} options.initiatorAmount - Amount of tokens the initiator has committed to\n * the channel\n * @param {Number} options.responderAmount - Amount of tokens the responder has committed to\n * the channel\n * @param {Number} options.channelReserve - The minimum amount both peers need to maintain\n * @param {Number} [options.ttl] - Minimum block height to include the channel_create_tx\n * @param {String} options.host - Host of the responder's node\n * @param {Number} options.port - The port of the responders node\n * @param {Number} options.lockPeriod - Amount of blocks for disputing a solo close\n * @param {Number} [options.existingChannelId] - Existing channel id (required if reestablishing a\n * channel)\n * @param {Number} [options.offchainTx] - Offchain transaction (required if reestablishing\n * a channel)\n * @param {Number} [options.timeoutIdle] - The time waiting for a new event to be initiated\n * (default: 600000)\n * @param {Number} [options.timeoutFundingCreate] - The time waiting for the initiator to produce\n * the create channel transaction after the noise session had been established (default: 120000)\n * @param {Number} [options.timeoutFundingSign] - The time frame the other client has to sign an\n * off-chain update after our client had initiated and signed it. This applies only for double\n * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.\n * (default: 120000)\n * @param {Number} [options.timeoutFundingLock] - The time frame the other client has to confirm an\n * on-chain transaction reaching maturity (passing minimum depth) after the local node has detected\n * this. This applies only for double signed on-chain intended updates: channel create transaction,\n * deposit, withdrawal and etc. (default: 360000)\n * @param {Number} [options.timeoutSign] - The time frame the client has to return a signed\n * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)\n * @param {Number} [options.timeoutAccept] - The time frame the other client has to react to an\n * event. This applies for all off-chain updates that are not meant to land on-chain, as well as\n * some special cases: opening a noise connection, mutual closing acknowledgement and\n * reestablishing an existing channel (default: 120000)\n * @param {Number} [options.timeoutInitialized] - the time frame the responder has to accept an\n * incoming noise session. Applicable only for initiator (default: timeout_accept's value)\n * @param {Number} [options.timeoutAwaitingOpen] - The time frame the initiator has to start an\n * outgoing noise session to the responder's node. Applicable only for responder (default:\n * timeout_idle's value)\n * @param {Number} [options.debug=false] - Log websocket communication\n * @param {Function} options.sign - Function which verifies and signs transactions\n * @return {Promise<Object>} Channel instance\n * @example Channel({\n *   url: 'ws://localhost:3001',\n *   role: 'initiator'\n *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   initiatorAmount: 1e18,\n *   responderAmount: 1e18,\n *   pushAmount: 0,\n *   channelReserve: 0,\n *   ttl: 1000,\n *   host: 'localhost',\n *   port: 3002,\n *   lockPeriod: 10,\n *   async sign (tag, tx) => await account.signTransaction(tx)\n * })\n */\nconst Channel = AsyncInit.compose({\n  async init (options) {\n    await initialize(\n      this,\n      options.existingFsmId ? handlers.awaitingReconnection : handlers.awaitingConnection,\n      handlers.channelOpen,\n      options\n    )\n  },\n  methods: {\n    on,\n    off,\n    status,\n    state,\n    round,\n    id,\n    fsmId,\n    update,\n    poi,\n    balances,\n    leave,\n    shutdown,\n    sendMessage,\n    withdraw,\n    deposit,\n    createContract,\n    callContract,\n    callContractStatic,\n    getContractCall,\n    getContractState,\n    disconnect,\n    cleanContractCalls,\n    forceProgress\n  },\n  statics: {\n    reconnect\n  }\n})\n\nexport default Channel\n"],"file":"index.mjs"}