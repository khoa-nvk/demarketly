{"version":3,"sources":["../../src/utils/mptree.ts"],"names":["hash","MerkleTreeHashMismatchError","MissingNodeInTreeError","UnknownPathNibbleError","UnknownNodeLengthError","NodeType","MPTree","nodeHash","node","from","rlpEncode","toString","constructor","binary","rootHash","nodes","Object","fromEntries","map","undefined","entries","forEach","key","type","payload","parseNode","Branch","slice","filter","n","length","Extension","isEqual","tree","path","nibble","parseInt","Leaf","includes","serialize","mptHash","value","get","searchFrom","substr"],"mappings":"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","sourcesContent":["/*\n * ISC License (ISC)\n * Copyright (c) 2021 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport { encode as rlpEncode } from 'rlp'\nimport type { Input } from 'rlp'\nimport { hash } from './crypto-ts'\nimport {\n  MerkleTreeHashMismatchError,\n  MissingNodeInTreeError,\n  UnknownPathNibbleError,\n  UnknownNodeLengthError\n} from './errors'\n\nenum NodeType {\n  Branch,\n  Extension,\n  Leaf\n}\n\nexport type MPTreeBinary = [Buffer, Array<[Buffer, Buffer[]]>]\n\nexport default class MPTree {\n  private readonly rootHash: string\n  private readonly nodes: { [key: string]: Buffer[] }\n\n  private static nodeHash (node: Input): string {\n    return Buffer.from(hash(rlpEncode(node))).toString('hex')\n  }\n\n  /**\n   * Deserialize Merkle Patricia Tree\n   * @rtype (binary: Array) => MPTree\n   * @param {Array} binary - Binary\n   * @return {MPTree} Merkle Patricia Tree\n   */\n  constructor (binary: MPTreeBinary) {\n    this.rootHash = binary[0].toString('hex')\n    this.nodes = Object.fromEntries(\n      binary[1].map((node) => [node[0].toString('hex'), node[1]])\n    )\n\n    if (this.nodes[this.rootHash] === undefined) throw new MissingNodeInTreeError('Can\\'t find a node by root hash')\n    Object.entries(this.nodes).forEach(([key, node]) => {\n      if (MPTree.nodeHash(node) !== key) throw new MerkleTreeHashMismatchError()\n      const { type, payload } = MPTree.parseNode(node)\n      switch (type) {\n        case NodeType.Branch:\n          payload\n            .slice(0, 16)\n            .filter(n => n.length)\n            .forEach((n) => {\n              if (this.nodes[n.toString('hex')] === undefined) {\n                throw new MissingNodeInTreeError('Can\\'t find a node by hash in branch node')\n              }\n            })\n          break\n        case NodeType.Extension:\n          if (this.nodes[payload[0].toString('hex')] === undefined) {\n            throw new MissingNodeInTreeError('Can\\'t find a node by hash in extension node')\n          }\n      }\n    })\n  }\n\n  isEqual (tree: MPTree): boolean {\n    return this.rootHash === tree.rootHash\n  }\n\n  private static parseNode (node: Buffer[]): { type: NodeType, payload: Buffer[], path: string | null } {\n    switch (node.length) {\n      case 17:\n        return { type: NodeType.Branch, payload: node, path: null }\n      case 2: {\n        const path = node[0].toString('hex')\n        const nibble = parseInt(path[0], 16)\n        if (nibble > 3) throw new UnknownPathNibbleError(nibble)\n        const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf\n        const slice = [0, 2].includes(nibble) ? 2 : 1\n        return { type, payload: [node[1]], path: path.slice(slice) }\n      }\n      default:\n        throw new UnknownNodeLengthError(node.length)\n    }\n  }\n\n  /**\n   * Serialize Merkle Patricia Tree\n   * @rtype () => Array\n   * @return {Array} Binary\n   */\n  serialize (): MPTreeBinary {\n    return [\n      Buffer.from(this.rootHash, 'hex'),\n      Object.entries(this.nodes).map(([mptHash, value]) => ([\n        Buffer.from(mptHash, 'hex'),\n        value\n      ]))\n    ]\n  }\n\n  /**\n   * Retrieve value from Merkle Patricia Tree\n   * @rtype (key: String) => Buffer\n   * @param {String} key - The key of the element to retrieve\n   * @return {Buffer} Value associated to the specified key\n   */\n  get (key: string): Buffer | undefined {\n    let searchFrom = this.rootHash\n    while (true) {\n      const { type, payload, path } = MPTree.parseNode(this.nodes[searchFrom])\n      switch (type) {\n        case NodeType.Branch:\n          if (key.length === 0) return payload[16]\n          searchFrom = payload[parseInt(key[0], 16)].toString('hex')\n          key = key.substr(1)\n          break\n        case NodeType.Extension:\n          if (key.substr(0, path?.length) !== path) return undefined\n          searchFrom = payload[0].toString('hex')\n          key = key.substr(path.length)\n          break\n        case NodeType.Leaf:\n          if (path !== key) return undefined\n          return payload[0]\n      }\n    }\n  }\n}\n"],"file":"mptree.mjs"}