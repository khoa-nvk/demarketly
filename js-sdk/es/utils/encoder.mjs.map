{"version":3,"sources":["../../src/utils/encoder.ts"],"names":["bs58","DecodeError","EncodeError","InvalidChecksumError","PayloadLengthError","PrefixMismatchError","sha256hash","input","sha256","update","digest","base64Types","base58Types","typesLength","ak","ct","ok","ensureValidLength","data","type","length","getChecksum","payload","slice","addChecksum","from","concat","getPayload","buffer","equals","base64","encode","toString","decode","string","base58","requiredPrefix","prefix","encodedPayload","extra","split","decoder","includes","encoder"],"mappings":"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","sourcesContent":["import * as bs58 from 'bs58'\nimport { sha256 } from 'sha.js'\nimport {\n  DecodeError,\n  EncodeError,\n  InvalidChecksumError,\n  PayloadLengthError,\n  PrefixMismatchError\n} from './errors'\n\n/**\n * Calculate SHA256 hash of `input`\n * @rtype (input: String) => hash: String\n * @param {Buffer|String} input - Data to hash\n * @return {String} Hash\n */\nexport function sha256hash (input: Buffer | string) {\n  return new sha256().update(input).digest()\n}\n\n// based on https://github.com/aeternity/protocol/blob/master/node/api/api_encoding.md\nconst base64Types = ['ba', 'cb', 'or', 'ov', 'pi', 'ss', 'cs', 'ck', 'cv', 'st', 'tx']\nconst base58Types = ['ak', 'bf', 'bs', 'bx', 'ch', 'cm', 'ct', 'kh', 'mh', 'nm', 'ok', 'oq', 'pp', 'sg', 'th']\n// TODO: add all types with a fixed length\nconst typesLength: { [name: string]: number } = {\n  ak: 32,\n  ct: 32,\n  ok: 32\n} as const\n\nfunction ensureValidLength (data: Buffer | string, type: string) {\n  if (!typesLength[type]) return\n  if (data.length === typesLength[type]) return\n  throw new PayloadLengthError(`Payload should be ${typesLength[type]} bytes, got ${data.length} instead`)\n}\n\nconst getChecksum = (payload: Buffer | string) => sha256hash(sha256hash(payload)).slice(0, 4)\n\nconst addChecksum = (input: Buffer | string) => {\n  const payload = Buffer.from(input)\n  return Buffer.concat([payload, getChecksum(payload)])\n}\n\nfunction getPayload (buffer: Buffer) {\n  const payload = buffer.slice(0, -4)\n  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError()\n  return payload\n}\n\nconst base64 = {\n  encode: (buffer: Buffer | string) => addChecksum(buffer).toString('base64'),\n  decode: (string: string) => getPayload(Buffer.from(string, 'base64'))\n}\n\nconst base58 = {\n  encode: (buffer: Buffer | string) => bs58.encode(addChecksum(buffer)),\n  decode: (string: string) => getPayload(bs58.decode(string))\n}\n\n/**\n * Decode data using the default encoding/decoding algorithm\n * @function\n * @alias module:@aeternity/aepp-sdk/es/tx/builder/helpers\n * @param {string} data An Base58/64check encoded and prefixed string (ex tx_..., sg_..., ak_....)\n * @param {string} [requiredPrefix] Ensure that data have this prefix\n * @return {Buffer} Decoded data\n */\nexport function decode (data: string, requiredPrefix?: string) {\n  const [prefix, encodedPayload, extra] = data.split('_')\n  if (!encodedPayload) throw new DecodeError(`Encoded string missing payload: ${data}`)\n  if (extra) throw new DecodeError(`Encoded string have extra parts: ${data}`)\n  if (requiredPrefix && requiredPrefix !== prefix) {\n    throw new PrefixMismatchError(prefix, requiredPrefix)\n  }\n  const decoder = (base64Types.includes(prefix) && base64.decode) ||\n    (base58Types.includes(prefix) && base58.decode)\n  if (!decoder) {\n    throw new DecodeError(`Encoded string have unknown type: ${prefix}`)\n  }\n  const payload = decoder(encodedPayload)\n  ensureValidLength(payload, prefix)\n  return payload\n}\n\n/**\n * Encode data using the default encoding/decoding algorithm\n * @function\n * @alias module:@aeternity/aepp-sdk/es/tx/builder/helpers\n * @param {Buffer|String} data  An decoded data\n * @param {string} type Prefix of Transaction\n * @return {String} Encoded string Base58check or Base64check data\n */\nexport function encode (data: Buffer | string, type: string) {\n  const encoder = (base64Types.includes(type) && base64.encode) ||\n    (base58Types.includes(type) && base58.encode)\n  if (!encoder) {\n    throw new EncodeError(`Unknown type: ${type}`)\n  }\n  ensureValidLength(data, type)\n  return `${type}_${encoder(data)}`\n}\n"],"file":"encoder.mjs"}