{"version":3,"sources":["../../src/utils/bytes.ts"],"names":["BigNumber","NoSerializerFoundError","TypeError","isBase64","isHex","bigNumberToByteArray","x","isInteger","toFixed","hexString","toString","length","from","toBytes","val","big","undefined","Number","isBigNumber","str2buf","str","enc"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,SAAP,MAAsB,cAAtB;SACSC,sB,EAAwBC,S;SACxBC,Q,EAAUC,K;AAEnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,oBAAT,CAA+BC,CAA/B,EAAqD;AAC1D,MAAI,CAACA,CAAC,CAACC,SAAF,EAAL,EAAoB,MAAM,IAAIL,SAAJ,CAAe,iCAAgCI,CAAC,CAACE,OAAF,EAAY,EAA3D,CAAN;AACpB,MAAIC,SAAS,GAAGH,CAAC,CAACI,QAAF,CAAW,EAAX,CAAhB;AACA,MAAID,SAAS,CAACE,MAAV,GAAmB,CAAnB,KAAyB,CAA7B,EAAgCF,SAAS,GAAG,MAAMA,SAAlB;AAChC,SAAO,QAAOG,IAAP,CAAYH,SAAZ,EAAuB,KAAvB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,OAAT,CAAkBC,GAAlB,EAA0F;AAAA,MAA9BC,GAA8B,uEAAf,KAAe;AAC/F;AACA;AACA;AAEA,MAAID,GAAG,KAAKE,SAAR,IAAqBF,GAAG,KAAK,IAAjC,EAAuC,OAAO,QAAOF,IAAP,CAAY,EAAZ,CAAP;;AACvC,MAAIK,MAAM,CAACV,SAAP,CAAiBO,GAAjB,KAAyBd,SAAS,CAACkB,WAAV,CAAsBJ,GAAtB,CAAzB,IAAuDC,GAA3D,EAAgE;AAC9D,QAAI,CAACf,SAAS,CAACkB,WAAV,CAAsBJ,GAAtB,CAAL,EAAiCA,GAAG,GAAG,IAAId,SAAJ,CAAcc,GAAd,CAAN;AACjC,WAAOT,oBAAoB,CAACS,GAAD,CAA3B;AACD;;AACD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAO,QAAOF,IAAP,CAAYE,GAAZ,CAAP;AACD;;AACD,QAAM,IAAIb,sBAAJ,EAAN;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASkB,OAAT,CAAkBC,GAAlB,EAA+BC,GAA/B,EAA6D;AAAA;;AAClE,SAAO,QAAOT,IAAP,CACLQ,GADK,UAELC,GAFK,aAELA,GAFK,cAELA,GAFK,GAEGjB,KAAK,CAACgB,GAAD,CAAL,GAAa,KAAb,GAAqBJ,SAFxB,uCAEuCb,QAAQ,CAACiB,GAAD,CAAR,GAAgB,QAAhB,GAA2BJ,SAFlE,CAAP;AAID","sourcesContent":["/*\n * ISC License (ISC)\n * Copyright 2018 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\nimport BigNumber from 'bignumber.js'\nimport { NoSerializerFoundError, TypeError } from './errors'\nimport { isBase64, isHex } from './string'\n\n/**\n * Bytes module\n * @module @aeternity/aepp-sdk/es/utils/bytes\n * @example import { Crypto } from '@aeternity/aepp-sdk'\n */\n\n/**\n * Convert bignumber to byte array\n * @param {BigNumber} x bignumber instance\n * @return Buffer\n */\nexport function bigNumberToByteArray (x: BigNumber): Buffer {\n  if (!x.isInteger()) throw new TypeError(`Unexpected not integer value: ${x.toFixed()}`)\n  let hexString = x.toString(16)\n  if (hexString.length % 2 === 1) hexString = '0' + hexString\n  return Buffer.from(hexString, 'hex')\n}\n\n/**\n * Convert string, number, or BigNumber to byte array\n * @param {null|string|number|BigNumber} val\n * @param {boolean} big enables force conversion to BigNumber\n * @return Buffer\n */\nexport function toBytes (val?: null | string | number | BigNumber, big: boolean = false): Buffer {\n  // Encode a value to bytes.\n  // If the value is an int it will be encoded as bytes big endian\n  // Raises ValueError if the input is not an int or string\n\n  if (val === undefined || val === null) return Buffer.from([])\n  if (Number.isInteger(val) || BigNumber.isBigNumber(val) || big) {\n    if (!BigNumber.isBigNumber(val)) val = new BigNumber(val)\n    return bigNumberToByteArray(val)\n  }\n  if (typeof val === 'string') {\n    return Buffer.from(val)\n  }\n  throw new NoSerializerFoundError()\n}\n\n/**\n * Convert a string to a Buffer.  If encoding is not specified, hex-encoding\n * will be used if the input is valid hex.  If the input is valid base64 but\n * not valid hex, base64 will be used.  Otherwise, utf8 will be used.\n * @param {string} str String to be converted.\n * @param {string} [enc] Encoding of the input string.\n * @return {buffer} Buffer containing the input data.\n */\nexport function str2buf (str: string, enc?: BufferEncoding): Buffer {\n  return Buffer.from(\n    str,\n    enc ?? (isHex(str) ? 'hex' : undefined) ?? (isBase64(str) ? 'base64' : undefined)\n  )\n}\n"],"file":"bytes.mjs"}