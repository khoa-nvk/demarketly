{"version":3,"sources":["../../src/utils/other.ts"],"names":["snakeToPascal","pascalToSnake","pause","duration","Promise","resolve","setTimeout","mapObject","object","fn","Object","fromEntries","entries","map","filterObject","filter","traverseKeys","Array","isArray","i","key","value","snakizeKeys","bind","pascalizeKeys"],"mappings":"SAASA,a,EAAeC,a;AAExB,OAAO,MAAMC,KAAK,GAAG,MAAOC,QAAP,IACnB,MAAM,IAAIC,OAAJ,CAAYC,OAAO,IAAIC,UAAU,CAACD,OAAD,EAAUF,QAAV,CAAjC,CADD;AAGP,OAAO,MAAMI,SAAS,GAAG,CACvBC,MADuB,EAEvBC,EAFuB,KAGZC,MAAM,CAACC,WAAP,CAAmBD,MAAM,CAACE,OAAP,CAAeJ,MAAf,EAAuBK,GAAvB,CAA2BJ,EAA3B,CAAnB,CAHN;AAKP,OAAO,MAAMK,YAAY,GAAG,CAC1BN,MAD0B,EAE1BC,EAF0B,KAGfC,MAAM,CAACC,WAAP,CAAmBD,MAAM,CAACE,OAAP,CAAeJ,MAAf,EAAuBO,MAAvB,CAA8BN,EAA9B,CAAnB,CAHN;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMO,YAAY,GAAG,CAACP,EAAD,EAAeD,MAAf,KAAoC;AAC9D,MAAI,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAA7C,EAAmD,OAAOA,MAAP;AACnD,MAAIS,KAAK,CAACC,OAAN,CAAcV,MAAd,CAAJ,EAA2B,OAAOA,MAAM,CAACK,GAAP,CAAWM,CAAC,IAAIH,YAAY,CAACP,EAAD,EAAKU,CAAL,CAA5B,CAAP;AAC3B,SAAOZ,SAAS,CAACC,MAAD,EAAS;AAAA,QAAC,CAACY,GAAD,EAAMC,KAAN,CAAD;AAAA,WAAiC,CACxDZ,EAAE,CAACW,GAAD,CADsD,EAC/CJ,YAAY,CAACP,EAAD,EAAKY,KAAL,CADmC,CAAjC;AAAA,GAAT,CAAhB;AAGD,CANM;AAQP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAGN,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAwBtB,aAAxB,CAApB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMuB,aAAa,GAAGR,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAwBvB,aAAxB,CAAtB","sourcesContent":["import { snakeToPascal, pascalToSnake } from './string'\n\nexport const pause = async (duration: number): Promise<void> =>\n  await new Promise(resolve => setTimeout(resolve, duration))\n\nexport const mapObject = (\n  object: object,\n  fn: (value: [string, any], index: number, array: Array<[string, any]>) => Array<[string, any]>\n): object => Object.fromEntries(Object.entries(object).map(fn))\n\nexport const filterObject = (\n  object: object,\n  fn: (value: [string, any], index: number, array: Array<[string, any]>) => boolean\n): object => Object.fromEntries(Object.entries(object).filter(fn))\n\n/**\n * Key traversal metafunction\n * @static\n * @function\n * @rtype (fn: (s: String) => String) => (o: Object) => Object\n * @param {Function} fn - Key transformation function\n * @param {Object} object - Object to traverse\n * @return {Object} Transformed object\n */\nexport const traverseKeys = (fn: Function, object: any): any => {\n  if (typeof object !== 'object' || object === null) return object\n  if (Array.isArray(object)) return object.map(i => traverseKeys(fn, i))\n  return mapObject(object, ([key, value]: [string, any]) => [\n    fn(key), traverseKeys(fn, value)\n  ])\n}\n\n/**\n * snake_case key traversal\n * @static\n * @rtype (o: Object) => Object\n * @param {Object} object - Object to traverse\n * @return {Object} Transformed object\n * @see pascalToSnake\n */\nexport const snakizeKeys = traverseKeys.bind(null, pascalToSnake)\n\n/**\n * PascalCase key traversal\n * @static\n * @rtype (o: Object) => Object\n * @param {Object} object - Object to traverse\n * @return {Object} Transformed object\n * @see snakeToPascal\n */\nexport const pascalizeKeys = traverseKeys.bind(null, snakeToPascal)\n"],"file":"other.mjs"}