(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bignumber.js"), require("rlp"), require("bs58"), require("buffer"), require("tweetnacl"), require("varuint-bitcoin"), require("@aeternity/uuid"), require("@aeternity/argon2-browser/dist/argon2-bundled.min.js"), require("tweetnacl-auth"), require("bip32-path"), require("aes-js"), require("@aeternity/aepp-calldata"), require("@azure/core-client"), require("@azure/core-rest-pipeline"), require("json-bigint"), require("websocket"), require("events"));
	else if(typeof define === 'function' && define.amd)
		define(["bignumber.js", "rlp", "bs58", "buffer", "tweetnacl", "varuint-bitcoin", "@aeternity/uuid", "@aeternity/argon2-browser/dist/argon2-bundled.min.js", "tweetnacl-auth", "bip32-path", "aes-js", "@aeternity/aepp-calldata", "@azure/core-client", "@azure/core-rest-pipeline", "json-bigint", "websocket", "events"], factory);
	else if(typeof exports === 'object')
		exports["Ae"] = factory(require("bignumber.js"), require("rlp"), require("bs58"), require("buffer"), require("tweetnacl"), require("varuint-bitcoin"), require("@aeternity/uuid"), require("@aeternity/argon2-browser/dist/argon2-bundled.min.js"), require("tweetnacl-auth"), require("bip32-path"), require("aes-js"), require("@aeternity/aepp-calldata"), require("@azure/core-client"), require("@azure/core-rest-pipeline"), require("json-bigint"), require("websocket"), require("events"));
	else
		root["Ae"] = factory(root["bignumber.js"], root["rlp"], root["bs58"], root["buffer"], root["tweetnacl"], root["varuint-bitcoin"], root["@aeternity/uuid"], root["@aeternity/argon2-browser/dist/argon2-bundled.min.js"], root["tweetnacl-auth"], root["bip32-path"], root["aes-js"], root["@aeternity/aepp-calldata"], root["@azure/core-client"], root["@azure/core-rest-pipeline"], root["json-bigint"], root["websocket"], root["events"]);
})(global, (__WEBPACK_EXTERNAL_MODULE__5192__, __WEBPACK_EXTERNAL_MODULE__3485__, __WEBPACK_EXTERNAL_MODULE__3783__, __WEBPACK_EXTERNAL_MODULE__9408__, __WEBPACK_EXTERNAL_MODULE__79__, __WEBPACK_EXTERNAL_MODULE__7480__, __WEBPACK_EXTERNAL_MODULE__3983__, __WEBPACK_EXTERNAL_MODULE__7289__, __WEBPACK_EXTERNAL_MODULE__9882__, __WEBPACK_EXTERNAL_MODULE__1986__, __WEBPACK_EXTERNAL_MODULE__8236__, __WEBPACK_EXTERNAL_MODULE__7946__, __WEBPACK_EXTERNAL_MODULE__4711__, __WEBPACK_EXTERNAL_MODULE__5039__, __WEBPACK_EXTERNAL_MODULE__2716__, __WEBPACK_EXTERNAL_MODULE__8079__, __WEBPACK_EXTERNAL_MODULE__3735__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

const util = __webpack_require__(9488)

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  const o0 = v[a] + v[b]
  let o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  let o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  let o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  const x0 = m[ix]
  const x1 = m[ix + 1]
  const y0 = m[iy]
  const y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  let xor0 = v[d] ^ v[a]
  let xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
const BLAKE2B_IV32 = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,
  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
])

const SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,
  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,
  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,
  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,
  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,
  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,
  1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function (x) {
    return x * 2
  })
)

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
const v = new Uint32Array(32)
const m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  let i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// reusable parameterBlock
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0, //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0, //  4: leaf length, sequential mode
  0,
  0,
  0,
  0, //  8: node offset
  0,
  0,
  0,
  0, // 12: node offset
  0,
  0,
  0,
  0, // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0, // 20: rfu
  0,
  0,
  0,
  0, // 24: rfu
  0,
  0,
  0,
  0, // 28: rfu
  0,
  0,
  0,
  0, // 32: salt
  0,
  0,
  0,
  0, // 36: salt
  0,
  0,
  0,
  0, // 40: salt
  0,
  0,
  0,
  0, // 44: salt
  0,
  0,
  0,
  0, // 48: personal
  0,
  0,
  0,
  0, // 52: personal
  0,
  0,
  0,
  0, // 56: personal
  0,
  0,
  0,
  0 // 60: personal
])

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
// Takes an optinal Uint8Array salt
// Takes an optinal Uint8Array personal
function blake2bInit (outlen, key, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }
  if (salt && salt.length !== 16) {
    throw new Error('Illegal salt, expected Uint8Array with length is 16')
  }
  if (personal && personal.length !== 16) {
    throw new Error('Illegal personal, expected Uint8Array with length is 16')
  }

  // state, 'param block'
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize parameterBlock before usage
  parameterBlock.fill(0)
  parameterBlock[0] = outlen
  if (key) parameterBlock[1] = key.length
  parameterBlock[2] = 1 // fanout
  parameterBlock[3] = 1 // depth
  if (salt) parameterBlock.set(salt, 32)
  if (personal) parameterBlock.set(personal, 48)

  // initialize hash state
  for (let i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)
  }

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  const out = new Uint8Array(ctx.outlen)
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2b (input, key, outlen, salt, personal) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)
  if (salt) {
    salt = util.normalizeInput(salt)
  }
  if (personal) {
    personal = util.normalizeInput(personal)
  }

  // do the math
  const ctx = blake2bInit(outlen, key, salt, personal)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2bHex (input, key, outlen, salt, personal) {
  const output = blake2b(input, key, outlen, salt, personal)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}


/***/ }),

/***/ 9488:
/***/ ((module) => {

const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  let ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (typeof input === 'string') {
    const encoder = new TextEncoder()
    ret = encoder.encode(input)
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map
    .call(bytes, function (n) {
      return (n < 16 ? '0' : '') + n.toString(16)
    })
    .join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  let msg = '\n' + label + ' = '
  for (let i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  let startMs = new Date().getTime()

  const input = new Uint8Array(N)
  for (let i = 0; i < N; i++) {
    input[i] = i % 256
  }
  const genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (let i = 0; i < M; i++) {
    const hashHex = hashFn(input)
    const hashMs = new Date().getTime()
    const ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(
      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
    )
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}


/***/ }),

/***/ 3536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(1910);

module.exports = parent;


/***/ }),

/***/ 991:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(7690);
var entryVirtual = __webpack_require__(5703);

module.exports = entryVirtual('Array').includes;


/***/ }),

/***/ 8557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(7046);
var arrayMethod = __webpack_require__(991);
var stringMethod = __webpack_require__(1631);

var ArrayPrototype = Array.prototype;
var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.includes;
  if (it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.includes)) return arrayMethod;
  if (typeof it == 'string' || it === StringPrototype || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.includes)) {
    return stringMethod;
  } return own;
};


/***/ }),

/***/ 8171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(6450);
var path = __webpack_require__(4058);

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;


/***/ }),

/***/ 1631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(1035);
var entryVirtual = __webpack_require__(5703);

module.exports = entryVirtual('String').includes;


/***/ }),

/***/ 3685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(621);


/***/ }),

/***/ 621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(3536);

module.exports = parent;


/***/ }),

/***/ 4883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(7475);
var tryToString = __webpack_require__(9826);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8479:
/***/ ((module) => {

module.exports = function () { /* empty */ };


/***/ }),

/***/ 6059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(941);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 1692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(4529);
var toAbsoluteIndex = __webpack_require__(9413);
var lengthOfArrayLike = __webpack_require__(623);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 2532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 9697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(2885);
var isCallable = __webpack_require__(7475);
var classofRaw = __webpack_require__(2532);
var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7772:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(9813);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ 2029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(5746);
var definePropertyModule = __webpack_require__(5988);
var createPropertyDescriptor = __webpack_require__(1887);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 1887:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 5609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(1899);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 5746:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5981);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(1899);
var isObject = __webpack_require__(941);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(626);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 3385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(1899);
var userAgent = __webpack_require__(2861);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 5703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(4058);

module.exports = function (CONSTRUCTOR) {
  return path[CONSTRUCTOR + 'Prototype'];
};


/***/ }),

/***/ 6887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var apply = __webpack_require__(9730);
var uncurryThis = __webpack_require__(5329);
var isCallable = __webpack_require__(7475);
var getOwnPropertyDescriptor = (__webpack_require__(9677).f);
var isForced = __webpack_require__(7252);
var path = __webpack_require__(4058);
var bind = __webpack_require__(6843);
var createNonEnumerableProperty = __webpack_require__(2029);
var hasOwn = __webpack_require__(953);

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

    // bind timers to global for call from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
    // wrap global constructors for prevent changs in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ 5981:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 9730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(8285);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es-x/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 6843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);
var aCallable = __webpack_require__(4883);
var NATIVE_BIND = __webpack_require__(8285);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 8285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5981);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 8834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(8285);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 5329:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(8285);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(4058);
var global = __webpack_require__(1899);
var isCallable = __webpack_require__(7475);

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 4229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(4883);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 1899:
/***/ ((module) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);
var toObject = __webpack_require__(9678);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 2840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(5746);
var fails = __webpack_require__(5981);
var createElement = __webpack_require__(1333);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 7026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);
var fails = __webpack_require__(5981);
var classof = __webpack_require__(2532);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 7475:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 7252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5981);
var isCallable = __webpack_require__(7475);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(7475);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 2529:
/***/ ((module) => {

module.exports = true;


/***/ }),

/***/ 685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(941);
var classof = __webpack_require__(2532);
var wellKnownSymbol = __webpack_require__(9813);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 6664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(626);
var isCallable = __webpack_require__(7475);
var isPrototypeOf = __webpack_require__(7046);
var USE_SYMBOL_AS_UID = __webpack_require__(2302);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(3057);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 5331:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 2497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(3385);
var fails = __webpack_require__(5981);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isRegExp = __webpack_require__(685);

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ 5988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(5746);
var IE8_DOM_DEFINE = __webpack_require__(2840);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3937);
var anObject = __webpack_require__(6059);
var toPropertyKey = __webpack_require__(3894);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 9677:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(5746);
var call = __webpack_require__(8834);
var propertyIsEnumerableModule = __webpack_require__(6760);
var createPropertyDescriptor = __webpack_require__(1887);
var toIndexedObject = __webpack_require__(4529);
var toPropertyKey = __webpack_require__(3894);
var hasOwn = __webpack_require__(953);
var IE8_DOM_DEFINE = __webpack_require__(2840);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 7046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 6760:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(8834);
var isCallable = __webpack_require__(7475);
var isObject = __webpack_require__(941);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4058:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 8219:
/***/ ((module) => {

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 3030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(1899);
var defineGlobalProperty = __webpack_require__(5609);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 8726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(2529);
var store = __webpack_require__(3030);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.24.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.24.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 9413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(2435);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 4529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7026);
var requireObjectCoercible = __webpack_require__(8219);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 2435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trunc = __webpack_require__(5331);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 3057:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(2435);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 9678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(8219);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 6935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(8834);
var isObject = __webpack_require__(941);
var isSymbol = __webpack_require__(6664);
var getMethod = __webpack_require__(4229);
var ordinaryToPrimitive = __webpack_require__(9811);
var wellKnownSymbol = __webpack_require__(9813);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 3894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(6935);
var isSymbol = __webpack_require__(6664);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2885:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 5803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(9697);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 9826:
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 9418:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(5329);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 2302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(2497);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 3937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(5746);
var fails = __webpack_require__(5981);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 9813:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(1899);
var shared = __webpack_require__(8726);
var hasOwn = __webpack_require__(953);
var uid = __webpack_require__(9418);
var NATIVE_SYMBOL = __webpack_require__(2497);
var USE_SYMBOL_AS_UID = __webpack_require__(2302);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 7690:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var $includes = (__webpack_require__(1692).includes);
var fails = __webpack_require__(5981);
var addToUnscopables = __webpack_require__(8479);

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 6450:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(6887);
var DESCRIPTORS = __webpack_require__(5746);
var defineProperty = (__webpack_require__(5988).f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ 1035:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var uncurryThis = __webpack_require__(5329);
var notARegExp = __webpack_require__(344);
var requireObjectCoercible = __webpack_require__(8219);
var toString = __webpack_require__(5803);
var correctIsRegExpLogic = __webpack_require__(7772);

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ 3778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(8557);

module.exports = parent;


/***/ }),

/***/ 1910:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(8171);

module.exports = parent;


/***/ }),

/***/ 4378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(3837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(5717);
}


/***/ }),

/***/ 5717:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 9509:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9408)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 4189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(9509).Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ 7499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(4378)
var Hash = __webpack_require__(4189)
var Buffer = (__webpack_require__(9509).Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 7946:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7946__;

/***/ }),

/***/ 7289:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7289__;

/***/ }),

/***/ 3983:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3983__;

/***/ }),

/***/ 4711:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__4711__;

/***/ }),

/***/ 5039:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__5039__;

/***/ }),

/***/ 8236:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8236__;

/***/ }),

/***/ 5192:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__5192__;

/***/ }),

/***/ 1986:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1986__;

/***/ }),

/***/ 3783:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3783__;

/***/ }),

/***/ 9408:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__9408__;

/***/ }),

/***/ 3735:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3735__;

/***/ }),

/***/ 2716:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__2716__;

/***/ }),

/***/ 3485:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3485__;

/***/ }),

/***/ 79:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__79__;

/***/ }),

/***/ 9882:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__9882__;

/***/ }),

/***/ 7480:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7480__;

/***/ }),

/***/ 8079:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8079__;

/***/ }),

/***/ 8118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3778);

/***/ }),

/***/ 7445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3685);

/***/ }),

/***/ 9689:
/***/ ((module) => {

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

module.exports = _classApplyDescriptorGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6906:
/***/ ((module) => {

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
  }
}

module.exports = _classApplyDescriptorSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6412:
/***/ ((module) => {

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }

  return privateMap.get(receiver);
}

module.exports = _classExtractFieldDescriptor, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorGet = __webpack_require__(9689);

var classExtractFieldDescriptor = __webpack_require__(6412);

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
  return classApplyDescriptorGet(receiver, descriptor);
}

module.exports = _classPrivateFieldGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorSet = __webpack_require__(6906);

var classExtractFieldDescriptor = __webpack_require__(6412);

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
  classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}

module.exports = _classPrivateFieldSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 1125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Object$defineProperty = __webpack_require__(7445);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ABI_VERSIONS": () => (/* reexport */ ABI_VERSIONS),
  "AE_AMOUNT_FORMATS": () => (/* reexport */ AE_AMOUNT_FORMATS),
  "AMOUNT": () => (/* reexport */ AMOUNT),
  "AccountBase": () => (/* reexport */ AccountBase),
  "AccountError": () => (/* reexport */ AccountError),
  "AeSdk": () => (/* reexport */ AeSdk),
  "AeSdkAepp": () => (/* reexport */ AeSdkAepp),
  "AeSdkBase": () => (/* reexport */ src_AeSdkBase),
  "AeSdkWallet": () => (/* reexport */ AeSdkWallet),
  "AensError": () => (/* reexport */ AensError),
  "AensPointerContextError": () => (/* reexport */ AensPointerContextError),
  "AeppError": () => (/* reexport */ AeppError),
  "AlreadyConnectedError": () => (/* reexport */ AlreadyConnectedError),
  "AmbiguousEventDefinitionError": () => (/* reexport */ AmbiguousEventDefinitionError),
  "ArgumentCountMismatchError": () => (/* reexport */ ArgumentCountMismatchError),
  "ArgumentError": () => (/* reexport */ ArgumentError),
  "BaseError": () => (/* reexport */ BaseError),
  "BrowserRuntimeConnection": () => (/* reexport */ BrowserRuntimeConnection),
  "BrowserWindowMessageConnection": () => (/* reexport */ BrowserWindowMessageConnection),
  "BytecodeMismatchError": () => (/* reexport */ BytecodeMismatchError),
  "CLIENT_TTL": () => (/* reexport */ CLIENT_TTL),
  "Channel": () => (/* reexport */ channel_Channel),
  "ChannelCallError": () => (/* reexport */ ChannelCallError),
  "ChannelConnectionError": () => (/* reexport */ ChannelConnectionError),
  "ChannelError": () => (/* reexport */ ChannelError),
  "ChannelPingTimedOutError": () => (/* reexport */ ChannelPingTimedOutError),
  "Compiler": () => (/* reexport */ Compiler),
  "CompilerError": () => (/* reexport */ CompilerError),
  "ContractError": () => (/* reexport */ ContractError),
  "CryptographyError": () => (/* reexport */ CryptographyError),
  "DRY_RUN_ACCOUNT": () => (/* reexport */ DRY_RUN_ACCOUNT),
  "DecodeError": () => (/* reexport */ DecodeError),
  "DerivationError": () => (/* reexport */ DerivationError),
  "DryRunError": () => (/* reexport */ DryRunError),
  "DuplicateContractError": () => (/* reexport */ DuplicateContractError),
  "DuplicateNodeError": () => (/* reexport */ DuplicateNodeError),
  "Encoding": () => (/* reexport */ Encoding),
  "FIELD_TYPES": () => (/* reexport */ FIELD_TYPES),
  "GAS_MAX": () => (/* reexport */ GAS_MAX),
  "ID_TAG": () => (/* reexport */ ID_TAG),
  "ID_TAG_PREFIX": () => (/* reexport */ ID_TAG_PREFIX),
  "IllegalArgumentError": () => (/* reexport */ IllegalArgumentError),
  "IllegalBidFeeError": () => (/* reexport */ IllegalBidFeeError),
  "InactiveContractError": () => (/* reexport */ InactiveContractError),
  "InsufficientBalanceError": () => (/* reexport */ InsufficientBalanceError),
  "InsufficientNameFeeError": () => (/* reexport */ InsufficientNameFeeError),
  "InternalError": () => (/* reexport */ InternalError),
  "InvalidAensNameError": () => (/* reexport */ InvalidAensNameError),
  "InvalidAuthDataError": () => (/* reexport */ InvalidAuthDataError),
  "InvalidChecksumError": () => (/* reexport */ InvalidChecksumError),
  "InvalidKeypairError": () => (/* reexport */ InvalidKeypairError),
  "InvalidMethodInvocationError": () => (/* reexport */ InvalidMethodInvocationError),
  "InvalidPasswordError": () => (/* reexport */ InvalidPasswordError),
  "InvalidRpcMessageError": () => (/* reexport */ InvalidRpcMessageError),
  "InvalidSignatureError": () => (/* reexport */ InvalidSignatureError),
  "InvalidTxError": () => (/* reexport */ InvalidTxError),
  "InvalidTxParamsError": () => (/* reexport */ InvalidTxParamsError),
  "MAX_AUTH_FUN_GAS": () => (/* reexport */ MAX_AUTH_FUN_GAS),
  "MESSAGE_DIRECTION": () => (/* reexport */ MESSAGE_DIRECTION),
  "METHODS": () => (/* reexport */ METHODS),
  "MIN_GAS_PRICE": () => (/* reexport */ MIN_GAS_PRICE),
  "MemoryAccount": () => (/* reexport */ AccountMemory),
  "MerkleTreeHashMismatchError": () => (/* reexport */ MerkleTreeHashMismatchError),
  "MissingCallbackError": () => (/* reexport */ MissingCallbackError),
  "MissingContractAddressError": () => (/* reexport */ MissingContractAddressError),
  "MissingContractDefError": () => (/* reexport */ MissingContractDefError),
  "MissingEventDefinitionError": () => (/* reexport */ MissingEventDefinitionError),
  "MissingFunctionNameError": () => (/* reexport */ MissingFunctionNameError),
  "MissingNodeInTreeError": () => (/* reexport */ MissingNodeInTreeError),
  "MissingParamError": () => (/* reexport */ MissingParamError),
  "NAME_BID_MAX_LENGTH": () => (/* reexport */ NAME_BID_MAX_LENGTH),
  "NAME_BID_RANGES": () => (/* reexport */ NAME_BID_RANGES),
  "NAME_BID_TIMEOUT_BLOCKS": () => (/* reexport */ NAME_BID_TIMEOUT_BLOCKS),
  "NAME_FEE_BID_INCREMENT": () => (/* reexport */ NAME_FEE_BID_INCREMENT),
  "NAME_FEE_MULTIPLIER": () => (/* reexport */ NAME_FEE_MULTIPLIER),
  "NAME_MAX_CLIENT_TTL": () => (/* reexport */ NAME_MAX_CLIENT_TTL),
  "NAME_MAX_LENGTH_FEE": () => (/* reexport */ NAME_MAX_LENGTH_FEE),
  "NAME_MAX_TTL": () => (/* reexport */ NAME_MAX_TTL),
  "NAME_TTL": () => (/* reexport */ NAME_TTL),
  "NoSerializerFoundError": () => (/* reexport */ NoSerializerFoundError),
  "NoSuchContractFunctionError": () => (/* reexport */ NoSuchContractFunctionError),
  "NoWalletConnectedError": () => (/* reexport */ NoWalletConnectedError),
  "Node": () => (/* reexport */ Node_Node),
  "NodeError": () => (/* reexport */ NodeError),
  "NodeInvocationError": () => (/* reexport */ NodeInvocationError),
  "NodeNotFoundError": () => (/* reexport */ NodeNotFoundError),
  "NotImplementedError": () => (/* reexport */ NotImplementedError),
  "NotPayableFunctionError": () => (/* reexport */ NotPayableFunctionError),
  "ORACLE_TTL": () => (/* reexport */ ORACLE_TTL),
  "ORACLE_TTL_TYPES": () => (/* reexport */ ORACLE_TTL_TYPES),
  "POINTER_KEY_BY_PREFIX": () => (/* reexport */ POINTER_KEY_BY_PREFIX),
  "PREFIX_ID_TAG": () => (/* reexport */ PREFIX_ID_TAG),
  "PROTOCOL_VERSIONS": () => (/* reexport */ PROTOCOL_VERSIONS),
  "PROTOCOL_VM_ABI": () => (/* reexport */ PROTOCOL_VM_ABI),
  "PayloadLengthError": () => (/* reexport */ PayloadLengthError),
  "PrefixNotFoundError": () => (/* reexport */ PrefixNotFoundError),
  "QUERY_FEE": () => (/* reexport */ QUERY_FEE),
  "QUERY_TTL": () => (/* reexport */ QUERY_TTL),
  "RESPONSE_TTL": () => (/* reexport */ RESPONSE_TTL),
  "RPC_STATUS": () => (/* reexport */ RPC_STATUS),
  "RequestTimedOutError": () => (/* reexport */ RequestTimedOutError),
  "RpcBroadcastError": () => (/* reexport */ RpcBroadcastError),
  "RpcConnectionDenyError": () => (/* reexport */ RpcConnectionDenyError),
  "RpcConnectionError": () => (/* reexport */ RpcConnectionError),
  "RpcError": () => (/* reexport */ RpcError),
  "RpcInternalError": () => (/* reexport */ RpcInternalError),
  "RpcInvalidTransactionError": () => (/* reexport */ RpcInvalidTransactionError),
  "RpcMethodNotFoundError": () => (/* reexport */ RpcMethodNotFoundError),
  "RpcNotAuthorizeError": () => (/* reexport */ RpcNotAuthorizeError),
  "RpcPermissionDenyError": () => (/* reexport */ RpcPermissionDenyError),
  "RpcRejectedByUserError": () => (/* reexport */ RpcRejectedByUserError),
  "RpcUnsupportedProtocolError": () => (/* reexport */ RpcUnsupportedProtocolError),
  "SUBSCRIPTION_TYPES": () => (/* reexport */ SUBSCRIPTION_TYPES),
  "SchemaNotFoundError": () => (/* reexport */ SchemaNotFoundError),
  "TX_SCHEMA": () => (/* reexport */ TX_SCHEMA),
  "TX_TTL": () => (/* reexport */ TX_TTL),
  "TX_TYPE": () => (/* reexport */ TX_TYPE),
  "Tag": () => (/* reexport */ Tag),
  "TagNotFoundError": () => (/* reexport */ TagNotFoundError),
  "TransactionError": () => (/* reexport */ TransactionError),
  "TxNotInChainError": () => (/* reexport */ TxNotInChainError),
  "TxTimedOutError": () => (/* reexport */ TxTimedOutError),
  "TypeError": () => (/* reexport */ errors_TypeError),
  "UnAuthorizedAccountError": () => (/* reexport */ UnAuthorizedAccountError),
  "UnavailableAccountError": () => (/* reexport */ UnavailableAccountError),
  "UnexpectedChannelMessageError": () => (/* reexport */ UnexpectedChannelMessageError),
  "UnexpectedTsError": () => (/* reexport */ UnexpectedTsError),
  "UnknownChannelStateError": () => (/* reexport */ UnknownChannelStateError),
  "UnknownNodeLengthError": () => (/* reexport */ UnknownNodeLengthError),
  "UnknownPathNibbleError": () => (/* reexport */ UnknownPathNibbleError),
  "UnknownRpcClientError": () => (/* reexport */ UnknownRpcClientError),
  "UnknownTxError": () => (/* reexport */ UnknownTxError),
  "UnsubscribedAccountError": () => (/* reexport */ UnsubscribedAccountError),
  "UnsupportedABIversionError": () => (/* reexport */ UnsupportedABIversionError),
  "UnsupportedPlatformError": () => (/* reexport */ UnsupportedPlatformError),
  "UnsupportedProtocolError": () => (/* reexport */ UnsupportedProtocolError),
  "UnsupportedVMversionError": () => (/* reexport */ UnsupportedVMversionError),
  "UnsupportedVersionError": () => (/* reexport */ UnsupportedVersionError),
  "VM_VERSIONS": () => (/* reexport */ VM_VERSIONS),
  "WALLET_TYPE": () => (/* reexport */ WALLET_TYPE),
  "WalletError": () => (/* reexport */ WalletError),
  "_buildTx": () => (/* reexport */ _buildTx),
  "_getPollInterval": () => (/* reexport */ _getPollInterval),
  "aensBid": () => (/* reexport */ aensBid),
  "aensClaim": () => (/* reexport */ aensClaim),
  "aensPreclaim": () => (/* reexport */ aensPreclaim),
  "aensQuery": () => (/* reexport */ aensQuery),
  "aensRevoke": () => (/* reexport */ aensRevoke),
  "aensTransfer": () => (/* reexport */ aensTransfer),
  "aensUpdate": () => (/* reexport */ aensUpdate),
  "awaitHeight": () => (/* reexport */ awaitHeight),
  "bigNumberToByteArray": () => (/* reexport */ bigNumberToByteArray),
  "buildAuthTxHash": () => (/* reexport */ buildAuthTxHash),
  "buildContractId": () => (/* reexport */ buildContractId),
  "buildContractIdByContractTx": () => (/* reexport */ buildContractIdByContractTx),
  "buildPointers": () => (/* reexport */ buildPointers),
  "buildTx": () => (/* reexport */ buildTx),
  "buildTxHash": () => (/* reexport */ buildTxHash),
  "bytesToHex": () => (/* reexport */ bytesToHex),
  "calculateMinFee": () => (/* reexport */ deprecated_calculateMinFee),
  "commitmentHash": () => (/* reexport */ commitmentHash),
  "computeAuctionEndBlock": () => (/* reexport */ computeAuctionEndBlock),
  "computeBidFee": () => (/* reexport */ computeBidFee),
  "connectionProxy": () => (/* reexport */ connection_proxy),
  "createAensDelegationSignature": () => (/* reexport */ createAensDelegationSignature),
  "createGeneralizedAccount": () => (/* reexport */ createGeneralizedAccount),
  "createMetaTx": () => (/* reexport */ createMetaTx),
  "createOracleDelegationSignature": () => (/* reexport */ createOracleDelegationSignature),
  "createSalt": () => (/* reexport */ createSalt),
  "decode": () => (/* reexport */ decode),
  "decryptKey": () => (/* reexport */ decryptKey),
  "deriveChild": () => (/* reexport */ deriveChild),
  "derivePathFromKey": () => (/* reexport */ derivePathFromKey),
  "derivePathFromSeed": () => (/* reexport */ derivePathFromSeed),
  "dump": () => (/* reexport */ dump),
  "encode": () => (/* reexport */ encode),
  "encodeContractAddress": () => (/* reexport */ encodeContractAddress),
  "encodeUnsigned": () => (/* reexport */ encodeUnsigned),
  "encryptKey": () => (/* reexport */ encryptKey),
  "extendOracleTtl": () => (/* reexport */ extendOracleTtl),
  "formatAmount": () => (/* reexport */ formatAmount),
  "formatSalt": () => (/* reexport */ formatSalt),
  "genSalt": () => (/* reexport */ genSalt),
  "generateKeyPair": () => (/* reexport */ generateKeyPair),
  "generateKeyPairFromSecret": () => (/* reexport */ generateKeyPairFromSecret),
  "generateSaveHDWalletFromSeed": () => (/* reexport */ generateSaveHDWalletFromSeed),
  "getAccount": () => (/* reexport */ getAccount),
  "getAddressFromPriv": () => (/* reexport */ getAddressFromPriv),
  "getBalance": () => (/* reexport */ getBalance),
  "getContract": () => (/* reexport */ getContract),
  "getContractByteCode": () => (/* reexport */ getContractByteCode),
  "getContractInstance": () => (/* reexport */ getContractInstance),
  "getCurrentGeneration": () => (/* reexport */ getCurrentGeneration),
  "getDefaultPointerKey": () => (/* reexport */ getDefaultPointerKey),
  "getGeneration": () => (/* reexport */ getGeneration),
  "getHdWalletAccountFromSeed": () => (/* reexport */ getHdWalletAccountFromSeed),
  "getHeight": () => (/* reexport */ getHeight),
  "getKeyBlock": () => (/* reexport */ getKeyBlock),
  "getKeyPair": () => (/* reexport */ getKeyPair),
  "getMasterKeyFromSeed": () => (/* reexport */ getMasterKeyFromSeed),
  "getMicroBlockHeader": () => (/* reexport */ getMicroBlockHeader),
  "getMicroBlockTransactions": () => (/* reexport */ getMicroBlockTransactions),
  "getMinimumNameFee": () => (/* reexport */ getMinimumNameFee),
  "getName": () => (/* reexport */ getName),
  "getOracleObject": () => (/* reexport */ getOracleObject),
  "getQueryObject": () => (/* reexport */ getQueryObject),
  "getSaveHDWalletAccounts": () => (/* reexport */ getSaveHDWalletAccounts),
  "getVmVersion": () => (/* reexport */ getVmVersion),
  "hash": () => (/* reexport */ hash),
  "height": () => (/* reexport */ height),
  "hexToBytes": () => (/* reexport */ hexToBytes),
  "isAddressValid": () => (/* reexport */ isAddressValid),
  "isAuctionName": () => (/* reexport */ isAuctionName),
  "isGA": () => (/* reexport */ isGA),
  "isNameValid": () => (/* reexport */ isNameValid),
  "isValidKeypair": () => (/* reexport */ isValidKeypair),
  "messageToHash": () => (/* reexport */ messageToHash),
  "oracleQueryId": () => (/* reexport */ oracleQueryId),
  "payForTransaction": () => (/* reexport */ payForTransaction),
  "poll": () => (/* reexport */ poll),
  "pollForQueries": () => (/* reexport */ pollForQueries),
  "pollForQueryResponse": () => (/* reexport */ pollForQueryResponse),
  "postQueryToOracle": () => (/* reexport */ postQueryToOracle),
  "prepareTxParams": () => (/* reexport */ prepareTxParams),
  "produceNameId": () => (/* reexport */ produceNameId),
  "readId": () => (/* reexport */ readId),
  "readInt": () => (/* reexport */ readInt),
  "readPointers": () => (/* reexport */ readPointers),
  "recover": () => (/* reexport */ recover),
  "registerOracle": () => (/* reexport */ registerOracle),
  "resolveName": () => (/* reexport */ resolveName),
  "respondToQuery": () => (/* reexport */ respondToQuery),
  "salt": () => (/* reexport */ salt),
  "send": () => (/* reexport */ send),
  "sendTransaction": () => (/* reexport */ sendTransaction),
  "sha256hash": () => (/* reexport */ sha256hash),
  "sign": () => (/* reexport */ sign),
  "signMessage": () => (/* reexport */ signMessage),
  "signUsingGA": () => (/* reexport */ signUsingGA),
  "spend": () => (/* reexport */ spend),
  "str2buf": () => (/* reexport */ str2buf),
  "toAe": () => (/* reexport */ toAe),
  "toAettos": () => (/* reexport */ toAettos),
  "toBytes": () => (/* reexport */ toBytes),
  "transferFunds": () => (/* reexport */ transferFunds),
  "txDryRun": () => (/* reexport */ txDryRun),
  "unpackRawTx": () => (/* reexport */ unpackRawTx),
  "unpackTx": () => (/* reexport */ unpackTx),
  "validateParams": () => (/* reexport */ validateParams),
  "verify": () => (/* reexport */ verify),
  "verifyMessage": () => (/* reexport */ verifyMessage),
  "verifyTransaction": () => (/* reexport */ verifyTransaction),
  "waitForTxConfirm": () => (/* reexport */ waitForTxConfirm),
  "walletDetector": () => (/* reexport */ wallet_detector),
  "writeId": () => (/* reexport */ writeId),
  "writeInt": () => (/* reexport */ writeInt)
});

// NAMESPACE OBJECT: ./src/chain.ts
var chain_namespaceObject = {};
__webpack_require__.r(chain_namespaceObject);
__webpack_require__.d(chain_namespaceObject, {
  "InvalidTxError": () => (InvalidTxError),
  "_getPollInterval": () => (_getPollInterval),
  "awaitHeight": () => (awaitHeight),
  "getAccount": () => (getAccount),
  "getBalance": () => (getBalance),
  "getContract": () => (getContract),
  "getContractByteCode": () => (getContractByteCode),
  "getCurrentGeneration": () => (getCurrentGeneration),
  "getGeneration": () => (getGeneration),
  "getHeight": () => (getHeight),
  "getKeyBlock": () => (getKeyBlock),
  "getMicroBlockHeader": () => (getMicroBlockHeader),
  "getMicroBlockTransactions": () => (getMicroBlockTransactions),
  "getName": () => (getName),
  "poll": () => (poll),
  "resolveName": () => (resolveName),
  "sendTransaction": () => (sendTransaction),
  "txDryRun": () => (txDryRun),
  "waitForTxConfirm": () => (waitForTxConfirm)
});

// NAMESPACE OBJECT: ./src/tx/index.ts
var tx_namespaceObject = {};
__webpack_require__.r(tx_namespaceObject);
__webpack_require__.d(tx_namespaceObject, {
  "_buildTx": () => (_buildTx),
  "getVmVersion": () => (getVmVersion),
  "prepareTxParams": () => (prepareTxParams)
});

// NAMESPACE OBJECT: ./src/spend.ts
var spend_namespaceObject = {};
__webpack_require__.r(spend_namespaceObject);
__webpack_require__.d(spend_namespaceObject, {
  "payForTransaction": () => (payForTransaction),
  "send": () => (send),
  "spend": () => (spend),
  "transferFunds": () => (transferFunds)
});

// NAMESPACE OBJECT: ./src/aens.ts
var aens_namespaceObject = {};
__webpack_require__.r(aens_namespaceObject);
__webpack_require__.d(aens_namespaceObject, {
  "aensBid": () => (aensBid),
  "aensClaim": () => (aensClaim),
  "aensPreclaim": () => (aensPreclaim),
  "aensQuery": () => (aensQuery),
  "aensRevoke": () => (aensRevoke),
  "aensTransfer": () => (aensTransfer),
  "aensUpdate": () => (aensUpdate)
});

// NAMESPACE OBJECT: ./src/contract/methods.ts
var methods_namespaceObject = {};
__webpack_require__.r(methods_namespaceObject);
__webpack_require__.d(methods_namespaceObject, {
  "createAensDelegationSignature": () => (createAensDelegationSignature),
  "createOracleDelegationSignature": () => (createOracleDelegationSignature),
  "getContractInstance": () => (getContractInstance)
});

// NAMESPACE OBJECT: ./src/oracle.ts
var oracle_namespaceObject = {};
__webpack_require__.r(oracle_namespaceObject);
__webpack_require__.d(oracle_namespaceObject, {
  "extendOracleTtl": () => (extendOracleTtl),
  "getOracleObject": () => (getOracleObject),
  "getQueryObject": () => (getQueryObject),
  "pollForQueries": () => (pollForQueries),
  "pollForQueryResponse": () => (pollForQueryResponse),
  "postQueryToOracle": () => (postQueryToOracle),
  "registerOracle": () => (registerOracle),
  "respondToQuery": () => (respondToQuery)
});

// NAMESPACE OBJECT: ./src/contract/ga.ts
var ga_namespaceObject = {};
__webpack_require__.r(ga_namespaceObject);
__webpack_require__.d(ga_namespaceObject, {
  "buildAuthTxHash": () => (buildAuthTxHash),
  "createGeneralizedAccount": () => (createGeneralizedAccount),
  "createMetaTx": () => (createMetaTx),
  "isGA": () => (isGA)
});

// NAMESPACE OBJECT: ./src/deprecated/methods.ts
var deprecated_methods_namespaceObject = {};
__webpack_require__.r(deprecated_methods_namespaceObject);
__webpack_require__.d(deprecated_methods_namespaceObject, {
  "height": () => (height),
  "signUsingGA": () => (signUsingGA)
});

// NAMESPACE OBJECT: ./src/apis/node/models/mappers.ts
var mappers_namespaceObject = {};
__webpack_require__.r(mappers_namespaceObject);
__webpack_require__.d(mappers_namespaceObject, {
  "Account": () => (Account),
  "ByteCode": () => (ByteCode),
  "Channel": () => (Channel),
  "ChannelCloseMutualTx": () => (ChannelCloseMutualTx),
  "ChannelCloseSoloTx": () => (ChannelCloseSoloTx),
  "ChannelCreateTx": () => (ChannelCreateTx),
  "ChannelDepositTx": () => (ChannelDepositTx),
  "ChannelForceProgressTx": () => (ChannelForceProgressTx),
  "ChannelSetDelegatesTx": () => (ChannelSetDelegatesTx),
  "ChannelSettleTx": () => (ChannelSettleTx),
  "ChannelSlashTx": () => (ChannelSlashTx),
  "ChannelSnapshotSoloTx": () => (ChannelSnapshotSoloTx),
  "ChannelWithdrawTx": () => (ChannelWithdrawTx),
  "CheckTxInPoolResponse": () => (CheckTxInPoolResponse),
  "CommitmentId": () => (CommitmentId),
  "ContractCallObject": () => (ContractCallObject),
  "ContractCallTx": () => (ContractCallTx),
  "ContractCreateTx": () => (ContractCreateTx),
  "ContractObject": () => (ContractObject),
  "CountResponse": () => (CountResponse),
  "CreateContractUnsignedTx": () => (CreateContractUnsignedTx),
  "Delegates": () => (Delegates),
  "DryRunAccount": () => (DryRunAccount),
  "DryRunCallContext": () => (DryRunCallContext),
  "DryRunCallReq": () => (DryRunCallReq),
  "DryRunInput": () => (DryRunInput),
  "DryRunInputItem": () => (DryRunInputItem),
  "DryRunResult": () => (DryRunResult),
  "DryRunResults": () => (DryRunResults),
  "EncodedTx": () => (EncodedTx),
  "ErrorModel": () => (ErrorModel),
  "Event": () => (Event),
  "GAAttachTx": () => (GAAttachTx),
  "GAMetaTx": () => (GAMetaTx),
  "GAObject": () => (GAObject),
  "Generation": () => (Generation),
  "HashResponse": () => (HashResponse),
  "Header": () => (Header),
  "HeightResponse": () => (HeightResponse),
  "KeyBlock": () => (KeyBlock),
  "MicroBlockHeader": () => (MicroBlockHeader),
  "NameClaimTx": () => (NameClaimTx),
  "NameEntry": () => (NameEntry),
  "NameHash": () => (NameHash),
  "NamePointer": () => (NamePointer),
  "NamePreclaimTx": () => (NamePreclaimTx),
  "NameRevokeTx": () => (NameRevokeTx),
  "NameTransferTx": () => (NameTransferTx),
  "NameUpdateTx": () => (NameUpdateTx),
  "NextNonceResponse": () => (NextNonceResponse),
  "OffChainCallContract": () => (OffChainCallContract),
  "OffChainDeposit": () => (OffChainDeposit),
  "OffChainNewContract": () => (OffChainNewContract),
  "OffChainTransfer": () => (OffChainTransfer),
  "OffChainUpdate": () => (OffChainUpdate),
  "OffChainWithdrawal": () => (OffChainWithdrawal),
  "OracleExtendTx": () => (OracleExtendTx),
  "OracleQueries": () => (OracleQueries),
  "OracleQuery": () => (OracleQuery),
  "OracleQueryTx": () => (OracleQueryTx),
  "OracleRegisterTx": () => (OracleRegisterTx),
  "OracleRespondTx": () => (OracleRespondTx),
  "PayingForTx": () => (PayingForTx),
  "PeerConnections": () => (PeerConnections),
  "PeerCount": () => (PeerCount),
  "PeerCountAvailable": () => (PeerCountAvailable),
  "PeerCountConnected": () => (PeerCountConnected),
  "PeerDetails": () => (PeerDetails),
  "PeerPubKey": () => (PeerPubKey),
  "Peers": () => (Peers),
  "PoI": () => (PoI),
  "PostTxResponse": () => (PostTxResponse),
  "Protocol": () => (Protocol),
  "PubKey": () => (PubKey),
  "RegisteredOracle": () => (RegisteredOracle),
  "RelativeTTL": () => (RelativeTTL),
  "SignedTx": () => (SignedTx),
  "SignedTxs": () => (SignedTxs),
  "SpendTx": () => (SpendTx),
  "Status": () => (Status),
  "TokenSupply": () => (TokenSupply),
  "Ttl": () => (Ttl),
  "Tx": () => (Tx),
  "TxInfoObject": () => (TxInfoObject),
  "UnsignedTx": () => (UnsignedTx),
  "discriminators": () => (discriminators)
});

// NAMESPACE OBJECT: ./src/apis/compiler/models/mappers.ts
var models_mappers_namespaceObject = {};
__webpack_require__.r(models_mappers_namespaceObject);
__webpack_require__.d(models_mappers_namespaceObject, {
  "APIVersion": () => (APIVersion),
  "Aci": () => (Aci),
  "ByteCode": () => (mappers_ByteCode),
  "ByteCodeInput": () => (ByteCodeInput),
  "BytecodeCallResultInput": () => (BytecodeCallResultInput),
  "Calldata": () => (Calldata),
  "CompileOpts": () => (CompileOpts),
  "CompilerError": () => (mappers_CompilerError),
  "CompilerVersion": () => (CompilerVersion),
  "Contract": () => (Contract),
  "DecodeCalldataBytecode": () => (DecodeCalldataBytecode),
  "DecodeCalldataSource": () => (DecodeCalldataSource),
  "DecodedCalldata": () => (DecodedCalldata),
  "DecodedCallresult": () => (DecodedCallresult),
  "ErrorModel": () => (mappers_ErrorModel),
  "ErrorPos": () => (ErrorPos),
  "FateAssembler": () => (FateAssembler),
  "FunctionCallInput": () => (FunctionCallInput),
  "SophiaBinaryData": () => (SophiaBinaryData),
  "SophiaCallResultInput": () => (SophiaCallResultInput),
  "SophiaJsonData": () => (SophiaJsonData),
  "ValidateByteCodeInput": () => (ValidateByteCodeInput)
});

// EXTERNAL MODULE: external "bignumber.js"
var external_bignumber_js_ = __webpack_require__(5192);
var external_bignumber_js_default = /*#__PURE__*/__webpack_require__.n(external_bignumber_js_);
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/includes.js
var includes = __webpack_require__(8118);
var includes_default = /*#__PURE__*/__webpack_require__.n(includes);
;// CONCATENATED MODULE: ./src/utils/bignumber.ts


/**
 * Big Number Helpers
 */

/**
 * Check if value is BigNumber, Number, BigInt or number string representation
 * @param number - number to check
 */

const isBigNumber = number => {
  var _context;

  if (typeof number === 'bigint') return true;
  return includes_default()(_context = ['number', 'object', 'string']).call(_context, typeof number) // eslint-disable-next-line no-restricted-globals
  && (!isNaN(number) || Number.isInteger(number) || external_bignumber_js_default().isBigNumber(number));
};
/**
 * BigNumber ceil operation
 */

const ceil = bigNumber => bigNumber.integerValue((external_bignumber_js_default()).ROUND_CEIL);
;// CONCATENATED MODULE: ./src/utils/errors.ts
// eslint-disable-next-line max-classes-per-file

/**
 * aepp-sdk originated error
 * @category exception
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'BaseError';
  }

}
/**
 * @category exception
 */

class AccountError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AccountError';
  }

}
/**
 * @category exception
 */

class AensError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AensError';
  }

}
/**
 * @category exception
 */

class AeppError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AeppError';
  }

}
/**
 * @category exception
 */

class ChannelError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ChannelError';
  }

}
/**
 * @category exception
 */

class CompilerError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CompilerError';
  }

}
/**
 * @category exception
 */

class ContractError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ContractError';
  }

}
/**
 * @category exception
 */

class CryptographyError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CryptographyError';
  }

}
/**
 * @category exception
 */

class NodeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NodeError';
  }

}
/**
 * @category exception
 */

class TransactionError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TransactionError';
  }

}
/**
 * @category exception
 */

class WalletError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'WalletError';
  }

}
/**
 * @category exception
 */

class ArgumentError extends BaseError {
  constructor(argumentName, requirement, argumentValue) {
    super(`${argumentName} should be ${requirement}, got ${String(argumentValue)} instead`);
    this.name = 'ArgumentError';
  }

}
/**
 * @category exception
 */

class IllegalArgumentError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'IllegalArgumentError';
  }

}
/**
 * @category exception
 */

class ArgumentCountMismatchError extends BaseError {
  constructor(functionName, requiredCount, providedCount) {
    super(`${functionName} expects ${requiredCount} arguments, got ${providedCount} instead`);
    this.name = 'ArgumentCountMismatchError';
  }

}
/**
 * @category exception
 */

class InsufficientBalanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InsufficientBalanceError';
  }

}
/**
 * @category exception
 */

class MissingParamError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MissingParamError';
  }

}
/**
 * @category exception
 */

class NoSerializerFoundError extends BaseError {
  constructor() {
    super('Byte serialization not supported');
    this.name = 'NoSerializerFoundError';
  }

}
/**
 * @category exception
 */

class RequestTimedOutError extends BaseError {
  constructor(height) {
    super(`Giving up at height ${height}`);
    this.name = 'RequestTimedOutError';
  }

}
/**
 * @category exception
 */

class TxTimedOutError extends BaseError {
  constructor(blocks, th) {
    super([`Giving up after ${blocks} blocks mined`, `transaction hash: ${th}`].join(', '));
    this.name = 'TxTimedOutError';
  }

}
/**
 * @category exception
 */

class errors_TypeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TypeError';
  }

}
/**
 * @category exception
 */

class UnsupportedPlatformError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedPlatformError';
  }

}
/**
 * @category exception
 */

class UnsupportedProtocolError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedProtocolError';
  }

}
/**
 * @category exception
 */

class NotImplementedError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NotImplementedError';
  }

}
/**
 * @category exception
 */

class UnsupportedVersionError extends BaseError {
  constructor(dependency, version, geVersion, ltVersion) {
    super(`Unsupported ${dependency} version ${version}. Supported: >= ${geVersion} < ${ltVersion}`);
    this.name = 'UnsupportedVersionError';
  }

}
/**
 * @category exception
 */

class InternalError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InternalError';
  }

}
/**
 * @category exception
 */

class UnexpectedTsError extends InternalError {
  constructor() {
    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Expected to not happen, required for TS';
    super(message);
    this.name = 'UnexpectedTsError';
  }

}
/**
 * @category exception
 */

class InvalidKeypairError extends AccountError {
  constructor(message) {
    super(message);
    this.name = 'InvalidKeypairError';
  }

}
/**
 * @category exception
 */

class UnavailableAccountError extends AccountError {
  constructor(address) {
    super(`Account for ${address} not available`);
    this.name = 'UnavailableAccountError';
  }

}
/**
 * @category exception
 */

class AensPointerContextError extends AensError {
  constructor(nameOrId, prefix) {
    super(`Name ${nameOrId} don't have pointers for ${prefix}`);
    this.name = 'AensPointerContextError';
  }

}
/**
 * @category exception
 */

class InsufficientNameFeeError extends AensError {
  constructor(nameFee, minNameFee) {
    super(`the provided fee ${nameFee.toString()} is not enough to execute the claim, required: ${minNameFee.toString()}`);
    this.name = 'InsufficientNameFeeError';
  }

}
/**
 * @category exception
 */

class InvalidAensNameError extends AensError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAensNameError';
  }

}
/**
 * @category exception
 */

class InvalidRpcMessageError extends AeppError {
  constructor(message) {
    super(`Received invalid message: ${message}`);
    this.name = 'InvalidRpcMessageError';
  }

}
/**
 * @category exception
 */

class MissingCallbackError extends AeppError {
  constructor(id) {
    super(`Can't find callback for this messageId ${id}`);
    this.name = 'MissingCallbackError';
  }

}
/**
 * @category exception
 */

class UnAuthorizedAccountError extends AeppError {
  constructor(onAccount) {
    super(`You do not have access to account ${onAccount}`);
    this.name = 'UnAuthorizedAccountError';
  }

}
/**
 * @category exception
 */

class UnknownRpcClientError extends AeppError {
  constructor(id) {
    super(`RpcClient with id ${id} do not exist`);
    this.name = 'UnknownRpcClientError';
  }

}
/**
 * @category exception
 */

class UnsubscribedAccountError extends AeppError {
  constructor() {
    super('You are not subscribed for an account.');
    this.name = 'UnsubscribedAccountError';
  }

}
/**
 * @category exception
 */

class ChannelCallError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelCallError';
  }

}
/**
 * @category exception
 */

class ChannelConnectionError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelConnectionError';
  }

}
/**
 * @category exception
 */

class ChannelPingTimedOutError extends ChannelError {
  constructor() {
    super('Server pong timed out');
    this.name = 'ChannelPingTimedOutError';
  }

}
/**
 * @category exception
 */

class UnexpectedChannelMessageError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'UnexpectedChannelMessageError';
  }

}
/**
 * @category exception
 */

class UnknownChannelStateError extends ChannelError {
  constructor() {
    super('State Channels FSM entered unknown state');
    this.name = 'UnknownChannelStateError';
  }

}
/**
 * @category exception
 */

class InvalidAuthDataError extends CompilerError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAuthDataError';
  }

}
/**
 * @category exception
 */

class BytecodeMismatchError extends ContractError {
  constructor(source) {
    super(`Contract ${source} do not correspond to the bytecode deployed on the chain`);
    this.name = 'BytecodeMismatchError';
  }

}
/**
 * @category exception
 */

class DuplicateContractError extends ContractError {
  constructor() {
    super('Contract already deployed');
    this.name = 'DuplicateContractError';
  }

}
/**
 * @category exception
 */

class InactiveContractError extends ContractError {
  constructor(contractAddress) {
    super(`Contract with address ${contractAddress} not active`);
    this.name = 'InactiveContractError';
  }

}
/**
 * @category exception
 */

class InvalidMethodInvocationError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'InvalidMethodInvocationError';
  }

}
/**
 * @category exception
 */

class MissingContractAddressError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'MissingContractAddressError';
  }

}
/**
 * @category exception
 */

class MissingContractDefError extends ContractError {
  constructor() {
    super('Either ACI or source code is required');
    this.name = 'MissingContractDefError';
  }

}
/**
 * @category exception
 */

class MissingFunctionNameError extends ContractError {
  constructor() {
    super('Function name is required');
    this.name = 'MissingFunctionNameError';
  }

}
/**
 * @category exception
 */

class NodeInvocationError extends ContractError {
  constructor(message, transaction) {
    super(`Invocation failed${message == null ? '' : `: "${message}"`}`);
    this.name = 'NodeInvocationError';
    this.transaction = transaction;
  }

}
/**
 * @category exception
 */

class NoSuchContractFunctionError extends ContractError {
  constructor(name) {
    super(`Function ${name} doesn't exist in contract`);
    this.name = 'NoSuchContractFunctionError';
  }

}
/**
 * @category exception
 */

class NotPayableFunctionError extends ContractError {
  constructor(amount, fn) {
    super(`You try to pay "${amount}" to function "${fn}" which is not payable. ` + 'Only payable function can accept coins');
    this.name = 'NotPayableFunctionError';
  }

}
/**
 * @category exception
 */

class MissingEventDefinitionError extends ContractError {
  constructor(eventNameHash, eventAddress) {
    super(`Can't find definition of ${eventNameHash} event emitted by ${eventAddress}` + ' (use omitUnknown option to ignore events like this)');
    this.name = 'MissingEventDefinitionError';
  }

}
/**
 * @category exception
 */

class AmbiguousEventDefinitionError extends ContractError {
  constructor(eventAddress, matchedEvents) {
    super(`Found multiple definitions of "${matchedEvents[0][1]}" event emitted by ${eventAddress}` + ` in ${matchedEvents.map(_ref => {
      let [name] = _ref;
      return `"${name}"`;
    }).join(', ')} contracts` + ' (use contractAddressToName option to specify contract name corresponding to address)');
    this.name = 'AmbiguousEventDefinitionError';
  }

}
/**
 * @category exception
 */

class InvalidChecksumError extends CryptographyError {
  constructor() {
    super('Invalid checksum');
    this.name = 'InvalidChecksumError';
  }

}
/**
 * @category exception
 */

class InvalidPasswordError extends CryptographyError {
  constructor() {
    super('Invalid password or nonce');
    this.name = 'InvalidPasswordError';
  }

}
/**
 * @category exception
 */

class MerkleTreeHashMismatchError extends CryptographyError {
  constructor() {
    super('Node hash is not equal to provided one');
    this.name = 'MerkleTreeHashMismatchError';
  }

}
/**
 * @category exception
 */

class MissingNodeInTreeError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'MissingNodeInTreeError';
  }

}
/**
 * @category exception
 */

class UnknownNodeLengthError extends CryptographyError {
  constructor(nodeLength) {
    super(`Unknown node length: ${nodeLength}`);
    this.name = 'UnknownNodeLengthError';
  }

}
/**
 * @category exception
 */

class UnknownPathNibbleError extends CryptographyError {
  constructor(nibble) {
    super(`Unknown path nibble: ${nibble}`);
    this.name = 'UnknownPathNibbleError';
  }

}
/**
 * @category exception
 */

class DuplicateNodeError extends NodeError {
  constructor(name) {
    super(`Node with name ${name} already exist`);
    this.name = 'DuplicateNodeError';
  }

}
/**
 * @category exception
 */

class NodeNotFoundError extends NodeError {
  constructor(message) {
    super(message);
    this.name = 'NodeNotFoundError';
  }

}
/**
 * @category exception
 */

class DecodeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DecodeError';
  }

}
/**
 * @category exception
 */

class PayloadLengthError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'PayloadLengthError';
  }

}
/**
 * @category exception
 */

class DryRunError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DryRunError';
  }

}
/**
 * @category exception
 */

class IllegalBidFeeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'IllegalBidFeeError';
  }

}
/**
 * @category exception
 */

class InvalidSignatureError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'InvalidSignatureError';
  }

}
/**
 * @category exception
 */

class InvalidTxParamsError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'InvalidTxParamsError';
  }

}
/**
 * @category exception
 */

class PrefixNotFoundError extends TransactionError {
  constructor(tag) {
    super(`Prefix for id-tag ${tag} not found.`);
    this.name = 'PrefixNotFoundError';
  }

}
/**
 * @category exception
 */

class SchemaNotFoundError extends TransactionError {
  constructor(schemaName, key, version) {
    super(`Transaction ${schemaName} not implemented for ${key} version ${version}`);
    this.name = 'SchemaNotFoundError';
  }

}
/**
 * @category exception
 */

class TagNotFoundError extends TransactionError {
  constructor(prefix) {
    super(`Id tag for prefix ${prefix} not found.`);
    this.name = 'DecodeError';
  }

}
/**
 * @category exception
 */

class TxNotInChainError extends TransactionError {
  constructor(txHash) {
    super(`Transaction ${txHash} is removed from chain`);
    this.name = 'TxNotInChainError';
  }

}
/**
 * @category exception
 */

class UnknownTxError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'UnknownTxError';
  }

}
/**
 * @category exception
 */

class UnsupportedABIversionError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedABIversionError';
  }

}
/**
 * @category exception
 */

class UnsupportedVMversionError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedVMversionError';
  }

}
/**
 * @category exception
 */

class AlreadyConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'AlreadyConnectedError';
  }

}
/**
 * @category exception
 */

class NoWalletConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'NoWalletConnectedError';
  }

}
/**
 * @category exception
 */

class RpcConnectionError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'RpcConnectionError';
  }

}
;// CONCATENATED MODULE: ./src/utils/amount-formatter.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */



let AE_AMOUNT_FORMATS;
/**
 * DENOMINATION_MAGNITUDE
 */

(function (AE_AMOUNT_FORMATS) {
  AE_AMOUNT_FORMATS["AE"] = "ae";
  AE_AMOUNT_FORMATS["MILI_AE"] = "miliAE";
  AE_AMOUNT_FORMATS["MICRO_AE"] = "microAE";
  AE_AMOUNT_FORMATS["NANO_AE"] = "nanoAE";
  AE_AMOUNT_FORMATS["PICO_AE"] = "picoAE";
  AE_AMOUNT_FORMATS["FEMTO_AE"] = "femtoAE";
  AE_AMOUNT_FORMATS["AETTOS"] = "aettos";
})(AE_AMOUNT_FORMATS || (AE_AMOUNT_FORMATS = {}));

const DENOMINATION_MAGNITUDE = {
  [AE_AMOUNT_FORMATS.AE]: 0,
  [AE_AMOUNT_FORMATS.MILI_AE]: -3,
  [AE_AMOUNT_FORMATS.MICRO_AE]: -6,
  [AE_AMOUNT_FORMATS.NANO_AE]: -9,
  [AE_AMOUNT_FORMATS.PICO_AE]: -12,
  [AE_AMOUNT_FORMATS.FEMTO_AE]: -15,
  [AE_AMOUNT_FORMATS.AETTOS]: -18
};
/**
 * Convert amount from one to other denomination
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 * @param options.targetDenomination - target denomination,
 * can be ['ae', 'aettos']
 */

const formatAmount = (value, _ref) => {
  let {
    denomination = AE_AMOUNT_FORMATS.AETTOS,
    targetDenomination = AE_AMOUNT_FORMATS.AETTOS
  } = _ref;
  if (!isBigNumber(value)) throw new ArgumentError('value', 'a number', value);
  return new (external_bignumber_js_default())(typeof value === 'bigint' ? value.toString() : value).shiftedBy(DENOMINATION_MAGNITUDE[denomination] - DENOMINATION_MAGNITUDE[targetDenomination]).toFixed();
};
/**
 * Convert amount to AE
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */

const toAe = function (value) {
  let {
    denomination = AE_AMOUNT_FORMATS.AETTOS
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return formatAmount(value, {
    denomination,
    targetDenomination: AE_AMOUNT_FORMATS.AE
  });
};
/**
 * Convert amount to aettos
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */

const toAettos = function (value) {
  let {
    denomination = AE_AMOUNT_FORMATS.AE
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return formatAmount(value, {
    denomination
  });
};
const prefixes = [{
  name: 'exa',
  magnitude: 18
}, {
  name: 'giga',
  magnitude: 9
}, {
  name: '',
  magnitude: 0
}, {
  name: 'pico',
  magnitude: -12
}];

const getNearestPrefix = exponent => prefixes.reduce((p, n) => Math.abs(n.magnitude - exponent) < Math.abs(p.magnitude - exponent) ? n : p);

const getLowerBoundPrefix = exponent => {
  var _prefixes$find;

  return (_prefixes$find = prefixes.find(p => p.magnitude <= exponent)) !== null && _prefixes$find !== void 0 ? _prefixes$find : prefixes[prefixes.length - 1];
};

/* harmony default export */ const amount_formatter = (rawValue => {
  var _value$e;

  const value = new BigNumber(rawValue);
  const exp = (_value$e = value.e) !== null && _value$e !== void 0 ? _value$e : 0;
  const {
    name,
    magnitude
  } = (exp < 0 ? getNearestPrefix : getLowerBoundPrefix)(exp);
  const v = value.shiftedBy(-magnitude).precision(9 + Math.min(exp - magnitude, 0)).toFixed();
  return `${v}${name !== '' ? ' ' : ''}${name}`;
});
// EXTERNAL MODULE: external "tweetnacl"
var external_tweetnacl_ = __webpack_require__(79);
var external_tweetnacl_default = /*#__PURE__*/__webpack_require__.n(external_tweetnacl_);
// EXTERNAL MODULE: ./node_modules/blakejs/blake2b.js
var blake2b = __webpack_require__(8442);
// EXTERNAL MODULE: external "varuint-bitcoin"
var external_varuint_bitcoin_ = __webpack_require__(7480);
;// CONCATENATED MODULE: ./src/utils/string.ts
/*
 * ISC License (ISC)
 * Copyright 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Convert string from snake_case to PascalCase
 * @param s - String to convert
 * @returns Converted string
 */
function snakeToPascal(s) {
  return s.replace(/_./g, match => match[1].toUpperCase());
}
/**
 * Convert string from PascalCase to snake_case
 * @param s - String to convert
 * @returns Converted string
 */

function pascalToSnake(s) {
  return s.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`);
}
/**
 * Check whether a string is valid hex.
 * @param str - String to validate.
 * @returns True if the string is valid hex, false otherwise.
 */

function isHex(str) {
  return str.length % 2 === 0 && /^[0-9a-f]+$/i.test(str);
}
/**
 * Check whether a string is valid base-64.
 * @param str - String to validate.
 * @returns True if the string is valid base-64, false otherwise.
 */

function isBase64(str) {
  if (str.length % 4 > 0 || /[^0-9a-z+/=]/i.test(str)) return false;
  const index = str.indexOf('=');
  return index === -1 || /={1,2}/.test(str.slice(index));
}
;// CONCATENATED MODULE: ./src/utils/bytes.ts
/*
 * ISC License (ISC)
 * Copyright 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */



/**
 * Convert bignumber to byte array
 * @param x - bignumber instance
 * @returns Buffer
 */

function bigNumberToByteArray(x) {
  if (!x.isInteger()) throw new errors_TypeError(`Unexpected not integer value: ${x.toFixed()}`);
  let hexString = x.toString(16);
  if (hexString.length % 2 === 1) hexString = `0${hexString}`;
  return Buffer.from(hexString, 'hex');
}
/**
 * Convert string, number, or BigNumber to byte array
 * @param val - value to convert
 * @param big - enables force conversion to BigNumber
 * @returns Buffer
 */

function toBytes(val) {
  let big = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // Encode a value to bytes.
  // If the value is an int it will be encoded as bytes big endian
  // Raises ValueError if the input is not an int or string
  if (val === undefined || val === null) return Buffer.from([]);

  if (Number.isInteger(val) || external_bignumber_js_default().isBigNumber(val) || big) {
    if (!external_bignumber_js_default().isBigNumber(val)) val = new (external_bignumber_js_default())(val);
    return bigNumberToByteArray(val);
  }

  if (typeof val === 'string') {
    return Buffer.from(val);
  }

  throw new NoSerializerFoundError();
}
/**
 * Convert a string to a Buffer.  If encoding is not specified, hex-encoding
 * will be used if the input is valid hex.  If the input is valid base64 but
 * not valid hex, base64 will be used.  Otherwise, utf8 will be used.
 * @param str - String to be converted.
 * @param enc - Encoding of the input string.
 * @returns Buffer containing the input data.
 */

function str2buf(str, enc) {
  var _ref;

  return Buffer.from(str, (_ref = enc !== null && enc !== void 0 ? enc : isHex(str) ? 'hex' : undefined) !== null && _ref !== void 0 ? _ref : isBase64(str) ? 'base64' : undefined);
}
const bytesToHex = b => Buffer.from(b).toString('hex');
const hexToBytes = s => Buffer.from(s, 'hex');
;// CONCATENATED MODULE: ./src/utils/other.ts

const pause = async duration => new Promise(resolve => {
  setTimeout(resolve, duration);
});
const mapObject = (object, fn) => Object.fromEntries(Object.entries(object).map(fn)); // remove after dropping webpack4 support

const isWebpack4Buffer = (() => {
  try {
    Buffer.concat([Uint8Array.from([])]);
    return false;
  } catch (error) {
    return true;
  }
})();

const concatBuffers = isWebpack4Buffer ? (list, totalLength) => Buffer.concat(list.map(el => Buffer.from(el)), totalLength) : Buffer.concat;
/**
 * Object key type guard
 * @param key - Maybe object key
 * @param object - Object
 */

function isKeyOfObject(key, object) {
  return key in object;
}
/**
 * Array item type guard
 * @param item - Maybe array item
 * @param array - Array
 */

function isItemOfArray(item, array) {
  return includes_default()(array).call(array, item);
}
// EXTERNAL MODULE: external "bs58"
var external_bs58_ = __webpack_require__(3783);
// EXTERNAL MODULE: ./node_modules/sha.js/sha256.js
var sha256 = __webpack_require__(7499);
var sha256_default = /*#__PURE__*/__webpack_require__.n(sha256);
;// CONCATENATED MODULE: ./src/utils/encoder-types.ts
/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/master/node/api/api_encoding.md}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L205-L230}
 */
let Encoding;

(function (Encoding) {
  Encoding["KeyBlockHash"] = "kh";
  Encoding["MicroBlockHash"] = "mh";
  Encoding["BlockPofHash"] = "bf";
  Encoding["BlockTxHash"] = "bx";
  Encoding["BlockStateHash"] = "bs";
  Encoding["Channel"] = "ch";
  Encoding["ContractAddress"] = "ct";
  Encoding["ContractBytearray"] = "cb";
  Encoding["ContractStoreKey"] = "ck";
  Encoding["ContractStoreValue"] = "cv";
  Encoding["Transaction"] = "tx";
  Encoding["TxHash"] = "th";
  Encoding["OracleAddress"] = "ok";
  Encoding["OracleQuery"] = "ov";
  Encoding["OracleQueryId"] = "oq";
  Encoding["OracleResponse"] = "or";
  Encoding["AccountAddress"] = "ak";
  Encoding["Signature"] = "sg";
  Encoding["Commitment"] = "cm";
  Encoding["PeerPubkey"] = "pp";
  Encoding["Name"] = "nm";
  Encoding["State"] = "st";
  Encoding["Poi"] = "pi";
  Encoding["StateTrees"] = "ss";
  Encoding["CallStateTree"] = "cs";
  Encoding["Bytearray"] = "ba";
})(Encoding || (Encoding = {}));
;// CONCATENATED MODULE: ./src/utils/encoder.ts
 // js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions







/**
 * Calculate SHA256 hash of `input`
 * @param input - Data to hash
 * @returns Hash
 * @deprecated use `SubtleCrypto.digest` or `sha.js` package instead
 */

function sha256hash(input) {
  return new (sha256_default())().update(input).digest();
}
/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L177-L202}
 */

const base64Types = [Encoding.ContractBytearray, Encoding.ContractStoreKey, Encoding.ContractStoreValue, Encoding.Transaction, Encoding.OracleQuery, Encoding.OracleResponse, Encoding.State, Encoding.Poi, Encoding.StateTrees, Encoding.CallStateTree, Encoding.Bytearray];
const base58Types = [Encoding.KeyBlockHash, Encoding.MicroBlockHash, Encoding.BlockPofHash, Encoding.BlockTxHash, Encoding.BlockStateHash, Encoding.Channel, Encoding.ContractAddress, Encoding.TxHash, Encoding.OracleAddress, Encoding.OracleQueryId, Encoding.AccountAddress, Encoding.Signature, Encoding.Commitment, Encoding.PeerPubkey, Encoding.Name];
/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L261-L286}
 */

const byteSizeForType = {
  [Encoding.KeyBlockHash]: 32,
  [Encoding.MicroBlockHash]: 32,
  [Encoding.BlockPofHash]: 32,
  [Encoding.BlockTxHash]: 32,
  [Encoding.BlockStateHash]: 32,
  [Encoding.Channel]: 32,
  [Encoding.ContractAddress]: 32,
  [Encoding.TxHash]: 32,
  [Encoding.OracleAddress]: 32,
  [Encoding.OracleQueryId]: 32,
  [Encoding.AccountAddress]: 32,
  [Encoding.Signature]: 64,
  [Encoding.Commitment]: 32,
  [Encoding.PeerPubkey]: 32,
  [Encoding.State]: 32
};

function ensureValidLength(data, type) {
  if (!isKeyOfObject(type, byteSizeForType)) return;
  const reqLen = byteSizeForType[type];
  if (reqLen == null || data.length === reqLen) return;
  throw new PayloadLengthError(`Payload should be ${reqLen} bytes, got ${data.length} instead`);
}

const getChecksum = payload => sha256hash(sha256hash(payload)).slice(0, 4);

const addChecksum = payload => concatBuffers([payload, getChecksum(payload)]);

function getPayload(buffer) {
  const payload = buffer.slice(0, -4);
  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError();
  return payload;
}

const base64 = {
  encode: buffer => addChecksum(buffer).toString('base64'),
  decode: string => getPayload(Buffer.from(string, 'base64'))
};
const base58 = {
  encode: buffer => (0,external_bs58_.encode)(addChecksum(buffer)),
  decode: string => getPayload(Buffer.from((0,external_bs58_.decode)(string)))
};

const parseType = maybeType => {
  const base64Type = base64Types.find(t => t === maybeType);
  if (base64Type != null) return [base64Type, base64];
  const base58Type = base58Types.find(t => t === maybeType);
  if (base58Type != null) return [base58Type, base58];
  throw new ArgumentError('prefix', `one of ${[...base58Types, ...base64Types].join(', ')}`, maybeType);
};
/**
 * Decode data using the default encoding/decoding algorithm
 * @param data - An Base58/64check encoded and prefixed string
 * (ex tx_..., sg_..., ak_....)
 * @returns Decoded data
 */


function decode(data) {
  const [prefix, encodedPayload, extra] = data.split('_');
  if (encodedPayload == null) throw new DecodeError(`Encoded string missing payload: ${data}`);
  if (extra != null) throw new DecodeError(`Encoded string have extra parts: ${data}`);
  const [type, encoder] = parseType(prefix);
  const payload = encoder.decode(encodedPayload);
  ensureValidLength(payload, type);
  return payload;
}
/**
 * Encode data using the default encoding/decoding algorithm
 * @param data - An decoded data
 * @param type - Prefix of Transaction
 * @returns Encoded string Base58check or Base64check data
 */

function encode(data, type) {
  const [, encoder] = parseType(type);
  ensureValidLength(data, type);
  return `${type}_${encoder.encode(data)}`;
}
;// CONCATENATED MODULE: ./src/utils/crypto.ts
/*
 * ISC License (ISC)
 * Copyright 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */
 // js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions






/**
 * Generate address from secret key
 * @param secret - Private key
 * @returns Public key encoded as address
 */

function getAddressFromPriv(secret) {
  const secretBuffer = typeof secret === 'string' ? str2buf(secret) : secret;
  const keys = external_tweetnacl_default().sign.keyPair.fromSecretKey(secretBuffer);
  return encode(keys.publicKey, Encoding.AccountAddress);
}
/**
 * Check if address is valid
 * @param address - Address
 * @param prefix - Transaction prefix. Default: 'ak'
 * @returns is valid
 */

function isAddressValid(address) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Encoding.AccountAddress;

  try {
    decode(address);
    return true;
  } catch (e) {
    return false;
  }
}
/**
 * Generate a random salt (positive integer)
 * @returns random salt
 */

function genSalt() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
/**
 * Converts a positive integer to the smallest possible
 * representation in a binary digit representation
 * @param value - Value to encode
 * @returns Encoded number
 */

function encodeUnsigned(value) {
  const binary = Buffer.allocUnsafe(4);
  binary.writeUInt32BE(value);
  return binary.slice(binary.findIndex(i => i !== 0));
}
/**
 * Calculate 256bits Blake2b hash of `input`
 * @param input - Data to hash
 * @returns Hash
 */

function hash(input) {
  return Buffer.from((0,blake2b.blake2b)(input, undefined, 32)); // 256 bits
} // Todo Duplicated in tx builder. remove

/**
 * Compute contract address
 * @category contract
 * @param owner - Address of contract owner
 * @param nonce - Round when contract was created
 * @returns Contract address
 */

function encodeContractAddress(owner, nonce) {
  const publicKey = decode(owner);
  const binary = concatBuffers([publicKey, encodeUnsigned(nonce)]);
  return encode(hash(binary), Encoding.ContractAddress);
} // KEY-PAIR HELPERS

/**
 * Generate keyPair from secret key
 * @param secret - secret key
 * @returns Object with Private(privateKey) and Public(publicKey) keys
 */

function generateKeyPairFromSecret(secret) {
  return external_tweetnacl_default().sign.keyPair.fromSecretKey(secret);
}
/**
 * Generate a random ED25519 keypair
 * @param raw - Whether to return raw (binary) keys
 * @returns Key pair
 */

function generateKeyPair() {
  let raw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  const keyPair = external_tweetnacl_default().sign.keyPair();
  const publicBuffer = Buffer.from(keyPair.publicKey);
  const secretBuffer = Buffer.from(keyPair.secretKey);

  if (raw) {
    return {
      publicKey: publicBuffer,
      secretKey: secretBuffer
    };
  }

  return {
    publicKey: encode(publicBuffer, Encoding.AccountAddress),
    secretKey: secretBuffer.toString('hex')
  };
} // SIGNATURES

/**
 * Generate signature
 * @param data - Data to sign
 * @param privateKey - Key to sign with
 * @returns Signature
 */

function sign(data, privateKey) {
  return external_tweetnacl_default().sign.detached(Buffer.from(data), Buffer.from(privateKey));
}
/**
 * Verify that signature was signed by public key
 * @param data - Data to verify
 * @param signature - Signature to verify
 * @param publicKey - Key to verify against
 * @returns Valid?
 */

function verify(data, signature, publicKey) {
  const publicKeyBuffer = typeof publicKey === 'string' ? str2buf(publicKey) : publicKey;
  return external_tweetnacl_default().sign.detached.verify(data, signature, publicKeyBuffer);
}
function messageToHash(message) {
  const p = Buffer.from('aeternity Signed Message:\n', 'utf8');
  const msg = Buffer.from(message, 'utf8');
  return hash(concatBuffers([(0,external_varuint_bitcoin_.encode)(p.length), p, (0,external_varuint_bitcoin_.encode)(msg.length), msg]));
}
function signMessage(message, privateKey) {
  return sign(messageToHash(message), privateKey);
}
function verifyMessage(str, signature, publicKey) {
  return verify(messageToHash(str), signature, publicKey);
}
/**
 * Check key pair for validity
 *
 * Sign a message, and then verifying that signature
 * @param privateKey - Private key to verify
 * @param publicKey - Public key to verify
 * @returns Valid?
 */

function isValidKeypair(privateKey, publicKey) {
  const message = Buffer.from('TheMessage');
  const signature = sign(message, privateKey);
  return verify(message, signature, publicKey);
}
;// CONCATENATED MODULE: ./src/tx/builder/constants.ts

 // # AENS

const NAME_TTL = 180000; // # max number of block into the future that the name is going to be available
// # https://github.com/aeternity/protocol/blob/epoch-v0.22.0/AENS.md#update
// # https://github.com/aeternity/protocol/blob/44a93d3aab957ca820183c3520b9daf6b0fedff4/AENS.md#aens-entry

const NAME_MAX_TTL = 36000;
const NAME_MAX_CLIENT_TTL = 84600;
const CLIENT_TTL = NAME_MAX_CLIENT_TTL;
const MIN_GAS_PRICE = 1e9; // # see https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L67

const NAME_FEE_MULTIPLIER = 1e14; // 100000000000000

const NAME_FEE_BID_INCREMENT = 0.05; // # the increment is in percentage
// # see https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L272

const NAME_BID_TIMEOUT_BLOCKS = 480; // # ~1 day
// # this is the max length for a domain that requires a base fee to be paid

const NAME_MAX_LENGTH_FEE = 31;
const NAME_BID_MAX_LENGTH = 12; // # this is the max length for a domain to be part of a bid
// # https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L290
// # https://github.com/aeternity/protocol/blob/master/AENS.md#protocol-fees-and-protection-times
// # bid ranges:

const NAME_BID_RANGES = mapObject({
  31: 3,
  30: 5,
  29: 8,
  28: 13,
  27: 21,
  26: 34,
  25: 55,
  24: 89,
  23: 144,
  22: 233,
  21: 377,
  20: 610,
  19: 987,
  18: 1597,
  17: 2584,
  16: 4181,
  15: 6765,
  14: 10946,
  13: 17711,
  12: 28657,
  11: 46368,
  10: 75025,
  9: 121393,
  8: 196418,
  7: 317811,
  6: 514229,
  5: 832040,
  4: 1346269,
  3: 2178309,
  2: 3524578,
  1: 5702887
}, _ref => {
  let [key, value] = _ref;
  return [key, new (external_bignumber_js_default())(value).times(NAME_FEE_MULTIPLIER)];
});
/**
 * Enum with tag types
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/serializations.md#binary-serialization}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_chain_objects.erl#L39-L97}
 */
// TODO: implement serialisation for commented-out tags

let Tag;

(function (Tag) {
  Tag[Tag["Account"] = 10] = "Account";
  Tag[Tag["SignedTx"] = 11] = "SignedTx";
  Tag[Tag["SpendTx"] = 12] = "SpendTx";
  Tag[Tag["OracleRegisterTx"] = 22] = "OracleRegisterTx";
  Tag[Tag["OracleQueryTx"] = 23] = "OracleQueryTx";
  Tag[Tag["OracleResponseTx"] = 24] = "OracleResponseTx";
  Tag[Tag["OracleExtendTx"] = 25] = "OracleExtendTx";
  Tag[Tag["NameClaimTx"] = 32] = "NameClaimTx";
  Tag[Tag["NamePreclaimTx"] = 33] = "NamePreclaimTx";
  Tag[Tag["NameUpdateTx"] = 34] = "NameUpdateTx";
  Tag[Tag["NameRevokeTx"] = 35] = "NameRevokeTx";
  Tag[Tag["NameTransferTx"] = 36] = "NameTransferTx";
  Tag[Tag["Contract"] = 40] = "Contract";
  Tag[Tag["ContractCall"] = 41] = "ContractCall";
  Tag[Tag["ContractCreateTx"] = 42] = "ContractCreateTx";
  Tag[Tag["ContractCallTx"] = 43] = "ContractCallTx";
  Tag[Tag["ChannelCreateTx"] = 50] = "ChannelCreateTx";
  Tag[Tag["ChannelDepositTx"] = 51] = "ChannelDepositTx";
  Tag[Tag["ChannelWithdrawTx"] = 52] = "ChannelWithdrawTx";
  Tag[Tag["ChannelForceProgressTx"] = 521] = "ChannelForceProgressTx";
  Tag[Tag["ChannelCloseMutualTx"] = 53] = "ChannelCloseMutualTx";
  Tag[Tag["ChannelCloseSoloTx"] = 54] = "ChannelCloseSoloTx";
  Tag[Tag["ChannelSlashTx"] = 55] = "ChannelSlashTx";
  Tag[Tag["ChannelSettleTx"] = 56] = "ChannelSettleTx";
  Tag[Tag["ChannelOffChainTx"] = 57] = "ChannelOffChainTx";
  Tag[Tag["ChannelOffChainUpdateTransfer"] = 570] = "ChannelOffChainUpdateTransfer";
  Tag[Tag["ChannelOffChainUpdateDeposit"] = 571] = "ChannelOffChainUpdateDeposit";
  Tag[Tag["ChannelOffChainUpdateWithdraw"] = 572] = "ChannelOffChainUpdateWithdraw";
  Tag[Tag["ChannelOffChainUpdateCreateContract"] = 573] = "ChannelOffChainUpdateCreateContract";
  Tag[Tag["ChannelOffChainUpdateCallContract"] = 574] = "ChannelOffChainUpdateCallContract";
  Tag[Tag["ChannelClientReconnectTx"] = 575] = "ChannelClientReconnectTx";
  Tag[Tag["Channel"] = 58] = "Channel";
  Tag[Tag["ChannelSnapshotSoloTx"] = 59] = "ChannelSnapshotSoloTx";
  Tag[Tag["TreesPoi"] = 60] = "TreesPoi";
  Tag[Tag["StateTrees"] = 62] = "StateTrees";
  Tag[Tag["Mtree"] = 63] = "Mtree";
  Tag[Tag["MtreeValue"] = 64] = "MtreeValue";
  Tag[Tag["ContractsMtree"] = 621] = "ContractsMtree";
  Tag[Tag["CallsMtree"] = 622] = "CallsMtree";
  Tag[Tag["ChannelsMtree"] = 623] = "ChannelsMtree";
  Tag[Tag["NameserviceMtree"] = 624] = "NameserviceMtree";
  Tag[Tag["OraclesMtree"] = 625] = "OraclesMtree";
  Tag[Tag["AccountsMtree"] = 626] = "AccountsMtree";
  Tag[Tag["CompilerSophia"] = 70] = "CompilerSophia";
  Tag[Tag["GaAttachTx"] = 80] = "GaAttachTx";
  Tag[Tag["GaMetaTx"] = 81] = "GaMetaTx";
  Tag[Tag["PayingForTx"] = 82] = "PayingForTx";
})(Tag || (Tag = {}));
;// CONCATENATED MODULE: ./src/tx/builder/address.ts




/**
 * Map of prefix to ID tag constant
 * @see {@link https://github.com/aeternity/protocol/blob/master/serializations.md#the-id-type}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_id.erl#L97-L102}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L163-L168}
 */

const idTagToEncoding = [Encoding.AccountAddress, Encoding.Name, Encoding.Commitment, Encoding.OracleAddress, Encoding.ContractAddress, Encoding.Channel];

/**
 * Utility function to create and _id type
 * @category transaction builder
 * @param hashId - Encoded hash
 * @returns Buffer Buffer with ID tag and decoded HASh
 */
function writeId(hashId) {
  if (typeof hashId !== 'string') throw new ArgumentError('hashId', 'a string', hashId);
  const encoding = hashId.slice(0, 2);
  if (!isItemOfArray(encoding, idTagToEncoding)) throw new TagNotFoundError(encoding);
  const idTag = idTagToEncoding.indexOf(encoding) + 1;
  return Buffer.from([...toBytes(idTag), ...decode(hashId)]);
}
/**
 * Utility function to read and _id type
 * @category transaction builder
 * @param buf - Data
 * @returns Encoided hash string with prefix
 */

function readId(buf) {
  const idTag = Buffer.from(buf).readUIntBE(0, 1);
  const encoding = idTagToEncoding[idTag - 1];
  if (encoding == null) throw new PrefixNotFoundError(idTag);
  return encode(buf.slice(1, buf.length), encoding);
}
;// CONCATENATED MODULE: ./src/tx/builder/helpers.ts









/**
 * JavaScript-based Transaction builder helper function's
 */

/**
 * Build a contract public key
 * @category contract
 * @param ownerId - The public key of the owner account
 * @param nonce - the nonce of the transaction
 * @returns Contract public key
 */

function buildContractId(ownerId, nonce) {
  const ownerIdAndNonce = Buffer.from([...decode(ownerId), ...toBytes(nonce)]);
  const b2bHash = hash(ownerIdAndNonce);
  return encode(b2bHash, Encoding.ContractAddress);
}
/**
 * Build a oracle query id
 * @category oracle
 * @param senderId - The public key of the sender account
 * @param nonce - the nonce of the transaction
 * @param oracleId - The oracle public key
 * @returns Contract public key
 */

function oracleQueryId(senderId, nonce, oracleId) {
  function _int32(val) {
    const nonceBE = toBytes(val, true);
    return concatBuffers([Buffer.alloc(32 - nonceBE.length), nonceBE]);
  }

  const b2bHash = hash(Buffer.from([...decode(senderId), ..._int32(nonce), ...decode(oracleId)]));
  return encode(b2bHash, Encoding.OracleQueryId);
}
/**
 * Format the salt into a 64-byte hex string
 * @category transaction builder
 * @param salt - Random number
 * @returns Zero-padded hex string of salt
 */

function formatSalt(salt) {
  return Buffer.from(salt.toString(16).padStart(64, '0'), 'hex');
}
/**
 * Encode an AENS name
 * @category AENS
 * @param name - Name to encode
 * @returns `nm_` prefixed encoded AENS name
 */

function produceNameId(name) {
  return encode(hash(name.toLowerCase()), Encoding.Name);
}
/**
 * Generate the commitment hash by hashing the formatted salt and
 * name, base 58 encoding the result and prepending 'cm_'
 * @category transaction builder
 * @param name - Name to be registered
 * @param salt - Random salt
 * @returns Commitment hash
 */

function commitmentHash(name) {
  let salt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : genSalt();
  return encode(hash(concatBuffers([Buffer.from(name.toLowerCase()), formatSalt(salt)])), Encoding.Commitment);
}
/**
 * Utility function to convert int to bytes
 * @category transaction builder
 * @param val - Value
 * @returns Buffer Buffer from number(BigEndian)
 */

function writeInt(val) {
  return toBytes(val, true);
}
/**
 * Utility function to convert bytes to int
 * @category transaction builder
 * @param buf - Value
 * @returns Buffer Buffer from number(BigEndian)
 */

function readInt() {
  let buf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.from([]);
  return new (external_bignumber_js_default())(Buffer.from(buf).toString('hex'), 16).toString(10);
}
/**
 * Helper function to build pointers for name update TX
 * @category transaction builder
 * @param pointers - Array of pointers
 * `([ { key: 'account_pubkey', id: 'ak_32klj5j23k23j5423l434l2j3423'} ])`
 * @returns Serialized pointers array
 */

function buildPointers(pointers) {
  return pointers.map(p => [toBytes(p.key), writeId(p.id)]);
}
/**
 * Helper function to read pointers from name update TX
 * @category transaction builder
 * @param pointers - Array of pointers
 * @returns Deserialize pointer array
 */

function readPointers(pointers) {
  return pointers.map(_ref => {
    let [key, id] = _ref;
    return {
      key: key.toString(),
      id: readId(id)
    };
  });
}
const AENS_SUFFIX = '.chain';
/**
 * Is AENS name valid
 * @category AENS
 * @param name - AENS name
 */

function isNameValid(name) {
  // TODO: probably there are stronger requirements
  return name.endsWith(AENS_SUFFIX);
}
const encodingToPointerKey = [[Encoding.AccountAddress, 'account_pubkey'], [Encoding.OracleAddress, 'oracle_pubkey'], [Encoding.ContractAddress, 'contract_pubkey'], [Encoding.Channel, 'channel']];
/**
 * @category AENS
 * @param identifier - account/oracle/contract address, or channel
 * @returns default AENS pointer key
 */

function getDefaultPointerKey(identifier) {
  var _encodingToPointerKey;

  decode(identifier);
  const encoding = identifier.substring(0, 2);
  const result = (_encodingToPointerKey = encodingToPointerKey.find(_ref2 => {
    let [e] = _ref2;
    return e === encoding;
  })) === null || _encodingToPointerKey === void 0 ? void 0 : _encodingToPointerKey[1];
  if (result != null) return result;
  throw new ArgumentError('identifier', `prefixed with one of ${encodingToPointerKey.map(_ref3 => {
    let [e] = _ref3;
    return `${e}_`;
  }).join(', ')}`, identifier);
}
/**
 * Get the minimum AENS name fee
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @returns the minimum fee for the AENS name auction
 */

function getMinimumNameFee(name) {
  const nameLength = name.length - AENS_SUFFIX.length;
  return NAME_BID_RANGES[Math.min(nameLength, NAME_MAX_LENGTH_FEE)];
}
/**
 * Compute bid fee for AENS auction
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @param options - Options
 * @param options.startFee - Auction start fee
 * @param options.increment - Bid multiplier(In percentage, must be between 0 and 1)
 * @returns Bid fee
 */

function computeBidFee(name) {
  let {
    startFee,
    increment = NAME_FEE_BID_INCREMENT
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!(Number(increment) === increment && increment % 1 !== 0)) throw new IllegalBidFeeError(`Increment must be float. Current increment ${increment}`);
  if (increment < NAME_FEE_BID_INCREMENT) throw new IllegalBidFeeError(`minimum increment percentage is ${NAME_FEE_BID_INCREMENT}`); // FIXME: increment should be used somehow here

  return ceil(new (external_bignumber_js_default())(startFee !== null && startFee !== void 0 ? startFee : getMinimumNameFee(name)).times(new (external_bignumber_js_default())(NAME_FEE_BID_INCREMENT).plus(1)));
}
/**
 * Compute auction end height
 * @category AENS
 * @param name - Name to compute auction end for
 * @param claimHeight - Auction starting height
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L273}
 * @returns Auction end height
 */

function computeAuctionEndBlock(name, claimHeight) {
  const length = name.length - AENS_SUFFIX.length;
  const h = length <= 4 && 62 * NAME_BID_TIMEOUT_BLOCKS || length <= 8 && 31 * NAME_BID_TIMEOUT_BLOCKS || length <= 12 && NAME_BID_TIMEOUT_BLOCKS || 0;
  return h + claimHeight;
}
/**
 * Is name accept going to auction
 * @category AENS
 */

function isAuctionName(name) {
  return name.length < 13 + AENS_SUFFIX.length;
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/u-int.ts


/* harmony default export */ const u_int = ({
  serialize(value) {
    if (value < 0) throw new ArgumentError('value', 'greater or equal to 0', value);
    return writeInt(value);
  },

  deserialize(value) {
    return readInt(value);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/short-u-int.ts

/* harmony default export */ const short_u_int = ({
  serialize(value) {
    return u_int.serialize(value);
  },

  deserialize(value) {
    return +u_int.deserialize(value);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/coin-amount.ts



/* harmony default export */ const coin_amount = ({ ...u_int,

  serializeAettos(value) {
    if (value == null) throw new ArgumentError('value', 'provided', value);
    return value;
  },

  serializeOptional(value, _ref) {
    let {
      denomination,
      ...options
    } = _ref;
    return u_int.serialize(this.serializeAettos(value != null ? formatAmount(value, {
      denomination
    }) : value, options));
  },

  serialize(value, options) {
    return this.serializeOptional(value, options);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/deposit.ts


/* harmony default export */ const deposit = ({ ...coin_amount,

  /**
   * @param value - Deposit value in string format. Should be equal to '0'.
   * @param options - Options
   * @returns Deposit value Buffer.
   */
  serialize(value, options) {
    var _value;

    (_value = value) !== null && _value !== void 0 ? _value : value = 0;
    if (+value !== 0) throw new IllegalArgumentError(`Contract deposit is not refundable, so it should be equal 0, got ${value.toString()} instead`);
    return coin_amount.serialize(value, options);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/fee.ts






const BASE_GAS = 15000;
const GAS_PER_BYTE = 20;
const KEY_BLOCK_INTERVAL = 3;
/**
 * Calculate the Base fee gas
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @returns The base fee
 * @example
 * ```js
 * TX_FEE_BASE('channelForceProgress') => new BigNumber(30 * 15000)
 * ```
 */

const TX_FEE_BASE_GAS = txType => {
  var _feeFactors;

  const feeFactors = {
    [Tag.ChannelForceProgressTx]: 30,
    [Tag.ChannelOffChainTx]: 0,
    [Tag.ChannelOffChainUpdateCallContract]: 0,
    [Tag.ChannelOffChainUpdateCreateContract]: 0,
    [Tag.ChannelOffChainUpdateDeposit]: 0,
    [Tag.ChannelOffChainUpdateWithdraw]: 0,
    [Tag.ChannelOffChainUpdateTransfer]: 0,
    [Tag.ContractCreateTx]: 5,
    [Tag.ContractCallTx]: 12,
    [Tag.GaAttachTx]: 5,
    [Tag.GaMetaTx]: 5,
    [Tag.PayingForTx]: 1 / 5
  };
  const factor = (_feeFactors = feeFactors[txType]) !== null && _feeFactors !== void 0 ? _feeFactors : 1;
  return new (external_bignumber_js_default())(factor * BASE_GAS);
};
/**
 * Calculate fee for Other types of transactions
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @param txSize - The transaction size
 * @returns parameters - The transaction parameters
 * @returns parameters.relativeTtl - The relative ttl
 * @returns parameters.innerTxSize - The size of the inner transaction
 * @returns The Other fee
 * @example
 * ```js
 * TX_FEE_OTHER_GAS('oracleResponse',10, { relativeTtl: 10, innerTxSize: 10 })
 *  => new BigNumber(10).times(20).plus(Math.ceil(32000 * 10 / Math.floor(60 * 24 * 365 / 2)))
 * ```
 */


const TX_FEE_OTHER_GAS = (txType, txSize, _ref) => {
  let {
    relativeTtl,
    innerTxSize
  } = _ref;

  switch (txType) {
    case Tag.OracleRegisterTx:
    case Tag.OracleExtendTx:
    case Tag.OracleQueryTx:
    case Tag.OracleResponseTx:
      return new (external_bignumber_js_default())(txSize).times(GAS_PER_BYTE).plus(Math.ceil(32000 * relativeTtl / Math.floor(60 * 24 * 365 / KEY_BLOCK_INTERVAL)));

    case Tag.GaMetaTx:
    case Tag.PayingForTx:
      return new (external_bignumber_js_default())(txSize).minus(innerTxSize).times(GAS_PER_BYTE);

    default:
      return new (external_bignumber_js_default())(txSize).times(GAS_PER_BYTE);
  }
};

function getOracleRelativeTtl(params, txType) {
  const ttlKeys = {
    [Tag.OracleRegisterTx]: 'oracleTtlValue',
    [Tag.OracleExtendTx]: 'oracleTtlValue',
    [Tag.OracleQueryTx]: 'queryTtlValue',
    [Tag.OracleResponseTx]: 'responseTtlValue'
  };
  if (!isKeyOfObject(txType, ttlKeys)) return 1;
  return params[ttlKeys[txType]];
}
/**
 * Calculate fee based on tx type and params
 */


function buildFee(txType, buildTx) {
  var _context;

  const {
    rlpEncoded: {
      length
    },
    txObject
  } = buildTx;
  return TX_FEE_BASE_GAS(txType).plus(TX_FEE_OTHER_GAS(txType, length, {
    relativeTtl: getOracleRelativeTtl(txObject, txType),
    innerTxSize: includes_default()(_context = [Tag.GaMetaTx, Tag.PayingForTx]).call(_context, txType) ? txObject.tx.tx.encodedTx.rlpEncoded.length : 0
  })).times(MIN_GAS_PRICE);
}
/**
 * Calculate min fee
 * @category transaction builder
 * @param txType - Transaction type
 * @param rebuildTx - Callback to get built transaction with specific fee
 */

function calculateMinFee(txType, rebuildTx) {
  let fee = new (external_bignumber_js_default())(0);
  let previousFee;

  do {
    previousFee = fee;
    fee = buildFee(txType, rebuildTx(fee));
  } while (!fee.eq(previousFee));

  return fee;
}
/* harmony default export */ const fee = ({ ...coin_amount,

  serializeAettos(_value, _ref2) {
    let {
      txType,
      rebuildTx,
      _computingMinFee
    } = _ref2;
    if (_computingMinFee != null) return _computingMinFee;
    const minFee = calculateMinFee(txType, fee => rebuildTx({
      _computingMinFee: fee
    }));
    const value = new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minFee);

    if (minFee.gt(value)) {
      throw new IllegalArgumentError(`Fee ${value.toString()} must be bigger then ${minFee}`);
    }

    return value.toFixed();
  },

  serialize: coin_amount.serializeOptional
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/gas-limit.ts





function calculateGasLimitMax(txType, gasMax, rebuildTx) {
  return gasMax - +buildFee(txType, rebuildTx(gasMax)).dividedBy(MIN_GAS_PRICE);
}

/* harmony default export */ const gas_limit = ({ ...short_u_int,

  serialize(_value, _ref) {
    let {
      txType,
      rebuildTx,
      gasMax = 6e6,
      _computingGasLimit
    } = _ref;
    if (_computingGasLimit != null) return short_u_int.serialize(_computingGasLimit);
    const gasLimitMax = calculateGasLimitMax(txType, gasMax, gasLimit => rebuildTx({
      _computingGasLimit: gasLimit
    }));
    const value = _value !== null && _value !== void 0 ? _value : gasLimitMax;

    if (value > gasLimitMax) {
      throw new IllegalArgumentError(`Gas limit ${value} must be less or equal to ${gasLimitMax}`);
    }

    return short_u_int.serialize(value);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/gas-price.ts



/* harmony default export */ const gas_price = ({ ...coin_amount,

  serializeAettos() {
    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MIN_GAS_PRICE.toString();

    if (+value < MIN_GAS_PRICE) {
      throw new IllegalArgumentError(`Gas price ${value.toString()} must be bigger then ${MIN_GAS_PRICE}`);
    }

    return value;
  },

  serialize: coin_amount.serializeOptional
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/field.ts
/* harmony default export */ const field = ({
  serialize(value) {
    return Buffer.from(value);
  },

  deserialize(value) {
    return value.toString();
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name.ts

/* harmony default export */ const field_types_name = ({
  /**
   * @param value - AENS name
   */
  serialize(value) {
    return field.serialize(value);
  },

  /**
   * @param value - AENS name
   */
  deserialize(value) {
    return field.deserialize(value);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name-fee.ts




/* harmony default export */ const name_fee = ({ ...coin_amount,

  serializeAettos(_value, txFields) {
    const minNameFee = getMinimumNameFee(txFields.name);
    const value = new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minNameFee);
    if (minNameFee.gt(value)) throw new InsufficientNameFeeError(value, minNameFee);
    return value.toFixed();
  },

  /**
   * @param value - AENS name fee Buffer
   * @param txFields - Transaction fields
   * @param txFields.name - AENS Name in transaction
   */
  serialize(value, txFields) {
    return coin_amount.serializeOptional.call(this, value, txFields);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name-id.ts


/* harmony default export */ const name_id = ({
  /**
   * @param value - AENS name ID
   */
  serialize(value) {
    return writeId(isNameValid(value) ? produceNameId(value) : value);
  },

  /**
   * @param value - AENS name ID Buffer
   */
  deserialize(value) {
    return readId(value);
  }

});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/index.ts










 // TODO: remove after fixing https://github.com/Gerrit0/typedoc-plugin-missing-exports/issues/15

const field_types_field = (/* unused pure expression or super */ null && (_field));
const uInt = u_int;
const shortUInt = short_u_int;
const coinAmount = coin_amount;
const field_types_deposit = deposit;
const field_types_fee = fee;
const gasLimit = gas_limit;
const gasPrice = gas_price;
const builder_field_types_name = field_types_name;
const nameFee = name_fee;
const nameId = name_id;

;// CONCATENATED MODULE: ./src/tx/builder/schema.ts
/**
 * Transaction Schema for TxBuilder
 */
// # RLP version number
// # https://github.com/aeternity/protocol/blob/master/serializations.md#binary-serialization



let ORACLE_TTL_TYPES; // # TRANSACTION DEFAULT TTL

(function (ORACLE_TTL_TYPES) {
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["delta"] = 0] = "delta";
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["block"] = 1] = "block";
})(ORACLE_TTL_TYPES || (ORACLE_TTL_TYPES = {}));

const TX_TTL = 0; // # ORACLE

const QUERY_FEE = 30000;
const ORACLE_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 500
};
const QUERY_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 10
};
const RESPONSE_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 10
}; // # CONTRACT

const AMOUNT = 0;
const MAX_AUTH_FUN_GAS = 50000;
const DRY_RUN_ACCOUNT = {
  pub: 'ak_11111111111111111111111111111111273Yts',
  amount: 100000000000000000000000000000000000n
};

/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */
let VM_VERSIONS;
/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */

(function (VM_VERSIONS) {
  VM_VERSIONS[VM_VERSIONS["NO_VM"] = 0] = "NO_VM";
  VM_VERSIONS[VM_VERSIONS["SOPHIA"] = 1] = "SOPHIA";
  VM_VERSIONS[VM_VERSIONS["SOPHIA_IMPROVEMENTS_MINERVA"] = 3] = "SOPHIA_IMPROVEMENTS_MINERVA";
  VM_VERSIONS[VM_VERSIONS["SOPHIA_IMPROVEMENTS_FORTUNA"] = 4] = "SOPHIA_IMPROVEMENTS_FORTUNA";
  VM_VERSIONS[VM_VERSIONS["FATE"] = 5] = "FATE";
  VM_VERSIONS[VM_VERSIONS["SOPHIA_IMPROVEMENTS_LIMA"] = 6] = "SOPHIA_IMPROVEMENTS_LIMA";
  VM_VERSIONS[VM_VERSIONS["FATE_2"] = 7] = "FATE_2";
})(VM_VERSIONS || (VM_VERSIONS = {}));

let ABI_VERSIONS;
/**
 * @category transaction builder
 */

(function (ABI_VERSIONS) {
  ABI_VERSIONS[ABI_VERSIONS["NO_ABI"] = 0] = "NO_ABI";
  ABI_VERSIONS[ABI_VERSIONS["SOPHIA"] = 1] = "SOPHIA";
  ABI_VERSIONS[ABI_VERSIONS["FATE"] = 3] = "FATE";
})(ABI_VERSIONS || (ABI_VERSIONS = {}));

let PROTOCOL_VERSIONS; // First abi/vm by default

(function (PROTOCOL_VERSIONS) {
  PROTOCOL_VERSIONS[PROTOCOL_VERSIONS["IRIS"] = 5] = "IRIS";
})(PROTOCOL_VERSIONS || (PROTOCOL_VERSIONS = {}));

const PROTOCOL_VM_ABI = {
  [PROTOCOL_VERSIONS.IRIS]: {
    [Tag.ContractCreateTx]: {
      vmVersion: [VM_VERSIONS.FATE_2],
      abiVersion: [ABI_VERSIONS.FATE]
    },
    // TODO: Ensure that AEVM (SOPHIA?) is still available here
    [Tag.ContractCallTx]: {
      vmVersion: [],
      abiVersion: [ABI_VERSIONS.FATE, ABI_VERSIONS.SOPHIA]
    },
    [Tag.OracleRegisterTx]: {
      vmVersion: [],
      abiVersion: [ABI_VERSIONS.NO_ABI, ABI_VERSIONS.SOPHIA]
    }
  }
};

/**
 * @category transaction builder
 */
let FIELD_TYPES;

(function (FIELD_TYPES) {
  FIELD_TYPES[FIELD_TYPES["id"] = 0] = "id";
  FIELD_TYPES[FIELD_TYPES["ids"] = 1] = "ids";
  FIELD_TYPES[FIELD_TYPES["string"] = 2] = "string";
  FIELD_TYPES[FIELD_TYPES["binary"] = 3] = "binary";
  FIELD_TYPES[FIELD_TYPES["bool"] = 4] = "bool";
  FIELD_TYPES[FIELD_TYPES["hex"] = 5] = "hex";
  FIELD_TYPES[FIELD_TYPES["rlpBinary"] = 6] = "rlpBinary";
  FIELD_TYPES[FIELD_TYPES["rlpBinaries"] = 7] = "rlpBinaries";
  FIELD_TYPES[FIELD_TYPES["rawBinary"] = 8] = "rawBinary";
  FIELD_TYPES[FIELD_TYPES["signatures"] = 9] = "signatures";
  FIELD_TYPES[FIELD_TYPES["pointers"] = 10] = "pointers";
  FIELD_TYPES[FIELD_TYPES["offChainUpdates"] = 11] = "offChainUpdates";
  FIELD_TYPES[FIELD_TYPES["callStack"] = 12] = "callStack";
  FIELD_TYPES[FIELD_TYPES["proofOfInclusion"] = 13] = "proofOfInclusion";
  FIELD_TYPES[FIELD_TYPES["mptrees"] = 14] = "mptrees";
  FIELD_TYPES[FIELD_TYPES["callReturnType"] = 15] = "callReturnType";
  FIELD_TYPES[FIELD_TYPES["ctVersion"] = 16] = "ctVersion";
  FIELD_TYPES[FIELD_TYPES["abiVersion"] = 17] = "abiVersion";
  FIELD_TYPES[FIELD_TYPES["ttlType"] = 18] = "ttlType";
  FIELD_TYPES[FIELD_TYPES["sophiaCodeTypeInfo"] = 19] = "sophiaCodeTypeInfo";
  FIELD_TYPES[FIELD_TYPES["payload"] = 20] = "payload";
  FIELD_TYPES[FIELD_TYPES["stateTree"] = 21] = "stateTree";
})(FIELD_TYPES || (FIELD_TYPES = {}));

const BASE_TX = [['tag', shortUInt], ['VSN', shortUInt]];
const TX_SCHEMA = {
  [Tag.Account]: {
    1: [...BASE_TX, ['nonce', shortUInt], ['balance', uInt]],
    2: [...BASE_TX, ['flags', uInt], ['nonce', shortUInt], ['balance', uInt], ['gaContract', FIELD_TYPES.id, [Encoding.ContractAddress, Encoding.Name]], ['gaAuthFun', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.SignedTx]: {
    1: [...BASE_TX, ['signatures', FIELD_TYPES.signatures], ['encodedTx', FIELD_TYPES.rlpBinary]]
  },
  [Tag.SpendTx]: {
    1: [...BASE_TX, ['senderId', FIELD_TYPES.id, Encoding.AccountAddress], ['recipientId', FIELD_TYPES.id, [Encoding.AccountAddress, Encoding.Name]], ['amount', coinAmount], ['fee', field_types_fee], ['ttl', shortUInt], ['nonce', shortUInt], ['payload', FIELD_TYPES.payload]]
  },
  [Tag.NamePreclaimTx]: {
    1: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['commitmentId', FIELD_TYPES.id, Encoding.Commitment], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.NameClaimTx]: {
    2: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['name', builder_field_types_name], ['nameSalt', uInt], ['nameFee', nameFee], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.NameUpdateTx]: {
    1: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['nameId', nameId], ['nameTtl', uInt], ['pointers', FIELD_TYPES.pointers], ['clientTtl', shortUInt], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.NameTransferTx]: {
    1: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['nameId', nameId], ['recipientId', FIELD_TYPES.id, [Encoding.AccountAddress, Encoding.Name]], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.NameRevokeTx]: {
    1: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['nameId', nameId], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.Contract]: {
    1: [...BASE_TX, ['owner', FIELD_TYPES.id, Encoding.AccountAddress], ['ctVersion', FIELD_TYPES.ctVersion], ['code', FIELD_TYPES.binary, Encoding.ContractBytearray], ['log', FIELD_TYPES.binary, Encoding.ContractBytearray], ['active', FIELD_TYPES.bool], ['referers', FIELD_TYPES.ids, Encoding.AccountAddress], ['deposit', field_types_deposit]]
  },
  [Tag.ContractCreateTx]: {
    1: [...BASE_TX, ['ownerId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['code', FIELD_TYPES.binary, Encoding.ContractBytearray], ['ctVersion', FIELD_TYPES.ctVersion], ['fee', field_types_fee], ['ttl', shortUInt], ['deposit', field_types_deposit], ['amount', coinAmount], ['gasLimit', gasLimit], ['gasPrice', gasPrice], ['callData', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.ContractCallTx]: {
    1: [...BASE_TX, ['callerId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['contractId', FIELD_TYPES.id, [Encoding.ContractAddress, Encoding.Name]], ['abiVersion', FIELD_TYPES.abiVersion], ['fee', field_types_fee], ['ttl', shortUInt], ['amount', coinAmount], ['gasLimit', gasLimit], ['gasPrice', gasPrice], ['callData', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.ContractCall]: {
    1: [...BASE_TX, ['callerId', FIELD_TYPES.id, Encoding.AccountAddress], ['callerNonce', shortUInt], ['height', shortUInt], ['contractId', FIELD_TYPES.id, Encoding.ContractAddress], ['gasPrice', gasPrice], ['gasUsed', shortUInt], ['returnValue', FIELD_TYPES.binary, Encoding.ContractBytearray], ['returnType', FIELD_TYPES.callReturnType], // TODO: add serialization for
    //  <log> :: [ { <address> :: id, [ <topics> :: binary() ], <data> :: binary() } ]
    ['log', FIELD_TYPES.rawBinary]]
  },
  [Tag.OracleRegisterTx]: {
    1: [...BASE_TX, ['accountId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['queryFormat', FIELD_TYPES.string], ['responseFormat', FIELD_TYPES.string], ['queryFee', coinAmount], ['oracleTtlType', FIELD_TYPES.ttlType], ['oracleTtlValue', shortUInt], ['fee', field_types_fee], ['ttl', shortUInt], ['abiVersion', FIELD_TYPES.abiVersion]]
  },
  [Tag.OracleExtendTx]: {
    1: [...BASE_TX, ['oracleId', FIELD_TYPES.id, [Encoding.OracleAddress, Encoding.Name]], ['nonce', shortUInt], ['oracleTtlType', FIELD_TYPES.ttlType], ['oracleTtlValue', shortUInt], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.OracleQueryTx]: {
    1: [...BASE_TX, ['senderId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['oracleId', FIELD_TYPES.id, [Encoding.OracleAddress, Encoding.Name]], ['query', FIELD_TYPES.string], ['queryFee', coinAmount], ['queryTtlType', FIELD_TYPES.ttlType], ['queryTtlValue', shortUInt], ['responseTtlType', FIELD_TYPES.ttlType], ['responseTtlValue', shortUInt], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.OracleResponseTx]: {
    1: [...BASE_TX, ['oracleId', FIELD_TYPES.id, Encoding.OracleAddress], ['nonce', shortUInt], ['queryId', FIELD_TYPES.binary, Encoding.OracleQueryId], ['response', FIELD_TYPES.string], ['responseTtlType', FIELD_TYPES.ttlType], ['responseTtlValue', shortUInt], ['fee', field_types_fee], ['ttl', shortUInt]]
  },
  [Tag.ChannelCreateTx]: {
    2: [...BASE_TX, ['initiator', FIELD_TYPES.id, Encoding.AccountAddress], ['initiatorAmount', uInt], ['responder', FIELD_TYPES.id, Encoding.AccountAddress], ['responderAmount', uInt], ['channelReserve', uInt], ['lockPeriod', uInt], ['ttl', shortUInt], ['fee', field_types_fee], ['initiatorDelegateIds', FIELD_TYPES.string], ['responderDelegateIds', FIELD_TYPES.string], ['stateHash', FIELD_TYPES.binary, 'st'], ['nonce', shortUInt]]
  },
  [Tag.ChannelCloseMutualTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['initiatorAmountFinal', uInt], ['responderAmountFinal', uInt], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelCloseSoloTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['payload', FIELD_TYPES.binary, 'tx'], ['poi', FIELD_TYPES.binary, 'pi'], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelSlashTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['payload', FIELD_TYPES.binary, 'tx'], ['poi', FIELD_TYPES.binary, 'pi'], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelDepositTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['amount', uInt], ['ttl', shortUInt], ['fee', field_types_fee], ['stateHash', FIELD_TYPES.binary, 'st'], ['round', shortUInt], ['nonce', shortUInt]]
  },
  [Tag.ChannelWithdrawTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['toId', FIELD_TYPES.id, Encoding.AccountAddress], ['amount', uInt], ['ttl', shortUInt], ['fee', field_types_fee], ['stateHash', FIELD_TYPES.binary, 'st'], ['round', shortUInt], ['nonce', shortUInt]]
  },
  [Tag.ChannelSettleTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['initiatorAmountFinal', uInt], ['responderAmountFinal', uInt], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelForceProgressTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['payload', FIELD_TYPES.binary, 'tx'], ['round', shortUInt], ['update', FIELD_TYPES.binary, Encoding.ContractBytearray], ['stateHash', FIELD_TYPES.binary, 'st'], ['offChainTrees', FIELD_TYPES.stateTree], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelOffChainTx]: {
    2: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['round', shortUInt], ['stateHash', FIELD_TYPES.binary, 'st']]
  },
  [Tag.Channel]: {
    3: [...BASE_TX, ['initiator', FIELD_TYPES.id, Encoding.AccountAddress], ['responder', FIELD_TYPES.id, Encoding.AccountAddress], ['channelAmount', uInt], ['initiatorAmount', uInt], ['responderAmount', uInt], ['channelReserve', uInt], ['initiatorDelegateIds', FIELD_TYPES.ids], ['responderDelegateIds', FIELD_TYPES.ids], ['stateHash', FIELD_TYPES.hex], ['round', shortUInt], ['soloRound', uInt], ['lockPeriod', uInt], ['lockedUntil', uInt], ['initiatorAuth', FIELD_TYPES.binary, Encoding.ContractBytearray], ['responderAuth', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.ChannelSnapshotSoloTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['fromId', FIELD_TYPES.id, Encoding.AccountAddress], ['payload', FIELD_TYPES.binary, 'tx'], ['ttl', shortUInt], ['fee', field_types_fee], ['nonce', shortUInt]]
  },
  [Tag.ChannelOffChainUpdateTransfer]: {
    1: [...BASE_TX, ['from', FIELD_TYPES.id, Encoding.AccountAddress], ['to', FIELD_TYPES.id, Encoding.AccountAddress], ['amount', uInt]]
  },
  [Tag.ChannelOffChainUpdateDeposit]: {
    1: [...BASE_TX, ['from', FIELD_TYPES.id, Encoding.AccountAddress], ['amount', uInt]]
  },
  [Tag.ChannelOffChainUpdateWithdraw]: {
    1: [...BASE_TX, ['from', FIELD_TYPES.id, Encoding.AccountAddress], ['amount', uInt]]
  },
  [Tag.ChannelOffChainUpdateCreateContract]: {
    1: [...BASE_TX, ['owner', FIELD_TYPES.id, Encoding.AccountAddress], ['ctVersion', FIELD_TYPES.ctVersion], ['code', FIELD_TYPES.binary, Encoding.ContractBytearray], ['deposit', uInt], ['callData', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.ChannelOffChainUpdateCallContract]: {
    1: [...BASE_TX, ['caller', FIELD_TYPES.id, Encoding.AccountAddress], ['contract', FIELD_TYPES.id, Encoding.ContractAddress], ['abiVersion', FIELD_TYPES.abiVersion], ['amount', uInt], ['callData', FIELD_TYPES.binary, Encoding.ContractBytearray], ['callStack', FIELD_TYPES.callStack], ['gasPrice', gasPrice], ['gasLimit', gasLimit]]
  },
  [Tag.ChannelClientReconnectTx]: {
    1: [...BASE_TX, ['channelId', FIELD_TYPES.id, Encoding.Channel], ['round', shortUInt], ['role', FIELD_TYPES.string], ['pubkey', FIELD_TYPES.id, Encoding.AccountAddress]]
  },
  [Tag.TreesPoi]: {
    1: [...BASE_TX, ['accounts', FIELD_TYPES.mptrees], ['calls', FIELD_TYPES.mptrees], ['channels', FIELD_TYPES.mptrees], ['contracts', FIELD_TYPES.mptrees], ['ns', FIELD_TYPES.mptrees], ['oracles', FIELD_TYPES.mptrees]]
  },
  [Tag.StateTrees]: {
    1: [...BASE_TX, ['contracts', FIELD_TYPES.rlpBinary], ['calls', FIELD_TYPES.rlpBinary], ['channels', FIELD_TYPES.rlpBinary], ['ns', FIELD_TYPES.rlpBinary], ['oracles', FIELD_TYPES.rlpBinary], ['accounts', FIELD_TYPES.rlpBinary]]
  },
  [Tag.Mtree]: {
    1: [...BASE_TX, ['values', FIELD_TYPES.rlpBinaries]]
  },
  [Tag.MtreeValue]: {
    1: [...BASE_TX, ['key', FIELD_TYPES.hex], ['value', FIELD_TYPES.rawBinary]]
  },
  [Tag.ContractsMtree]: {
    1: [...BASE_TX, ['contracts', FIELD_TYPES.rlpBinary]]
  },
  [Tag.CallsMtree]: {
    1: [...BASE_TX, ['calls', FIELD_TYPES.rlpBinary]]
  },
  [Tag.ChannelsMtree]: {
    1: [...BASE_TX, ['channels', FIELD_TYPES.rlpBinary]]
  },
  [Tag.NameserviceMtree]: {
    1: [...BASE_TX, ['mtree', FIELD_TYPES.rlpBinary]]
  },
  [Tag.OraclesMtree]: {
    1: [...BASE_TX, ['otree', FIELD_TYPES.rlpBinary]]
  },
  [Tag.AccountsMtree]: {
    1: [...BASE_TX, ['accounts', FIELD_TYPES.rlpBinary]]
  },
  [Tag.GaAttachTx]: {
    1: [...BASE_TX, ['ownerId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['code', FIELD_TYPES.binary, Encoding.ContractBytearray], ['authFun', FIELD_TYPES.rawBinary], ['ctVersion', FIELD_TYPES.ctVersion], ['fee', field_types_fee], ['ttl', shortUInt], ['gasLimit', gasLimit], ['gasPrice', gasPrice], ['callData', FIELD_TYPES.binary, Encoding.ContractBytearray]]
  },
  [Tag.GaMetaTx]: {
    2: [...BASE_TX, ['gaId', FIELD_TYPES.id, Encoding.AccountAddress], ['authData', FIELD_TYPES.binary, Encoding.ContractBytearray], ['abiVersion', FIELD_TYPES.abiVersion], ['fee', field_types_fee], ['gasLimit', gasLimit], ['gasPrice', gasPrice], ['tx', FIELD_TYPES.rlpBinary]]
  },
  [Tag.PayingForTx]: {
    1: [...BASE_TX, ['payerId', FIELD_TYPES.id, Encoding.AccountAddress], ['nonce', shortUInt], ['fee', field_types_fee], ['tx', FIELD_TYPES.rlpBinary]]
  },
  [Tag.CompilerSophia]: {
    3: [...BASE_TX, ['sourceCodeHash', FIELD_TYPES.rawBinary], ['typeInfo', FIELD_TYPES.sophiaCodeTypeInfo], ['byteCode', FIELD_TYPES.rawBinary], ['compilerVersion', FIELD_TYPES.string], ['payable', FIELD_TYPES.bool]]
  }
};
// EXTERNAL MODULE: external "rlp"
var external_rlp_ = __webpack_require__(3485);
;// CONCATENATED MODULE: ./src/utils/mptree.ts


/*
 * ISC License (ISC)
 * Copyright (c) 2021 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/* eslint-disable default-case */



var NodeType;

(function (NodeType) {
  NodeType[NodeType["Branch"] = 0] = "Branch";
  NodeType[NodeType["Extension"] = 1] = "Extension";
  NodeType[NodeType["Leaf"] = 2] = "Leaf";
})(NodeType || (NodeType = {}));

class MPTree {
  static nodeHash(node) {
    return Buffer.from(hash((0,external_rlp_.encode)(node))).toString('hex');
  }
  /**
   * Deserialize Merkle Patricia Tree
   * @param binary - Binary
   * @returns Merkle Patricia Tree
   */


  constructor(binary) {
    this.rootHash = binary[0].toString('hex');
    this.nodes = Object.fromEntries(binary[1].map(node => [node[0].toString('hex'), node[1]]));
    if (this.nodes[this.rootHash] === undefined) throw new MissingNodeInTreeError('Can\'t find a node by root hash');
    Object.entries(this.nodes).forEach(_ref => {
      let [key, node] = _ref;
      if (MPTree.nodeHash(node) !== key) throw new MerkleTreeHashMismatchError();
      const {
        type,
        payload
      } = MPTree.parseNode(node);

      switch (type) {
        case NodeType.Branch:
          payload.slice(0, 16).filter(n => n.length).forEach(n => {
            if (this.nodes[n.toString('hex')] === undefined) {
              throw new MissingNodeInTreeError('Can\'t find a node by hash in branch node');
            }
          });
          break;

        case NodeType.Extension:
          if (this.nodes[payload[0].toString('hex')] === undefined) {
            throw new MissingNodeInTreeError('Can\'t find a node by hash in extension node');
          }

      }
    });
  }

  isEqual(tree) {
    return this.rootHash === tree.rootHash;
  }

  static parseNode(node) {
    switch (node.length) {
      case 17:
        return {
          type: NodeType.Branch,
          payload: node,
          path: null
        };

      case 2:
        {
          var _context;

          const nibble = node[0][0] >> 4; // eslint-disable-line no-bitwise

          if (nibble > 3) throw new UnknownPathNibbleError(nibble);
          const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf;
          const slice = includes_default()(_context = [0, 2]).call(_context, nibble) ? 2 : 1;
          return {
            type,
            payload: [node[1]],
            path: node[0].toString('hex').slice(slice)
          };
        }

      default:
        throw new UnknownNodeLengthError(node.length);
    }
  }
  /**
   * Serialize Merkle Patricia Tree
   * @returns Binary
   */


  serialize() {
    return [Buffer.from(this.rootHash, 'hex'), Object.entries(this.nodes).map(_ref2 => {
      let [mptHash, value] = _ref2;
      return [Buffer.from(mptHash, 'hex'), value];
    })];
  }
  /**
   * Retrieve value from Merkle Patricia Tree
   * @param _key - The key of the element to retrieve
   * @returns Value associated to the specified key
   */


  get(_key) {
    let searchFrom = this.rootHash;
    let key = _key;

    while (true) {
      // eslint-disable-line no-constant-condition
      const {
        type,
        payload,
        path
      } = MPTree.parseNode(this.nodes[searchFrom]);

      switch (type) {
        case NodeType.Branch:
          if (key.length === 0) return payload[16];
          searchFrom = payload[+`0x${key[0]}`].toString('hex');
          key = key.substring(1);
          break;

        case NodeType.Extension:
          if (key.substring(0, path === null || path === void 0 ? void 0 : path.length) !== path) return undefined;
          searchFrom = payload[0].toString('hex');
          key = key.substring(path.length);
          break;

        case NodeType.Leaf:
          if (path !== key) return undefined;
          return payload[0];
      }
    }
  }

}
;// CONCATENATED MODULE: ./src/tx/builder/index.ts














/**
 * JavaScript-based Transaction builder
 */
// SERIALIZE AND DESERIALIZE PART
function deserializeField(value, type, prefix) {
  if (value == null) return '';

  switch (type) {
    case FIELD_TYPES.ctVersion:
      {
        const [vm,, abi] = value;
        return {
          vmVersion: readInt(Buffer.from([vm])),
          abiVersion: readInt(Buffer.from([abi]))
        };
      }

    case FIELD_TYPES.abiVersion:
    case FIELD_TYPES.ttlType:
      return readInt(value);

    case FIELD_TYPES.id:
      return readId(value);

    case FIELD_TYPES.ids:
      return value.map(readId);

    case FIELD_TYPES.bool:
      return value[0] === 1;

    case FIELD_TYPES.binary:
      return encode(value, prefix);

    case FIELD_TYPES.stateTree:
      return encode(value, Encoding.StateTrees);

    case FIELD_TYPES.string:
      return value.toString();

    case FIELD_TYPES.payload:
      return encode(value, Encoding.Bytearray);

    case FIELD_TYPES.pointers:
      return readPointers(value);

    case FIELD_TYPES.rlpBinary:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return unpackTx(encode(value, Encoding.Transaction));

    case FIELD_TYPES.rlpBinaries:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return value.map(v => unpackTx(encode(v, Encoding.Transaction)));

    case FIELD_TYPES.rawBinary:
      return value;

    case FIELD_TYPES.hex:
      return value.toString('hex');

    case FIELD_TYPES.offChainUpdates:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return value.map(v => unpackTx(encode(v, Encoding.Transaction)));

    case FIELD_TYPES.callStack:
      // TODO: fix this
      return [readInt(value)];

    case FIELD_TYPES.mptrees:
      return value.map(t => new MPTree(t));

    case FIELD_TYPES.callReturnType:
      switch (readInt(value)) {
        case '0':
          return 'ok';

        case '1':
          return 'error';

        case '2':
          return 'revert';

        default:
          return value;
      }

    case FIELD_TYPES.sophiaCodeTypeInfo:
      return value.reduce((acc, _ref) => {
        let [funHash, fnName, argType, outType] = _ref;
        return { ...acc,
          [fnName.toString()]: {
            funHash,
            argType,
            outType
          }
        };
      }, {});

    default:
      if (typeof type === 'number') return value;
      return type.deserialize(value);
  }
}

function serializeField(value, type, params) {
  var _value$rlpEncoded;

  switch (type) {
    case FIELD_TYPES.abiVersion:
    case FIELD_TYPES.ttlType:
      return writeInt(value);

    case FIELD_TYPES.id:
      return writeId(value);

    case FIELD_TYPES.ids:
      return value.map(writeId);

    case FIELD_TYPES.bool:
      return Buffer.from([value === true ? 1 : 0]);

    case FIELD_TYPES.binary:
      return decode(value);

    case FIELD_TYPES.stateTree:
      return decode(value);

    case FIELD_TYPES.hex:
      return Buffer.from(value, 'hex');

    case FIELD_TYPES.signatures:
      return value.map(Buffer.from);

    case FIELD_TYPES.payload:
      return typeof value === 'string' && value.split('_')[0] === 'ba' ? decode(value) : toBytes(value);

    case FIELD_TYPES.string:
      return toBytes(value);

    case FIELD_TYPES.pointers:
      return buildPointers(value);

    case FIELD_TYPES.rlpBinary:
      return (_value$rlpEncoded = value.rlpEncoded) !== null && _value$rlpEncoded !== void 0 ? _value$rlpEncoded : value;

    case FIELD_TYPES.mptrees:
      return value.map(t => t.serialize());

    case FIELD_TYPES.ctVersion:
      return Buffer.from([...toBytes(value.vmVersion), 0, ...toBytes(value.abiVersion)]);

    case FIELD_TYPES.callReturnType:
      switch (value) {
        case 'ok':
          return writeInt(0);

        case 'error':
          return writeInt(1);

        case 'revert':
          return writeInt(2);

        default:
          return value;
      }

    default:
      if (typeof type === 'number') return value; // @ts-expect-error will be solved after removing the whole serializeField function

      return type.serialize(value, params);
  }
}

function validateField(value, type, prefix) {
  // All fields are required
  if (value == null) return 'Field is required'; // Validate type of value

  switch (type) {
    case FIELD_TYPES.id:
      {
        const prefixes = Array.isArray(prefix) ? prefix : [prefix];

        if (!includes_default()(prefixes).call(prefixes, value.split('_')[0])) {
          if (prefix == null) {
            return `'${String(value)}' prefix doesn't exist'`;
          }

          return `'${String(value)}' prefix doesn't match expected prefix '${prefix.toString()}'`;
        }

        return undefined;
      }

    case FIELD_TYPES.ctVersion:
      if (!(Boolean(value.abiVersion) && Boolean(value.vmVersion))) {
        return 'Value must be an object with "vmVersion" and "abiVersion" fields';
      }

      return undefined;

    case FIELD_TYPES.pointers:
      if (!Array.isArray(value)) return 'Value must be of type Array';

      if (value.some(p => !(Boolean(p.key) && Boolean(p.id)))) {
        return 'Value must contains only object\'s like \'{key: "account_pubkey", id: "ak_lkamsflkalsdalksdlasdlasdlamd"}\'';
      }

      if (value.length > 32) {
        return `Expected 32 pointers or less, got ${value.length} instead`;
      }

      return undefined;

    default:
      return undefined;
  }
}
/**
 * Validate transaction params
 * @category transaction builder
 * @param params - Object with tx params
 * @param schema - Transaction schema
 * @param excludeKeys - Array of keys to exclude for validation
 * @returns Object with validation errors
 */


function validateParams(params, schema, _ref2) {
  let {
    excludeKeys = []
  } = _ref2;
  return Object.fromEntries(schema // TODO: allow optional keys in schema
  .filter(_ref3 => {
    var _context;

    let [key] = _ref3;
    return !includes_default()(excludeKeys).call(excludeKeys, key) && !includes_default()(_context = ['payload', 'nameFee', 'deposit', 'gasPrice', 'fee', 'gasLimit']).call(_context, key);
  }).map(_ref4 => {
    let [key, type, prefix] = _ref4;
    return [key, validateField(params[key], type, prefix)];
  }).filter(_ref5 => {
    let [, message] = _ref5;
    return message;
  }));
}
/**
 * Unpack binary transaction
 * @category transaction builder
 * @param binary - Array with binary transaction field's
 * @param schema - Transaction schema
 * @returns Object with transaction field's
 */

function unpackRawTx(binary, schema) {
  return schema.reduce((acc, _ref6, index) => {
    let [key, fieldType, prefix] = _ref6;
    return Object.assign(acc, {
      [key]: deserializeField(binary[index], fieldType, prefix)
    });
  }, {});
}
/**
 * @category transaction builder
 */

/**
 * Build transaction hash
 * @category transaction builder
 * @param _params - Object with tx params
 * @param type - Transaction type
 * @param options - options
 * @param options.excludeKeys - Array of keys to exclude for validation and build
 * @param options.denomination - Denomination of amounts
 * @param options.prefix - Prefix of transaction
 * @throws {@link InvalidTxParamsError}
 * @returns object
 * @returns object.tx Base64Check transaction hash with 'tx_' prefix
 * @returns object.rlpEncoded rlp encoded transaction
 * @returns object.binary binary transaction
 */
function buildTx(_params, type) {
  var _vsn;

  let {
    excludeKeys = [],
    prefix = Encoding.Transaction,
    vsn,
    denomination = AE_AMOUNT_FORMATS.AETTOS
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const schemas = TX_SCHEMA[type];
  (_vsn = vsn) !== null && _vsn !== void 0 ? _vsn : vsn = Math.max(...Object.keys(schemas).map(a => +a));
  if (!isKeyOfObject(vsn, schemas)) throw new SchemaNotFoundError('serialization', Tag[type], vsn);
  const schema = schemas[vsn];
  const params = _params;
  params.VSN = vsn;
  params.tag = type;
  params.denomination = denomination;
  const filteredSchema = schema.filter(_ref7 => {
    let [key] = _ref7;
    return !includes_default()(excludeKeys).call(excludeKeys, key);
  }); // Validation

  const valid = validateParams(params, schema, {
    excludeKeys
  });

  if (Object.keys(valid).length > 0) {
    throw new InvalidTxParamsError(`Transaction build error. ${JSON.stringify(valid)}`);
  }

  const binary = filteredSchema.map(_ref8 => {
    let [key, fieldType] = _ref8;
    return serializeField(params[key], fieldType, { ...params,
      txType: type,
      rebuildTx: overrideParams => buildTx({ ...params,
        ...overrideParams
      }, type, {
        excludeKeys,
        prefix: Encoding.Transaction,
        vsn,
        denomination
      })
    });
  }).filter(e => e !== undefined);
  const rlpEncoded = (0,external_rlp_.encode)(binary);
  const tx = encode(rlpEncoded, prefix);
  return {
    tx,
    rlpEncoded,
    binary,
    txObject: unpackRawTx(binary, schema)
  };
}
/**
 * @category transaction builder
 */

/**
 * Unpack transaction hash
 * @category transaction builder
 * @param encodedTx - Transaction to unpack
 * @param txType - Expected transaction type
 * @returns object
 * @returns object.tx Object with transaction param's
 * @returns object.txType Transaction type
 */
function unpackTx(encodedTx, txType) {
  const rlpEncoded = decode(encodedTx);
  const binary = (0,external_rlp_.decode)(rlpEncoded);
  const objId = +readInt(binary[0]);
  if (!isKeyOfObject(objId, TX_SCHEMA)) throw new DecodeError(`Unknown transaction tag: ${objId}`);
  if (txType != null && txType !== objId) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[objId]} instead`);
  const vsn = +readInt(binary[1]);
  if (!isKeyOfObject(vsn, TX_SCHEMA[objId])) throw new SchemaNotFoundError('deserialization', `tag ${objId}`, vsn);
  const schema = TX_SCHEMA[objId][vsn];
  return {
    txType: objId,
    tx: unpackRawTx(binary, schema),
    rlpEncoded
  };
}
/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */

function buildTxHash(rawTx) {
  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;
  return encode(hash(data), Encoding.TxHash);
}
/**
 * Build a contract public key by contractCreateTx or gaAttach
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */

function buildContractIdByContractTx(contractTx) {
  var _context2;

  const {
    txType,
    tx
  } = unpackTx(contractTx);

  if (!includes_default()(_context2 = [Tag.ContractCreateTx, Tag.GaAttachTx]).call(_context2, txType)) {
    throw new ArgumentError('contractCreateTx', 'a contractCreateTx or gaAttach', txType);
  }

  return buildContractId(tx.ownerId, +tx.nonce);
}
;// CONCATENATED MODULE: ./src/tx/validator.ts









const validators = [];

const getSenderAddress = tx => ['senderId', 'accountId', 'ownerId', 'callerId', 'oracleId', 'fromId', 'initiator', 'gaId', 'payerId'].map(key => tx[key]).filter(a => a).map(a => a === null || a === void 0 ? void 0 : a.toString().replace(/^ok_/, 'ak_'))[0];
/**
 * Transaction Validator
 * This function validates some of transaction properties,
 * to make sure it can be posted it to the chain
 * @category transaction builder
 * @param transaction - Base64Check-encoded transaction
 * @param node - Node to validate transaction against
 * @param parentTxTypes - Types of parent transactions
 * @returns Array with verification errors
 * @example const errors = await verifyTransaction(transaction, node)
 */


async function verifyTransaction(transaction, node) {
  var _getSenderAddress;

  let parentTxTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const {
    tx,
    txType
  } = unpackTx(transaction);
  const address = (_getSenderAddress = getSenderAddress(tx)) !== null && _getSenderAddress !== void 0 ? _getSenderAddress : txType === Tag.SignedTx ? getSenderAddress(tx.encodedTx.tx) : undefined;
  const [account, {
    height
  }, {
    consensusProtocolVersion,
    nodeNetworkId
  }] = await Promise.all([address == null ? undefined : node.getAccountByPubkey(address).catch(() => ({
    id: address,
    balance: 0n,
    nonce: 0
  })) // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537
  .then(acc => ({ ...acc,
    id: acc.id
  })), node.getCurrentKeyBlockHeight(), node.getNodeInfo()]);
  return (await Promise.all(validators.map(v => v(tx, {
    txType,
    node,
    account,
    height,
    consensusProtocolVersion,
    nodeNetworkId,
    parentTxTypes
  })))).flat();
}
validators.push((_ref, _ref2) => {
  let {
    encodedTx,
    signatures
  } = _ref;
  let {
    account,
    nodeNetworkId,
    parentTxTypes
  } = _ref2;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : signatures) === undefined) return [];
  if (account == null) return [];
  if (signatures.length !== 1) return []; // TODO: Support multisignature?

  const prefix = Buffer.from([nodeNetworkId, ...(includes_default()(parentTxTypes).call(parentTxTypes, Tag.PayingForTx) ? ['inner_tx'] : [])].join('-'));
  const txWithNetworkId = concatBuffers([prefix, encodedTx.rlpEncoded]);
  const txHashWithNetworkId = concatBuffers([prefix, hash(encodedTx.rlpEncoded)]);
  const decodedPub = decode(account.id);
  if (verify(txWithNetworkId, signatures[0], decodedPub) || verify(txHashWithNetworkId, signatures[0], decodedPub)) return [];
  return [{
    message: 'Signature cannot be verified, please ensure that you transaction have' + ' the correct prefix and the correct private key for the sender address',
    key: 'InvalidSignature',
    checkedKeys: ['encodedTx', 'signatures']
  }];
}, async (_ref3, _ref4) => {
  let {
    encodedTx,
    tx
  } = _ref3;
  let {
    node,
    parentTxTypes,
    txType
  } = _ref4;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : tx) === undefined) return [];
  return verifyTransaction(encode((encodedTx !== null && encodedTx !== void 0 ? encodedTx : tx).rlpEncoded, Encoding.Transaction), node, [...parentTxTypes, txType]);
}, (_ref5, _ref6) => {
  let {
    ttl
  } = _ref5;
  let {
    height
  } = _ref6;
  if (ttl === undefined) return [];
  ttl = +ttl;
  if (ttl === 0 || ttl >= height) return [];
  return [{
    message: `TTL ${ttl} is already expired, current height is ${height}`,
    key: 'ExpiredTTL',
    checkedKeys: ['ttl']
  }];
}, (_ref7, _ref8) => {
  var _ref9, _fee;

  let {
    amount,
    fee,
    nameFee,
    tx
  } = _ref7;
  let {
    account,
    parentTxTypes,
    txType
  } = _ref8;
  if (account == null) return [];
  if (((_ref9 = amount !== null && amount !== void 0 ? amount : fee) !== null && _ref9 !== void 0 ? _ref9 : nameFee) === undefined) return [];
  (_fee = fee) !== null && _fee !== void 0 ? _fee : fee = 0;
  const cost = new (external_bignumber_js_default())(fee).plus(nameFee !== null && nameFee !== void 0 ? nameFee : 0).plus(amount !== null && amount !== void 0 ? amount : 0).plus(txType === Tag.PayingForTx ? tx.tx.encodedTx.tx.fee : 0).minus(includes_default()(parentTxTypes).call(parentTxTypes, Tag.PayingForTx) ? fee : 0);
  if (cost.lte(account.balance.toString())) return [];
  return [{
    message: `Account balance ${account.balance.toString()} is not enough to execute the transaction that costs ${cost.toFixed()}`,
    key: 'InsufficientBalance',
    checkedKeys: ['amount', 'fee', 'nameFee']
  }];
}, (_ref10, _ref11) => {
  let {
    nonce
  } = _ref10;
  let {
    account,
    parentTxTypes
  } = _ref11;
  if (nonce == null || account == null || includes_default()(parentTxTypes).call(parentTxTypes, Tag.GaMetaTx)) return [];
  nonce = +nonce;
  const validNonce = account.nonce + 1;
  if (nonce === validNonce) return [];
  return [{ ...(nonce < validNonce ? {
      message: `Nonce ${nonce} is already used, valid nonce is ${validNonce}`,
      key: 'NonceAlreadyUsed'
    } : {
      message: `Nonce ${nonce} is too high, valid nonce is ${validNonce}`,
      key: 'NonceHigh'
    }),
    checkedKeys: ['nonce']
  }];
}, (_ref12, _ref13) => {
  let {
    ctVersion,
    abiVersion
  } = _ref12;
  let {
    txType,
    consensusProtocolVersion
  } = _ref13;

  if (!isKeyOfObject(consensusProtocolVersion, PROTOCOL_VM_ABI)) {
    throw new UnsupportedProtocolError(`Unsupported protocol: ${consensusProtocolVersion}`);
  }

  const protocol = PROTOCOL_VM_ABI[consensusProtocolVersion]; // If not contract create tx

  if (ctVersion == null) ctVersion = {
    abiVersion
  };
  const txProtocol = protocol[txType];
  if (txProtocol == null) return [];

  if (Object.entries(ctVersion).some(_ref14 => {
    var _context;

    let [key, value] = _ref14;
    return !includes_default()(_context = txProtocol[key]).call(_context, +value);
  })) {
    return [{
      message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(txProtocol)}`,
      key: 'VmAndAbiVersionMismatch',
      checkedKeys: ['ctVersion', 'abiVersion']
    }];
  }

  return [];
}, async (_ref15, _ref16) => {
  let {
    contractId
  } = _ref15;
  let {
    txType,
    node
  } = _ref16;
  if (Tag.ContractCallTx !== txType) return [];
  contractId = contractId;

  try {
    const {
      active
    } = await node.getContract(contractId);
    if (active) return [];
    return [{
      message: `Contract ${contractId} is not active`,
      key: 'ContractNotActive',
      checkedKeys: ['contractId']
    }];
  } catch (error) {
    var _error$response, _error$response$parse;

    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$parse = _error$response.parsedBody) === null || _error$response$parse === void 0 ? void 0 : _error$response$parse.reason) == null) throw error;
    return [{
      message: error.response.parsedBody.reason,
      key: 'ContractNotFound',
      checkedKeys: ['contractId']
    }];
  }
});
;// CONCATENATED MODULE: ./src/chain.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */








/**
 * @category chain
 */
function _getPollInterval(type, _ref) {
  let {
    _expectedMineRate = 180000,
    _microBlockCycle = 3000,
    _maxPollInterval = 5000
  } = _ref;
  const base = {
    block: _expectedMineRate,
    microblock: _microBlockCycle
  }[type];
  return Math.min(base / 3, _maxPollInterval);
}
/**
 * @category exception
 */

class InvalidTxError extends TransactionError {
  constructor(message, validation, transaction) {
    super(message);
    this.name = 'InvalidTxError';
    this.validation = validation;
    this.transaction = transaction;
  }

}
/**
 * Obtain current height of the chain
 * @category chain
 * @returns Current chain height
 */

async function getHeight(_ref2) {
  let {
    onNode
  } = _ref2;
  return (await onNode.getCurrentKeyBlockHeight()).height;
}
/**
 * Wait for a transaction to be mined
 * @category chain
 * @param th - The hash of transaction to poll
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.blocks - Number of blocks mined after which to fail
 * @param options.onNode - Node to use
 * @returns The transaction as it was mined
 */

async function poll(th, _ref3) {
  var _interval;

  let {
    blocks = 10,
    interval,
    onNode,
    ...options
  } = _ref3;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const max = (await getHeight({
    onNode
  })) + blocks;

  do {
    const tx = await onNode.getTransactionByHash(th);
    if (tx.blockHeight !== -1) return tx;
    await pause(interval);
  } while ((await getHeight({
    onNode
  })) < max);

  throw new TxTimedOutError(blocks, th);
}
/**
 * Wait for the chain to reach a specific height
 * @category chain
 * @param height - Height to wait for
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.onNode - Node to use
 * @returns Current chain height
 */

async function awaitHeight(height, _ref4) {
  var _interval2;

  let {
    interval,
    onNode,
    ...options
  } = _ref4;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('block', options);
  let currentHeight;

  do {
    if (currentHeight != null) await pause(interval);
    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;
  } while (currentHeight < height);

  return currentHeight;
}
/**
 * Wait for transaction confirmation
 * @category chain
 * @param txHash - Transaction hash
 * @param options - Options
 * @param options.confirm - Number of micro blocks to wait for transaction confirmation
 * @param options.onNode - Node to use
 * @returns Current Height
 */

async function waitForTxConfirm(txHash, _ref5) {
  let {
    confirm = 3,
    onNode,
    ...options
  } = _ref5;
  const {
    blockHeight
  } = await onNode.getTransactionByHash(txHash);
  const height = await awaitHeight(blockHeight + confirm, {
    onNode,
    ...options
  });
  const {
    blockHeight: newBlockHeight
  } = await onNode.getTransactionByHash(txHash);

  switch (newBlockHeight) {
    case -1:
      throw new TxNotInChainError(txHash);

    case blockHeight:
      return height;

    default:
      return waitForTxConfirm(txHash, {
        onNode,
        confirm,
        ...options
      });
  }
}
/**
 * Submit a signed transaction for mining
 * @category chain
 * @param tx - Transaction to submit
 * @param options - Options
 * @param options.onNode - Node to use
 * @param options.onAccount - Account to use
 * @param options.verify - Verify transaction before sending
 * @param options.waitMined - Ensure that transaction get into block
 * @param options.confirm - Number of micro blocks that should be mined after tx get included
 * @returns Transaction details
 */

async function sendTransaction(tx, _ref6) {
  let {
    onNode,
    onAccount,
    verify = true,
    waitMined = true,
    confirm,
    ...options
  } = _ref6;

  if (verify) {
    const validation = await verifyTransaction(tx, onNode);

    if (validation.length > 0) {
      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;
      throw new InvalidTxError(message, validation, tx);
    }
  }

  try {
    let __queue;

    try {
      __queue = onAccount != null ? `tx-${await onAccount.address(options)}` : null;
    } catch (error) {
      __queue = null;
    }

    const {
      txHash
    } = await onNode.postTransaction({
      tx
    }, __queue != null ? {
      requestOptions: {
        customHeaders: {
          __queue
        }
      }
    } : {});

    if (waitMined) {
      const pollResult = await poll(txHash, {
        onNode,
        ...options
      });
      const txData = { ...pollResult,
        hash: pollResult.hash,
        rawTx: tx
      }; // wait for transaction confirmation

      if (confirm != null && (confirm === true || confirm > 0)) {
        const c = typeof confirm === 'boolean' ? undefined : confirm;
        return { ...txData,
          confirmationHeight: await waitForTxConfirm(txHash, {
            onNode,
            confirm: c,
            ...options
          })
        };
      }

      return txData;
    }

    return {
      hash: txHash,
      rawTx: tx
    };
  } catch (error) {
    throw Object.assign(error, {
      rawTx: tx,
      verifyTx: async () => verifyTransaction(tx, onNode)
    });
  }
}

/**
 * Get account by account public key
 * @category chain
 * @param address - Account address (public key)
 * @param options - Options
 * @param options.height - Get account on specific block by block height
 * @param options.hash - Get account on specific block by micro block hash or key block hash
 * @param options.onNode - Node to use
 */
async function getAccount(address, _ref7) {
  let {
    height,
    hash,
    onNode
  } = _ref7;
  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);
  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);
  return onNode.getAccountByPubkey(address);
}
/**
 * Request the balance of specified account
 * @category chain
 * @param address - The public account address to obtain the balance for
 * @param options - Options
 * @param options.format
 * @param options.height - The chain height at which to obtain the balance for
 * (default: top of chain)
 * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)
 */

async function getBalance(address, _ref8) {
  let {
    format = AE_AMOUNT_FORMATS.AETTOS,
    ...options
  } = _ref8;
  const {
    balance
  } = await getAccount(address, options).catch(() => ({
    balance: 0n
  }));
  return formatAmount(balance, {
    targetDenomination: format
  });
}
/**
 * Obtain current generation
 * @category chain
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Current Generation
 */

async function getCurrentGeneration(_ref9) {
  let {
    onNode
  } = _ref9;
  return onNode.getCurrentGeneration();
}
/**
 * Get generation by hash or height
 * @category chain
 * @param hashOrHeight - Generation hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Generation
 */

async function getGeneration(hashOrHeight, _ref10) {
  let {
    onNode
  } = _ref10;
  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);
  return onNode.getGenerationByHash(hashOrHeight);
}
/**
 * Get micro block transactions
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transactions
 */

async function getMicroBlockTransactions(hash, _ref11) {
  let {
    onNode
  } = _ref11;
  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;
}
/**
 * Get key block
 * @category chain
 * @param hashOrHeight - Key block hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Key Block
 */

async function getKeyBlock(hashOrHeight, _ref12) {
  let {
    onNode
  } = _ref12;
  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);
  return onNode.getKeyBlockByHash(hashOrHeight);
}
/**
 * Get micro block header
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Micro block header
 */

async function getMicroBlockHeader(hash, _ref13) {
  let {
    onNode
  } = _ref13;
  return onNode.getMicroBlockHeaderByHash(hash);
}
const txDryRunRequests = new Map();

async function txDryRunHandler(key, onNode) {
  const rs = txDryRunRequests.get(key);
  txDryRunRequests.delete(key);
  if (rs == null) throw new InternalError('Can\'t get dry-run request');
  let dryRunRes;

  try {
    dryRunRes = await onNode.protectedDryRunTxs({
      top: rs[0].top,
      txEvents: rs[0].txEvents,
      txs: rs.map(req => ({
        tx: req.tx
      })),
      accounts: Array.from(new Set(rs.map(req => req.accountAddress))).map(pubKey => ({
        pubKey,
        amount: DRY_RUN_ACCOUNT.amount
      }))
    });
  } catch (error) {
    rs.forEach(_ref14 => {
      let {
        reject
      } = _ref14;
      return reject(error);
    });
    return;
  }

  const {
    results,
    txEvents
  } = dryRunRes;
  results.forEach((_ref15, idx) => {
    let {
      result,
      reason,
      ...resultPayload
    } = _ref15;
    const {
      resolve,
      reject,
      tx,
      accountAddress
    } = rs[idx];
    if (result === 'ok') resolve({ ...resultPayload,
      txEvents
    });else reject(Object.assign(new DryRunError(reason), {
      tx,
      accountAddress
    }));
  });
}
/**
 * Transaction dry-run
 * @category chain
 * @param tx - transaction to execute
 * @param accountAddress - address that will be used to execute transaction
 * @param options - Options
 * @param options.top - hash of block on which to make dry-run
 * @param options.txEvents - collect and return on-chain tx events that would result from the call
 * @param options.combine - Enables combining of similar requests to a single dry-run call
 * @param options.onNode - Node to use
 */


async function txDryRun(tx, accountAddress, _ref16) {
  var _txDryRunRequests$get;

  let {
    top,
    txEvents,
    combine,
    onNode
  } = _ref16;
  const key = combine === true ? [top, txEvents].join() : 'immediate';
  const requests = (_txDryRunRequests$get = txDryRunRequests.get(key)) !== null && _txDryRunRequests$get !== void 0 ? _txDryRunRequests$get : [];
  txDryRunRequests.set(key, requests);
  return new Promise((resolve, reject) => {
    var _requests$timeout;

    requests.push({
      tx,
      accountAddress,
      top,
      txEvents,
      resolve,
      reject
    });

    if (combine !== true) {
      void txDryRunHandler(key, onNode);
      return;
    }

    (_requests$timeout = requests.timeout) !== null && _requests$timeout !== void 0 ? _requests$timeout : requests.timeout = setTimeout(() => {
      void txDryRunHandler(key, onNode);
    });
  });
}
/**
 * Get contract byte code
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */

async function getContractByteCode(contractId, _ref17) {
  let {
    onNode
  } = _ref17;
  return onNode.getContractCode(contractId);
}
/**
 * Get contract entry
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */

async function getContract(contractId, _ref18) {
  let {
    onNode
  } = _ref18;
  return onNode.getContract(contractId);
}
/**
 * Get name entry
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onNode - Node to use
 */

async function getName(name, _ref19) {
  let {
    onNode
  } = _ref19;
  return onNode.getNameEntryByName(name);
}
/**
 * Resolve AENS name and return name hash
 * @category AENS
 * @param nameOrId - AENS name or address
 * @param key - in AENS pointers record
 * @param options - Options
 * @param options.verify - To ensure that name exist and have a corresponding pointer
 * // TODO: avoid that to don't trust to current api gateway
 * @param options.resolveByNode - Enables pointer resolving using node
 * @param options.onNode - Node to use
 * @returns Address or AENS name hash
 */

async function resolveName(nameOrId, key, _ref20) {
  let {
    verify = true,
    resolveByNode = false,
    onNode
  } = _ref20;

  if (isNameValid(nameOrId)) {
    if (verify || resolveByNode) {
      const name = await onNode.getNameEntryByName(nameOrId);
      const pointer = name.pointers.find(p => p.key === key);
      if (pointer == null) throw new AensPointerContextError(nameOrId, key);
      if (resolveByNode) return pointer.id;
    }

    return produceNameId(nameOrId);
  }

  try {
    decode(nameOrId);
    return nameOrId;
  } catch (error) {
    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);
  }
}
// EXTERNAL MODULE: external "@aeternity/uuid"
var uuid_ = __webpack_require__(3983);
// EXTERNAL MODULE: external "@aeternity/argon2-browser/dist/argon2-bundled.min.js"
var argon2_bundled_min_js_ = __webpack_require__(7289);
;// CONCATENATED MODULE: ./src/utils/keystore.ts

 // js extension is required for mjs build
// eslint-disable-next-line import/extensions





const DERIVED_KEY_FUNCTIONS = {
  async argon2id(pass, salt, params) {
    const {
      memlimit_kib: mem,
      opslimit: time
    } = params;
    return (await (0,argon2_bundled_min_js_.hash)({
      hashLen: 32,
      pass,
      salt,
      time,
      mem,
      type: argon2_bundled_min_js_.ArgonType.Argon2id
    })).hash;
  }

};
const CRYPTO_FUNCTIONS = {
  'xsalsa20-poly1305': {
    encrypt: (external_tweetnacl_default()).secretbox,

    decrypt() {
      const res = external_tweetnacl_default().secretbox.open(...arguments);
      if (res == null) throw new InvalidPasswordError();
      return res;
    }

  }
};
const CRYPTO_DEFAULTS = {
  secret_type: 'ed25519',
  symmetric_alg: 'xsalsa20-poly1305',
  kdf: 'argon2id',
  kdf_params: {
    memlimit_kib: 65536,
    opslimit: 3,
    parallelism: 1
  }
};
/**
 * Symmetric private key encryption using secret (derived) key.
 * @param plaintext - Data to be encrypted.
 * @param key - Secret key.
 * @param nonce - Randomly generated nonce.
 * @param algo - Encryption algorithm.
 * @returns Encrypted data.
 */

function encrypt(plaintext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].encrypt(plaintext, nonce, key);
}
/**
 * Symmetric private key decryption using secret (derived) key.
 * @param ciphertext - Data to be decrypted.
 * @param key - Secret key.
 * @param nonce - Nonce from key-object.
 * @param algo - Encryption algorithm.
 * @returns Decrypted data.
 */


function decrypt(ciphertext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].decrypt(ciphertext, nonce, key);
}
/**
 * Derive secret key from password with key derivation function.
 * @param password - User-supplied password.
 * @param nonce - Randomly generated nonce.
 * @param kdf - Key derivation function.
 * @param kdfParams - KDF parameters.
 * @returns Secret key derived from password.
 */


async function deriveKey(password, nonce, kdf, kdfParams) {
  return DERIVED_KEY_FUNCTIONS[kdf](password, nonce, kdfParams);
}
/**
 * Recover plaintext private key from secret-storage key object.
 * @param password - Keystore object password.
 * @param keystore - Keystore object.
 * @returns Plaintext private key.
 */


async function recover(password, _ref) {
  let {
    crypto
  } = _ref;
  const salt = hexToBytes(crypto.kdf_params.salt);
  return bytesToHex(decrypt(hexToBytes(crypto.ciphertext), await deriveKey(password, salt, crypto.kdf, crypto.kdf_params), hexToBytes(crypto.cipher_params.nonce), crypto.symmetric_alg));
}
/**
 * Export private key to keystore secret-storage format.
 * @param name - Key name.
 * @param password - User-supplied password.
 * @param privateKey - Private key as hex-string or a Buffer.
 * @param nonce - Randomly generated 24byte nonce.
 * @param salt - Randomly generated 16byte salt.
 * @param options - Encryption parameters.
 * @param options.kdf - Key derivation function.
 * @param options.kdf_params - KDF parameters.
 */

async function dump(name, password, privateKey) {
  let nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : external_tweetnacl_default().randomBytes(24);
  let salt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : external_tweetnacl_default().randomBytes(16);
  let options = arguments.length > 5 ? arguments[5] : undefined;
  const opt = { ...CRYPTO_DEFAULTS,
    ...options
  };
  const derivedKey = await deriveKey(password, salt, opt.kdf, opt.kdf_params);
  const payload = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
  return {
    name,
    version: 1,
    public_key: getAddressFromPriv(payload),
    id: (0,uuid_.v4)(),
    crypto: {
      secret_type: opt.secret_type,
      symmetric_alg: opt.symmetric_alg,
      ciphertext: bytesToHex(encrypt(payload, derivedKey, nonce, opt.symmetric_alg)),
      cipher_params: {
        nonce: bytesToHex(nonce)
      },
      kdf: opt.kdf,
      kdf_params: { ...opt.kdf_params,
        salt: bytesToHex(salt)
      }
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/index.ts


/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Transaction methods
 *
 * This is implementation of [Tx](api/tx.md) relays
 * the creation of transactions to {@link Node}.
 * These methods provide ability to create native transactions.
 */





async function getVmVersion(txType, _ref) {
  var _abiVersion, _vmVersion;

  let {
    vmVersion,
    abiVersion,
    onNode
  } = _ref;
  const {
    consensusProtocolVersion
  } = await onNode.getNodeInfo();

  if (!isKeyOfObject(consensusProtocolVersion, PROTOCOL_VM_ABI)) {
    throw new UnsupportedProtocolError('Not supported consensus protocol version');
  }

  const supportedProtocol = PROTOCOL_VM_ABI[consensusProtocolVersion];

  if (!isKeyOfObject(txType, supportedProtocol)) {
    throw new UnknownTxError('Not supported tx type');
  }

  const protocolForTX = supportedProtocol[txType];
  (_abiVersion = abiVersion) !== null && _abiVersion !== void 0 ? _abiVersion : abiVersion = protocolForTX.abiVersion[0];
  (_vmVersion = vmVersion) !== null && _vmVersion !== void 0 ? _vmVersion : vmVersion = protocolForTX.vmVersion[0];
  return {
    vmVersion,
    abiVersion
  };
}
/**
 * Calculate fee, get absolute ttl (ttl + height), get account nonce
 * @category transaction builder
 * @param txType - Type of transaction
 * @param params - Object which contains all tx data
 * @returns Object with account nonce, absolute ttl and transaction fee
 */

async function prepareTxParams(txType, _ref2) {
  var _nonce;

  let {
    senderId,
    nonce,
    ttl = TX_TTL,
    absoluteTtl,
    strategy,
    onNode
  } = _ref2;
  (_nonce = nonce) !== null && _nonce !== void 0 ? _nonce : nonce = (await onNode.getAccountNextNonce(senderId, {
    strategy
  }).catch(() => ({
    nextNonce: 1
  }))).nextNonce;

  if (ttl !== 0) {
    if (ttl < 0) throw new ArgumentError('ttl', 'greater or equal to 0', ttl);
    ttl += absoluteTtl === true ? 0 : (await onNode.getCurrentKeyBlock()).height;
  }

  return {
    ttl,
    nonce
  };
}
// TODO: find a better name or rearrange methods

/**
 * @category transaction builder
 */
async function _buildTx(txType, _ref3) {
  var _context;

  let {
    denomination,
    absoluteTtl,
    ..._params
  } = _ref3;
  // TODO: avoid this assertion
  const params = _params;
  let senderKey;

  switch (txType) {
    case Tag.SpendTx:
    case Tag.OracleQueryTx:
      senderKey = 'senderId';
      break;

    case Tag.NameClaimTx:
    case Tag.NameUpdateTx:
    case Tag.NameRevokeTx:
    case Tag.NameTransferTx:
    case Tag.NamePreclaimTx:
    case Tag.OracleRegisterTx:
      senderKey = 'accountId';
      break;

    case Tag.ContractCreateTx:
    case Tag.GaAttachTx:
      senderKey = 'ownerId';
      break;

    case Tag.ContractCallTx:
    case Tag.OracleExtendTx:
    case Tag.OracleResponseTx:
      senderKey = 'callerId';
      break;

    case Tag.ChannelCloseSoloTx:
    case Tag.ChannelSlashTx:
    case Tag.ChannelSettleTx:
    case Tag.ChannelSnapshotSoloTx:
      senderKey = 'fromId';
      break;

    case Tag.PayingForTx:
      senderKey = 'payerId';
      break;

    default:
      throw new ArgumentError('txType', 'valid transaction type', txType);
  } // TODO: move specific cases to field-types


  if (includes_default()(_context = [Tag.ContractCreateTx, Tag.GaAttachTx]).call(_context, txType)) {
    params.ctVersion = await getVmVersion(Tag.ContractCreateTx, { ...params,
      ...params.ctVersion
    });
  }

  if (txType === Tag.ContractCallTx) {
    params.abiVersion = (await getVmVersion(Tag.ContractCallTx, params)).abiVersion;
  }

  if (txType === Tag.OracleRegisterTx) {
    var _params$abiVersion;

    (_params$abiVersion = params.abiVersion) !== null && _params$abiVersion !== void 0 ? _params$abiVersion : params.abiVersion = ABI_VERSIONS.NO_ABI;
  }

  if (txType === Tag.PayingForTx) {
    params.tx = unpackTx(params.tx);
  }

  const senderId = params[senderKey]; // TODO: do this check on TypeScript level

  if (senderId == null) throw new InvalidTxParamsError(`Transaction field ${senderKey} is missed`);
  const extraParams = await prepareTxParams(txType, { ...params,
    senderId,
    absoluteTtl
  });
  return buildTx({ ...params,
    ...extraParams
  }, txType, {
    denomination
  }).tx;
}
// EXTERNAL MODULE: external "tweetnacl-auth"
var external_tweetnacl_auth_ = __webpack_require__(9882);
// EXTERNAL MODULE: external "bip32-path"
var external_bip32_path_ = __webpack_require__(1986);
// EXTERNAL MODULE: external "aes-js"
var external_aes_js_ = __webpack_require__(8236);
var external_aes_js_default = /*#__PURE__*/__webpack_require__.n(external_aes_js_);
;// CONCATENATED MODULE: ./src/utils/hd-wallet.ts









const Ecb = (external_aes_js_default()).ModeOfOperation.ecb; // TODO: at least don't export `encryptKey` and `decryptKey`

/**
 * Encrypt given data using `password`
 * @param password - Password to encrypt with
 * @param binaryData - Data to encrypt
 * @returns Encrypted data
 * @deprecated use 'sha.js' and 'aes-js' packages directly instead
 */

function encryptKey(password, binaryData) {
  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.encrypt(binaryData);
}
/**
 * Decrypt given data using `password`
 * @param password - Password to decrypt with
 * @param encrypted - Data to decrypt
 * @returns Decrypted data
 * @deprecated use 'sha.js' and 'aes-js' packages directly instead
 */

function decryptKey(password, encrypted) {
  const encryptedBytes = Buffer.from(encrypted);
  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.decrypt(encryptedBytes);
}
/**
 * @category exception
 */

class DerivationError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'DerivationError';
  }

}
const ED25519_CURVE = Buffer.from('ed25519 seed');
const HARDENED_OFFSET = 0x80000000;
function deriveChild(_ref, index) {
  let {
    secretKey,
    chainCode
  } = _ref;

  if (index < HARDENED_OFFSET) {
    throw new DerivationError(`Segment ${index} is not hardened`);
  }

  const indexBuffer = Buffer.allocUnsafe(4);
  indexBuffer.writeUInt32BE(index, 0);
  const data = concatBuffers([Buffer.alloc(1, 0), secretKey, indexBuffer]);
  const I = (0,external_tweetnacl_auth_.full)(data, chainCode);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
function derivePathFromKey(path, key) {
  const segments = path === '' ? [] : (0,external_bip32_path_.fromString)(path).toPathArray();
  segments.forEach((segment, i) => {
    if (segment < HARDENED_OFFSET) {
      throw new DerivationError(`Segment #${i + 1} is not hardened`);
    }
  });
  return segments.reduce((parentKey, segment) => deriveChild(parentKey, segment), key);
}
function getMasterKeyFromSeed(seed) {
  const I = (0,external_tweetnacl_auth_.full)(seed, ED25519_CURVE);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
function derivePathFromSeed(path, seed) {
  var _context;

  if (!includes_default()(_context = ['m', 'm/']).call(_context, path.slice(0, 2))) {
    throw new DerivationError('Root element is required');
  }

  const masterKey = getMasterKeyFromSeed(seed);
  return derivePathFromKey(path.slice(2), masterKey);
}

function formatAccount(keys) {
  const {
    secretKey,
    publicKey
  } = keys;
  return {
    secretKey: bytesToHex(secretKey),
    publicKey: encode(publicKey, Encoding.AccountAddress)
  };
}

function getKeyPair(secretKey) {
  return external_tweetnacl_default().sign.keyPair.fromSeed(secretKey);
}
function generateSaveHDWalletFromSeed(seed, password) {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  return {
    secretKey: bytesToHex(encryptKey(password, walletKey.secretKey)),
    chainCode: bytesToHex(encryptKey(password, walletKey.chainCode))
  };
}
function getSaveHDWalletAccounts(saveHDWallet, password, accountCount) {
  const walletKey = {
    secretKey: decryptKey(password, Buffer.from(saveHDWallet.secretKey, 'hex')),
    chainCode: decryptKey(password, Buffer.from(saveHDWallet.chainCode, 'hex'))
  };
  return new Array(accountCount).fill(undefined).map((_, idx) => formatAccount(getKeyPair(derivePathFromKey(`${idx}h/0h/0h`, walletKey).secretKey)));
}
const getHdWalletAccountFromSeed = (seed, accountIdx) => {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  const derived = derivePathFromKey(`${accountIdx}h/0h/0h`, walletKey);
  const keyPair = getKeyPair(derived.secretKey);
  return { ...formatAccount(keyPair),
    idx: accountIdx
  };
};
;// CONCATENATED MODULE: ./src/spend.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */







/**
 * Sign and post a transaction to the chain
 * @category chain
 * @param tx - Transaction
 * @param options - Options
 * @param options.verify - Verify transaction before broadcast, throw error if not
 * valid
 * @returns Transaction
 */
async function send(tx, options) {
  // TODO: detect authFun in AccountGa
  const authFun = options.innerTx === true ? undefined : (await getAccount(await options.onAccount.address(options), options)).authFun;
  const signed = await options.onAccount.signTransaction(tx, { ...options,
    authFun,
    networkId: (await options.onNode.getStatus()).networkId
  });
  return options.innerTx === true ? {
    hash: buildTxHash(signed),
    rawTx: signed
  } : sendTransaction(signed, options);
}

/**
 * Send coins to another account
 * @category chain
 * @param amount - Amount to spend
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
async function spend(amount, recipientIdOrName, options) {
  return send(await _buildTx(Tag.SpendTx, { ...options,
    senderId: await options.onAccount.address(options),
    recipientId: await resolveName(recipientIdOrName, 'account_pubkey', options),
    amount
  }), options);
}
// TODO: Rename to spendFraction

/**
 * Send a fraction of coin balance to another account
 * @category chain
 * @param fraction - Fraction of balance to spend (between 0 and 1)
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
async function transferFunds(fraction, recipientIdOrName, options) {
  if (fraction < 0 || fraction > 1) {
    throw new ArgumentError('fraction', 'a number between 0 and 1', fraction);
  }

  const recipientId = await resolveName(recipientIdOrName, 'account_pubkey', options);
  const senderId = await options.onAccount.address(options);
  const balance = new (external_bignumber_js_default())(await getBalance.bind(options.onAccount)(senderId, options));
  const desiredAmount = balance.times(fraction).integerValue((external_bignumber_js_default()).ROUND_HALF_UP);
  const {
    tx: {
      fee
    }
  } = unpackTx(await _buildTx(Tag.SpendTx, { ...options,
    senderId,
    recipientId,
    amount: desiredAmount
  }), Tag.SpendTx); // Reducing of the amount may reduce transaction fee, so this is not completely accurate

  const amount = desiredAmount.plus(fee).gt(balance) ? balance.minus(fee) : desiredAmount;
  return send(await _buildTx(Tag.SpendTx, { ...options,
    senderId,
    recipientId,
    amount
  }), options);
}

/**
 * Submit transaction of another account paying for it (fee and gas)
 * @category chain
 * @param transaction - tx_<base64>-encoded transaction
 * @param options - Options
 * @returns Object Transaction
 */
async function payForTransaction(transaction, options) {
  return send(await _buildTx(Tag.PayingForTx, { ...options,
    payerId: await options.onAccount.address(options),
    tx: transaction
  }), options);
}
;// CONCATENATED MODULE: ./src/aens.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Aens methods - routines to interact with the æternity naming system
 *
 * The high-level description of the naming system is
 * https://github.com/aeternity/protocol/blob/master/AENS.md in the protocol
 * repository.
 */








/**
 * Revoke a name
 * @category AENS
 * @param name - Name hash
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensRevoke(name, { fee, ttl , nonce })
 * // or
 * await nameObject.revoke({ fee, ttl, nonce })
 * ```
 */
async function aensRevoke(name, options) {
  const nameRevokeTx = await _buildTx(Tag.NameRevokeTx, { ...options,
    nameId: name,
    accountId: await options.onAccount.address(options)
  });
  return send(nameRevokeTx, options);
}

/**
 * Update a name
 * @category AENS
 * @param name - AENS name
 * @param pointers - Map of pointer keys to corresponding addresses
 * @param options - Options
 * @param options.extendPointers - Get the pointers from the node and merge with provided
 * ones. Pointers with the same type will be overwritten
 * @param options.onAccount - Make operation on specific account from sdk (you
 * pass publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @param options.nameTtl - Name ttl represented in number of
 * blocks (Max value is 50000 blocks)
 * @param options.clientTtl=84600 a suggestion as to how long any
 * clients should cache this information
 * @throws Invalid pointer array error
 * @example
 * ```js
 * const name = 'test.chain'
 * const pointersArray = ['ak_asd23dasdas...,' 'ct_asdf34fasdasd...']
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensUpdate(name, pointersArray, { nameTtl, ttl, fee, nonce, clientTtl })
 * // or
 * await nameObject.update(pointers, { nameTtl, ttl, fee, nonce, clientTtl })
 * ```
 */
async function aensUpdate(name, pointers, _ref) {
  let {
    extendPointers,
    ...options
  } = _ref;
  const allPointers = { ...(extendPointers === true && Object.fromEntries((await getName(name, options)).pointers.map(_ref2 => {
      let {
        key,
        id
      } = _ref2;
      return [key, id];
    }))),
    ...pointers
  };
  const nameUpdateTx = await _buildTx(Tag.NameUpdateTx, {
    clientTtl: CLIENT_TTL,
    nameTtl: NAME_TTL,
    ...options,
    nameId: name,
    accountId: await options.onAccount.address(options),
    pointers: Object.entries(allPointers).map(_ref3 => {
      let [key, id] = _ref3;
      return {
        key,
        id: id.toString()
      };
    })
  });
  return send(nameUpdateTx, options);
}

/**
 * Transfer a domain to another account
 * @category AENS
 * @param name - AENS name
 * @param account - Recipient account publick key
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const recipientPub = 'ak_asd23dasdas...'
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensTransfer(name, recipientPub, { ttl, fee, nonce })
 * // or
 * await nameObject.transfer(recipientPub, { ttl, fee, nonce })
 * ```
 */
async function aensTransfer(name, account, options) {
  const nameTransferTx = await _buildTx(Tag.NameTransferTx, { ...options,
    nameId: name,
    accountId: await options.onAccount.address(options),
    recipientId: account
  });
  return send(nameTransferTx, options);
}

/**
 * Query the AENS name info from the node
 * and return the object with info and predefined functions for manipulating name
 * @category AENS
 * @param name - AENS name
 * @param opt - Options
 * @returns
 * @example
 * ```js
 * const nameObject = sdkInstance.aensQuery('test.chain')
 * console.log(nameObject)
 * {
 *  id, // name hash
 *  pointers, // array of pointers
 *  update, // Update name function
 *  extendTtl, // Extend Ttl name function
 *  transfer, // Transfer name function
 *  revoke // Revoke name function
 * }
 * ```
 */
async function aensQuery(name, opt) {
  const nameEntry = await getName(name, opt);
  return Object.freeze({ ...nameEntry,
    id: nameEntry.id,
    owner: nameEntry.owner,

    async update(pointers, options) {
      return { ...(await aensUpdate(name, pointers, { ...opt,
          ...options
        })),
        ...(await aensQuery(name, { ...opt,
          ...options
        }))
      };
    },

    async transfer(account, options) {
      return { ...(await aensTransfer(name, account, { ...opt,
          ...options
        })),
        ...(await aensQuery(name, { ...opt,
          ...options
        }))
      };
    },

    async revoke(options) {
      return aensRevoke(name, { ...opt,
        ...options
      });
    },

    async extendTtl() {
      let nameTtl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NAME_TTL;
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (nameTtl > NAME_TTL || nameTtl <= 0) {
        throw new ArgumentError('nameTtl', `a number between 1 and ${NAME_TTL} blocks`, nameTtl);
      }

      return { ...(await aensUpdate(name, {}, { ...opt,
          ...options,
          nameTtl,
          extendPointers: true
        })),
        ...(await aensQuery(name, { ...opt,
          ...options
        }))
      };
    }

  });
}
/**
 * Claim a previously preclaimed registration. This can only be done after the
 * preclaim step
 * @category AENS
 * @param name - AENS name
 * @param salt - Salt from pre-claim, or 0 if it's a bid
 * @param options - options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @param options.nameFee - Name Fee (By default calculated by sdk)
 * @returns the result of the claim
 * @example
 * ```js
 * const name = 'test.chain'
 * const salt = preclaimResult.salt // salt from pre-claim transaction
 *
 * await sdkInstance.aensClaim(name, salt, { ttl, fee, nonce, nameFee })
 * ```
 */

async function aensClaim(name, salt, options) {
  const claimTx = await _buildTx(Tag.NameClaimTx, { ...options,
    accountId: await options.onAccount.address(options),
    nameSalt: salt,
    name
  });
  const result = await send(claimTx, options);

  if (!isAuctionName(name)) {
    const nameInter = result.blockHeight != null && result.blockHeight > 0 ? await aensQuery(name, options) : {};
    return Object.assign(result, nameInter);
  }

  return result;
}

/**
 * Preclaim a name. Sends a hash of the name and a random salt to the node
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @example
 * ```js
 * const name = 'test.chain'
 * const salt = preclaimResult.salt // salt from pre-claim transaction
 *
 * await sdkInstance.aensPreclaim(name, { ttl, fee, nonce })
 * {
 *   ...transactionResult,
 *   claim, // Claim function (options={}) => claimTransactionResult
 *   salt,
 *   commitmentId
 * }
 * ```
 */
async function aensPreclaim(name, options) {
  const salt = genSalt();
  const height = await getHeight(options);
  const commitmentId = commitmentHash(name, salt);
  const preclaimTx = await _buildTx(Tag.NamePreclaimTx, { ...options,
    accountId: await options.onAccount.address(options),
    commitmentId
  });
  return Object.freeze({ ...(await send(preclaimTx, options)),
    height,
    salt,
    commitmentId,

    async claim(opts) {
      return aensClaim(name, salt, { ...options,
        ...opts
      });
    }

  });
}

/**
 * Bid to name auction
 * @category AENS
 * @param name - Domain name
 * @param nameFee - Name fee (bid fee)
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const bidFee = computeBidFee(name, startFee, incrementPercentage)
 *
 * await sdkInstance.aensBid(name, 213109412839123, { ttl, fee, nonce })
 * ```
 */
async function aensBid(name, nameFee, options) {
  return aensClaim(name, 0, { ...options,
    nameFee
  });
}
// EXTERNAL MODULE: external "@aeternity/aepp-calldata"
var aepp_calldata_ = __webpack_require__(7946);
;// CONCATENATED MODULE: ./src/contract/aci.ts
/*
* ISC License (ISC)
* Copyright (c) 2022 aeternity developers
*
*  Permission to use, copy, modify, and/or distribute this software for any
*  purpose with or without fee is hereby granted, provided that the above
*  copyright notice and this permission notice appear in all copies.
*
*  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
*  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
*  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
*  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
*  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*/











/**
 * Generate contract ACI object with predefined js methods for contract usage - can be used for
 * creating a reference to already deployed contracts
 * @category contract
 * @param options - Options object
 * @returns JS Contract API
 * @example
 * ```js
 * const contractIns = await aeSdk.getContractInstance({ source })
 * await contractIns.deploy([321]) or await contractIns.methods.init(321)
 * const callResult = await contractIns.call('setState', [123]) or
 * await contractIns.methods.setState.send(123, options)
 * const staticCallResult = await contractIns.call('setState', [123], { callStatic: true }) or
 * await contractIns.methods.setState.get(123, options)
 * ```
 * Also you can call contract like: `await contractIns.methods.setState(123, options)`
 * Then sdk decide to make on-chain or static call(dry-run API) transaction based on function is
 * stateful or not
 */
async function getContractInstance(_ref) {
  let {
    onAccount,
    onCompiler,
    onNode,
    source,
    bytecode,
    aci: _aci,
    contractAddress,
    fileSystem = {},
    validateBytecode,
    ...otherOptions
  } = _ref;

  if (_aci == null && source != null) {
    // TODO: should be fixed when the compiledAci interface gets updated
    _aci = await onCompiler.generateACI({
      code: source,
      options: {
        fileSystem
      }
    });
  }

  if (_aci == null) throw new MissingContractDefError();

  if (contractAddress != null) {
    contractAddress = await resolveName(contractAddress, 'contract_pubkey', {
      resolveByNode: true,
      onNode
    });
  }

  if (contractAddress == null && source == null && bytecode == null) {
    throw new MissingContractAddressError('Can\'t create instance by ACI without address');
  }

  if (contractAddress != null) {
    const contract = await getContract(contractAddress, {
      onNode
    });
    if (contract.active == null) throw new InactiveContractError(contractAddress);
  }

  const instance = {
    _aci,
    _name: _aci.encodedAci.contract.name,
    calldata: new aepp_calldata_.Encoder([_aci.encodedAci, ..._aci.externalEncodedAci]),
    source,
    bytecode,
    deployInfo: {
      address: contractAddress
    },
    options: {
      onAccount,
      onCompiler,
      onNode,
      amount: AMOUNT,
      callStatic: false,
      fileSystem,
      ...otherOptions
    },

    /* eslint-disable @typescript-eslint/no-unused-vars */

    /* eslint-disable @typescript-eslint/no-empty-function */
    async compile(_options) {},

    async _estimateGas(_name, _params, _options) {},

    async deploy(_params, _options) {},

    async call(_fn, _params, _options) {},

    decodeEvents(_events, options) {},

    /* eslint-enable @typescript-eslint/no-unused-vars */

    /* eslint-enable @typescript-eslint/no-empty-function */
    methods: undefined
  };

  if (validateBytecode != null) {
    if (contractAddress == null) throw new MissingContractAddressError('Can\'t validate bytecode without contract address');
    const onChanBytecode = (await getContractByteCode(contractAddress, {
      onNode
    })).bytecode;
    const isValid = source != null ? await onCompiler.validateByteCode({
      bytecode: onChanBytecode,
      source,
      options: instance.options
    }).then(() => true, () => false) : bytecode === onChanBytecode;
    if (!isValid) throw new BytecodeMismatchError(source != null ? 'source' : 'bytecode');
  }
  /**
   * Compile contract
   * @returns bytecode
   */


  instance.compile = async function () {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (instance.bytecode != null) throw new IllegalArgumentError('Contract already compiled');
    if (instance.source == null) throw new IllegalArgumentError('Can\'t compile without source code');
    instance.bytecode = (await onCompiler.compileContract({
      code: instance.source,
      options: { ...instance.options,
        ...options
      }
    })).bytecode;
    return instance.bytecode;
  };

  const handleCallError = (_ref2, transaction) => {
    let {
      returnType,
      returnValue
    } = _ref2;
    let message;

    switch (returnType) {
      case 'ok':
        return;

      case 'revert':
        message = instance.calldata.decodeFateString(returnValue);
        break;

      case 'error':
        message = decode(returnValue).toString();
        break;

      default:
        throw new InternalError(`Unknown return type: ${returnType}`);
    }

    throw new NodeInvocationError(message, transaction);
  };

  const sendAndProcess = async (tx, options) => {
    options = { ...instance.options,
      ...options
    };
    const txData = await send(tx, options);
    const result = {
      hash: txData.hash,
      tx: unpackTx(txData.rawTx),
      txData,
      rawTx: txData.rawTx
    };
    if (txData.blockHeight == null) return result;
    const {
      callInfo
    } = await onNode.getTransactionInfoByHash(txData.hash);
    Object.assign(result.txData, callInfo); // TODO: don't duplicate data in result
    // @ts-expect-error TODO api should be updated to match types

    handleCallError(callInfo, tx);
    return { ...result,
      result: callInfo
    };
  };

  instance._estimateGas = async (name, params, options) => {
    const {
      result: {
        gasUsed
      }
    } = await instance.call(name, params, { ...options,
      callStatic: true
    }); // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771

    return Math.floor(gasUsed * 1.25);
  };
  /**
   * Deploy contract
   * @param params - Contract init function arguments array
   * @param options - Options
   * @returns deploy info
   */


  instance.deploy = async function () {
    var _opt$gasLimit;

    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let options = arguments.length > 1 ? arguments[1] : undefined;
    const opt = { ...instance.options,
      ...options
    };
    if (instance.bytecode == null) await instance.compile(opt); // @ts-expect-error TODO: need to fix compatibility between return types of `deploy` and `call`

    if (opt.callStatic === true) return instance.call('init', params, opt);
    if (instance.deployInfo.address != null) throw new DuplicateContractError();
    const ownerId = await opt.onAccount.address(options);
    const tx = await _buildTx(Tag.ContractCreateTx, { ...opt,
      gasLimit: (_opt$gasLimit = opt.gasLimit) !== null && _opt$gasLimit !== void 0 ? _opt$gasLimit : await instance._estimateGas('init', params, opt),
      callData: instance.calldata.encode(instance._name, 'init', params),
      code: instance.bytecode,
      ownerId,
      onNode
    });
    const contractId = buildContractIdByContractTx(tx);
    const {
      hash,
      rawTx,
      result,
      txData
    } = await sendAndProcess(tx, opt);
    instance.deployInfo = Object.freeze({
      result,
      owner: ownerId,
      transaction: hash,
      rawTx,
      txData,
      address: contractId
    });
    return instance.deployInfo;
  };
  /**
   * Get function schema from contract ACI object
   * @param name - Function name
   * @returns function ACI
   */


  function getFunctionACI(name) {
    const fn = instance._aci.encodedAci.contract.functions.find(f => f.name === name);

    if (fn != null) {
      return fn;
    }

    if (name === 'init') return {
      payable: false
    };
    throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);
  }
  /**
   * Call contract function
   * @param fn - Function name
   * @param params - Array of function arguments
   * @param options - Array of function arguments
   * @returns CallResult
   */


  instance.call = async function (fn) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const opt = { ...instance.options,
      ...options
    };
    const fnACI = getFunctionACI(fn);
    const contractId = instance.deployInfo.address;
    if (fn == null) throw new MissingFunctionNameError();
    if (fn === 'init' && opt.callStatic === false) throw new InvalidMethodInvocationError('"init" can be called only via dryRun');
    if (contractId == null && fn !== 'init') throw new InvalidMethodInvocationError('You need to deploy contract before calling!');
    if (fn !== 'init' && opt.amount > 0 && fnACI.payable === false) throw new NotPayableFunctionError(opt.amount, fn);
    const callerId = await Promise.resolve().then(() => opt.onAccount.address(opt)).catch(error => {
      if (opt.callStatic === true) return DRY_RUN_ACCOUNT.pub;
      throw error;
    });
    const callData = instance.calldata.encode(instance._name, fn, params);
    let res;

    if (opt.callStatic === true) {
      if (typeof opt.top === 'number') {
        opt.top = (await getKeyBlock(opt.top, {
          onNode
        })).hash;
      }

      const txOpt = { ...opt,
        onNode,
        callData
      };

      if (opt.nonce == null && opt.top != null) {
        opt.nonce = (await getAccount(callerId, {
          hash: opt.top,
          onNode
        })).nonce + 1;
      }

      const tx = await (fn === 'init' ? _buildTx(Tag.ContractCreateTx, { ...txOpt,
        code: instance.bytecode,
        ownerId: callerId
      }) : _buildTx(Tag.ContractCallTx, { ...txOpt,
        callerId,
        contractId
      }));
      const {
        callObj,
        ...dryRunOther
      } = await txDryRun(tx, callerId, {
        onNode,
        ...opt
      });
      if (callObj == null) throw new UnexpectedTsError();
      handleCallError({
        returnType: callObj.returnType,
        returnValue: callObj.returnValue
      }, tx);
      res = { ...dryRunOther,
        tx: unpackTx(tx),
        result: callObj
      };
    } else {
      var _opt$gasLimit2;

      const tx = await _buildTx(Tag.ContractCallTx, { ...opt,
        onNode,
        gasLimit: (_opt$gasLimit2 = opt.gasLimit) !== null && _opt$gasLimit2 !== void 0 ? _opt$gasLimit2 : await instance._estimateGas(fn, params, opt),
        callerId,
        contractId,
        callData
      });
      res = await sendAndProcess(tx, opt);
    }

    if (opt.callStatic === true || res.txData.blockHeight != null) {
      res.decodedResult = fnACI.returns != null && fnACI.returns !== 'unit' && fn !== 'init' && instance.calldata.decode(instance._name, fn, res.result.returnValue);
      res.decodedEvents = instance.decodeEvents(res.result.log, opt);
    }

    return res;
  };
  /**
   * @param address - Contract address that emitted event
   * @param nameHash - Hash of emitted event name
   * @param options - Options
   * @returns Contract name
   * @throws {@link MissingEventDefinitionError}
   * @throws {@link AmbiguousEventDefinitionError}
   */


  function getContractNameByEvent(address, nameHash, _ref3) {
    let {
      contractAddressToName
    } = _ref3;
    const addressToName = { ...instance.options.contractAddressToName,
      ...contractAddressToName
    };
    if (addressToName[address] != null) return addressToName[address];
    const matchedEvents = [instance._aci.encodedAci, ...instance._aci.externalEncodedAci].filter(_ref4 => {
      let {
        contract
      } = _ref4;
      return contract === null || contract === void 0 ? void 0 : contract.event;
    }).map(_ref5 => {
      let {
        contract
      } = _ref5;
      return [contract.name, contract.event.variant];
    }).map(_ref6 => {
      let [name, events] = _ref6;
      return events.map(event => [name, Object.keys(event)[0]]);
    }).flat().filter(_ref7 => {
      let [, eventName] = _ref7;
      return BigInt(`0x${hash(eventName).toString('hex')}`) === nameHash;
    });

    switch (matchedEvents.length) {
      case 0:
        throw new MissingEventDefinitionError(nameHash.toString(), address);

      case 1:
        return matchedEvents[0][0];

      default:
        throw new AmbiguousEventDefinitionError(address, matchedEvents);
    }
  }
  /**
   * Decode Events
   * @param events - Array of encoded events (callRes.result.log)
   * @param options - Options
   * @returns DecodedEvents
   */


  instance.decodeEvents = function (events) {
    let {
      omitUnknown,
      ...opt
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return events.map(event => {
      const topics = event.topics.map(t => BigInt(t));
      let contractName;

      try {
        contractName = getContractNameByEvent(event.address, topics[0], opt);
      } catch (error) {
        if ((omitUnknown !== null && omitUnknown !== void 0 ? omitUnknown : false) && error instanceof MissingEventDefinitionError) return null;
        throw error;
      }

      const decoded = instance.calldata.decodeEvent(contractName, event.data, topics);
      const [name, args] = Object.entries(decoded)[0];
      return {
        name,
        args,
        contract: {
          name: contractName,
          address: event.address
        }
      };
    }).filter(e => e != null);
  };
  /**
   * Generate proto function based on contract function using Contract ACI schema
   * All function can be called like:
   * ```js
   * await contract.methods.testFunction()
   * ```
   * then sdk will decide to use dry-run or send tx
   * on-chain base on if function stateful or not.
   * Also, you can manually do that:
   * ```js
   * await contract.methods.testFunction.get() // use call-static (dry-run)
   * await contract.methods.testFunction.send() // send tx on-chain
   * ```
   */


  instance.methods = Object.fromEntries(instance._aci.encodedAci.contract.functions.map(_ref8 => {
    let {
      name,
      arguments: aciArgs,
      stateful
    } = _ref8;

    const genHandler = callStatic => async function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      const options = args.length === aciArgs.length + 1 ? args.pop() : {};
      if (typeof options !== 'object') throw new errors_TypeError(`Options should be an object: ${options}`);
      if (name === 'init') return instance.deploy(args, {
        callStatic,
        ...options
      });
      return instance.call(name, args, {
        callStatic,
        ...options
      });
    };

    return [name, Object.assign(genHandler(name === 'init' ? false : !stateful), {
      get: genHandler(true),
      send: genHandler(false)
    })];
  }));
  return instance;
}
;// CONCATENATED MODULE: ./src/contract/methods.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Contract module - routines to interact with the æternity contract
 *
 * High level documentation of the contracts are available at
 * https://github.com/aeternity/protocol/tree/master/contracts and
 */




/**
 * Utility method to create a delegate signature for a contract
 * @category contract
 * @param ids - The list of id's to prepend
 * @param opt - Options
 * @param opt.onNode - Node to use
 * @param opt.onAccount - Account to use
 * @returns Signature in hex representation
 */

async function delegateSignatureCommon(ids, _ref) {
  let {
    onAccount,
    onNode,
    ...opt
  } = _ref;
  const signature = await onAccount.sign(concatBuffers([Buffer.from((await onNode.getStatus()).networkId), ...ids.map(e => decode(e))]), opt);
  return Buffer.from(signature).toString('hex');
}
/**
 * Helper to generate a signature to delegate pre-claim/claim/transfer/revoke of a name to
 * a contract.
 * @category contract
 * @param contractId - Contract Id
 * @param opt - Options
 * @param opt.name - The name
 * @returns Signature for delegation
 * @example
 * ```js
 * const aeSdk = new AeSdk({ ... })
 * const contractId = 'ct_asd2ks...' // contract address
 * const name = 'example.chain' // AENS name
 * const onAccount = await aeSdk.address() // Sign with a specific account
 * // Preclaim signature
 * const preclaimSig = await aeSdk.createAensDelegationSignature(contractId, { onAccount: current })
 * // Claim, transfer and revoke signature
 * const aensDelegationSig = await contract.createAensDelegationSignature(
 *   contractId, { name, onAccount: current }
 * )
 * ```
 */


async function createAensDelegationSignature(contractId, opt) {
  return delegateSignatureCommon([await opt.onAccount.address(opt), ...(opt.name != null ? [produceNameId(opt.name)] : []), contractId], opt);
}
/**
 * Helper to generate a signature to delegate register/extend/respond of a Oracle to a contract.
 * @category contract
 * @param contractId - Contract Id
 * @param opt - Options
 * @param opt.queryId - Oracle Query Id
 * @returns Signature for delegation
 * @example
 * ```js
 * const aeSdk = new AeSdk({ ... })
 * const contractId = 'ct_asd2ks...' // contract address
 * const queryId = 'oq_...' // Oracle Query Id
 * const onAccount = await aeSdk.address() // Sign with a specific account
 * // Oracle register and extend signature
 * const oracleDelegationSig = await aeSdk.createOracleDelegationSignature(contractId)
 * // Oracle respond signature
 * const respondSig = await aeSdk.createOracleDelegationSignature(contractId, { queryId })
 * ```
 */

async function createOracleDelegationSignature(contractId, opt) {
  var _opt$queryId;

  return delegateSignatureCommon([(_opt$queryId = opt.queryId) !== null && _opt$queryId !== void 0 ? _opt$queryId : await opt.onAccount.address(opt), contractId], opt);
}
;// CONCATENATED MODULE: ./src/oracle.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Oracle methods - routines to interact with the æternity oracle system
 *
 * The high-level description of the oracle system is
 * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol
 * repository.
 */











/**
 * Poll for oracle queries
 * @category oracle
 * @param oracleId - Oracle public key
 * @param onQuery - OnQuery callback
 * @param options - Options object
 * @param options.interval - Poll interval(default: 5000)
 * @param options.onNode - Node to use
 * @returns Callback to stop polling function
 */
function pollForQueries(oracleId, onQuery, _ref) {
  var _interval;

  let {
    interval,
    onNode,
    ...options
  } = _ref;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const knownQueryIds = new Set();

  const checkNewQueries = async () => {
    var _await$onNode$getOrac;

    const queries = ((_await$onNode$getOrac = (await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries) !== null && _await$onNode$getOrac !== void 0 ? _await$onNode$getOrac : []).filter(_ref2 => {
      let {
        id
      } = _ref2;
      return !knownQueryIds.has(id);
    });
    queries.forEach(_ref3 => {
      let {
        id
      } = _ref3;
      return knownQueryIds.add(id);
    });
    if (queries.length > 0) onQuery(queries);
  };

  let stopped = false; // eslint-disable-next-line @typescript-eslint/no-floating-promises

  (async () => {
    while (!stopped) {
      // eslint-disable-line no-unmodified-loop-condition
      // TODO: allow to handle this error somehow
      await checkNewQueries().catch(console.error);
      await pause(interval);
    }
  })();

  return () => {
    stopped = true;
  };
}
/**
 * Poll for oracle query response
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options object
 * @param options.interval - Poll interval
 * @param options.onNode - Node to use
 * @returns OracleQuery object
 */

async function pollForQueryResponse(oracleId, queryId, _ref4) {
  var _interval2;

  let {
    interval,
    onNode,
    ...options
  } = _ref4;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('microblock', options);
  let height;
  let ttl;
  let response;

  do {
    if (height != null) await pause(interval);
    ({
      response,
      ttl
    } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));
    const responseBuffer = decode(response);
    if (responseBuffer.length > 0) return responseBuffer.toString();
    height = await this.getHeight();
  } while (ttl >= height);

  throw new RequestTimedOutError(height);
}
/**
 * Constructor for OracleQuery Object (helper object for using OracleQuery)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options
 * @returns OracleQuery object
 */

async function getQueryObject(oracleId, queryId, options) {
  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);
  return { ...record,
    decodedQuery: decode(record.query).toString(),
    decodedResponse: decode(record.response).toString(),
    respond: async (response, opt) => // eslint-disable-next-line @typescript-eslint/no-use-before-define
    respondToQuery(oracleId, queryId, response, { ...options,
      ...opt
    }),
    pollForResponse: async opt => pollForQueryResponse(oracleId, queryId, { ...options,
      ...opt
    })
  };
}

/**
 * Post query to oracle
 * @category oracle
 * @param oracleId - Oracle public key
 * @param query - Oracle query object
 * @param options - Options object
 * @param options.queryTtl - queryTtl Oracle query time to leave
 * @param options.responseTtl - queryFee Oracle query response time to leave
 * @param options.queryFee - queryFee Oracle query fee
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Query object
 */
async function postQueryToOracle(oracleId, query, options) {
  var _options$queryFee;

  (_options$queryFee = options.queryFee) !== null && _options$queryFee !== void 0 ? _options$queryFee : options.queryFee = (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();
  const senderId = await options.onAccount.address(options);
  const oracleQueryTx = await _buildTx(Tag.OracleQueryTx, {
    queryTtlType: QUERY_TTL.type,
    queryTtlValue: QUERY_TTL.value,
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    oracleId,
    senderId,
    query
  });
  const {
    nonce
  } = unpackTx(oracleQueryTx, Tag.OracleQueryTx).tx;
  const queryId = oracleQueryId(senderId, nonce, oracleId);
  return { ...(await send(oracleQueryTx, options)),
    ...(await getQueryObject(oracleId, queryId, options))
  };
}

/**
 * Extend oracle ttl
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options object
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @param options.oracleTtlType - Oracle time to leave for extend
 * @param options.oracleTtlValue - Oracle time to leave for extend
 * @returns Oracle object
 */
async function extendOracleTtl(oracleId, options) {
  const oracleExtendTx = await _buildTx(Tag.OracleExtendTx, {
    oracleTtlType: ORACLE_TTL.type,
    oracleTtlValue: ORACLE_TTL.value,
    ...options,
    callerId: await options.onAccount.address(options),
    oracleId
  });
  return { ...(await send(oracleExtendTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}

/**
 * Extend oracle ttl
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle query id
 * @param response - Oracle query response
 * @param options - Options object
 * @param options.responseTtl - responseTtl Query response time to leave
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
async function respondToQuery(oracleId, queryId, response, options) {
  const oracleRespondTx = await _buildTx(Tag.OracleResponseTx, {
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    callerId: await options.onAccount.address(options),
    oracleId,
    queryId,
    response
  });
  return { ...(await send(oracleRespondTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}

/**
 * Constructor for Oracle Object (helper object for using Oracle)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options
 * @returns Oracle object
 */
async function getOracleObject(oracleId, options) {
  return { ...(await options.onNode.getOracleByPubkey(oracleId)),
    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,
    ...mapObject({
      pollQueries: pollForQueries,
      postQuery: postQueryToOracle,
      respondToQuery,
      extendOracle: extendOracleTtl,
      getQuery: getQueryObject
    }, _ref5 => {
      let [name, handler] = _ref5;
      return [name, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        const lastArg = args[args.length - 1];

        if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
          Object.assign(lastArg, { ...options,
            ...lastArg
          });
        } else args.push(options);

        return handler(oracleId, ...args);
      }];
    })
  };
}

/**
 * Register oracle
 * @category oracle
 * @param queryFormat - Format of query
 * @param responseFormat - Format of query response
 * @param options - Options
 * @param options.queryFee - Oracle query Fee
 * @param options - Options object
 * @param options.abiVersion - Always 0 (do not use virtual machine)
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
async function registerOracle(queryFormat, responseFormat, options) {
  const accountId = await options.onAccount.address(options);
  const oracleRegisterTx = await _buildTx(Tag.OracleRegisterTx, {
    queryFee: QUERY_FEE,
    oracleTtlValue: ORACLE_TTL.value,
    oracleTtlType: ORACLE_TTL.type,
    ...options,
    accountId,
    queryFormat,
    responseFormat
  });
  return { ...(await send(oracleRegisterTx, options)),
    ...(await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options))
  };
}
;// CONCATENATED MODULE: ./src/contract/ga.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Generalized Account module - routines to use generalized account
 */












/**
 * Check if account is GA
 * @category contract
 * @param address - Account address
 * @param options - Options
 * @returns if account is GA
 */
async function isGA(address, options) {
  const {
    contractId
  } = await getAccount(address, options);
  return contractId != null;
}
/**
 * Convert current account to GA
 * @category contract
 * @param authFnName - Authorization function name
 * @param source - Auth contract source code
 * @param args - init arguments
 * @param options - Options
 * @returns General Account Object
 */

async function createGeneralizedAccount(authFnName, source, args, _ref) {
  var _options$gasLimit;

  let {
    onAccount,
    onCompiler,
    onNode,
    ...options
  } = _ref;
  const ownerId = await onAccount.address(options);
  if (await isGA(ownerId, {
    onNode
  })) throw new IllegalArgumentError(`Account ${ownerId} is already GA`);
  const contract = await getContractInstance({
    onAccount,
    onCompiler,
    onNode,
    source
  });
  const tx = await _buildTx(Tag.GaAttachTx, { ...options,
    onNode,
    code: await contract.compile(),
    gasLimit: (_options$gasLimit = options.gasLimit) !== null && _options$gasLimit !== void 0 ? _options$gasLimit : await contract._estimateGas('init', args, options),
    ownerId,
    callData: contract.calldata.encode(contract._name, 'init', args),
    authFun: hash(authFnName)
  });
  const contractId = buildContractIdByContractTx(tx);
  const {
    hash: transaction,
    rawTx
  } = await send(tx, {
    onNode,
    onAccount,
    onCompiler,
    ...options
  });
  return Object.freeze({
    owner: ownerId,
    transaction,
    rawTx,
    gaContractId: contractId
  });
}

/**
 * Create a metaTx transaction
 * @category contract
 * @param rawTransaction - Inner transaction
 * @param authData - Object with gaMeta params
 * @param authFnName - Authorization function name
 * @param options - Options
 * @param options.onAccount - Account to use
 * @returns Transaction string
 */
async function createMetaTx(rawTransaction, authData, authFnName, _ref2) {
  var _authData$gasLimit, _authData$callData;

  let {
    onAccount,
    onCompiler,
    onNode,
    ...options
  } = _ref2;

  const wrapInEmptySignedTx = tx => buildTx({
    encodedTx: tx,
    signatures: []
  }, Tag.SignedTx);

  if (Object.keys(authData).length <= 0) throw new MissingParamError('authData is required');
  const gasLimit = (_authData$gasLimit = authData.gasLimit) !== null && _authData$gasLimit !== void 0 ? _authData$gasLimit : MAX_AUTH_FUN_GAS;

  if (gasLimit > MAX_AUTH_FUN_GAS) {
    throw new InvalidAuthDataError(`the maximum gasLimit value for ga authFun is ${MAX_AUTH_FUN_GAS}, got ${gasLimit}`);
  }

  const authCallData = (_authData$callData = authData.callData) !== null && _authData$callData !== void 0 ? _authData$callData : await (async () => {
    if (authData.source == null || authData.args == null) throw new InvalidAuthDataError('Auth data must contain source code and arguments.');
    const contract = await getContractInstance({
      onCompiler,
      onNode,
      source: authData.source
    });
    return contract.calldata.encode(contract._name, authFnName, authData.args);
  })();
  const {
    abiVersion
  } = await getVmVersion(Tag.ContractCallTx, {
    onNode
  });
  const wrappedTx = wrapInEmptySignedTx(unpackTx(rawTransaction));
  const params = { ...options,
    tx: { ...wrappedTx,
      tx: wrappedTx.txObject
    },
    // TODO: accept an address instead
    gaId: await onAccount.address(options),
    abiVersion,
    authData: authCallData,
    gasLimit,
    vsn: 2
  }; // @ts-expect-error createMetaTx needs to be integrated into tx builder

  const {
    fee
  } = await prepareTxParams(Tag.GaMetaTx, { ...params,
    onNode
  });
  const {
    rlpEncoded: metaTxRlp
  } = buildTx({ ...params,
    fee
  }, Tag.GaMetaTx);
  return wrapInEmptySignedTx(metaTxRlp).tx;
}
/**
 * Build a transaction hash the same as `Auth.tx_hash`
 * @category contract
 * @param transaction - tx-encoded transaction
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */

async function buildAuthTxHash(transaction, _ref3) {
  let {
    onNode
  } = _ref3;
  const {
    networkId
  } = await onNode.getStatus();
  return new Uint8Array(hash(concatBuffers([Buffer.from(networkId), decode(transaction)])));
}
;// CONCATENATED MODULE: ./src/deprecated/methods.ts


/**
 * @deprecated Use createMetaTx instead
 * @hidden
 */
async function signUsingGA(tx, _ref) {
  let {
    authData,
    authFun,
    ...options
  } = _ref;
  return createMetaTx(tx, authData, authFun, options);
}
/**
 * @deprecated Use getHeight instead
 * @hidden
 */

async function height(_ref2) {
  let {
    onNode
  } = _ref2;
  return (await onNode.getCurrentKeyBlockHeight()).height;
}
;// CONCATENATED MODULE: ./src/deprecated/index.ts




/**
 * @deprecated use NamePointer from apis/node instead
 * @hidden
 */

/**
 * @deprecated use genSalt instead
 * @hidden
 */
function salt() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
/**
 * @deprecated use genSalt instead
 * @hidden
 */

const createSalt = salt;
/**
 * Calculate min fee
 * @category transaction builder
 * @param txType - Transaction type
 * @param options - Options object
 * @param options.params - Tx params
 * @deprecated use buildTx to generate transaction, unpack it and refer to `fee` field
 * @hidden
 * @example
 * ```js
 * calculateMinFee('spendTx', { gasLimit, params })
 * ```
 */

function deprecated_calculateMinFee(txType, _ref) {
  let {
    params,
    vsn,
    denomination
  } = _ref;
  return calculateMinFee(txType, fee => // @ts-expect-error anyway this planned to be removed
  buildTx({ ...params,
    _computingMinFee: fee
  }, txType, {
    vsn,
    denomination
  }));
}

/**
 * @deprecated Maximum gas limit depends on transaction size, this value is outdated,
 * sdk check/provides gasLimit by itself while building a transaction
 * @hidden
 */
const GAS_MAX = 1600000 - 21000;
/**
 * @deprecated use `Tag`
 * @hidden
 */

let TX_TYPE;
/**
 * @deprecated use `readId`, `writeId`
 * @hidden
 */

(function (TX_TYPE) {
  TX_TYPE[TX_TYPE["account"] = 10] = "account";
  TX_TYPE[TX_TYPE["signed"] = 11] = "signed";
  TX_TYPE[TX_TYPE["spend"] = 12] = "spend";
  TX_TYPE[TX_TYPE["oracleRegister"] = 22] = "oracleRegister";
  TX_TYPE[TX_TYPE["oracleQuery"] = 23] = "oracleQuery";
  TX_TYPE[TX_TYPE["oracleResponse"] = 24] = "oracleResponse";
  TX_TYPE[TX_TYPE["oracleExtend"] = 25] = "oracleExtend";
  TX_TYPE[TX_TYPE["nameClaim"] = 32] = "nameClaim";
  TX_TYPE[TX_TYPE["namePreClaim"] = 33] = "namePreClaim";
  TX_TYPE[TX_TYPE["nameUpdate"] = 34] = "nameUpdate";
  TX_TYPE[TX_TYPE["nameRevoke"] = 35] = "nameRevoke";
  TX_TYPE[TX_TYPE["nameTransfer"] = 36] = "nameTransfer";
  TX_TYPE[TX_TYPE["contract"] = 40] = "contract";
  TX_TYPE[TX_TYPE["contractCallResult"] = 41] = "contractCallResult";
  TX_TYPE[TX_TYPE["contractCreate"] = 42] = "contractCreate";
  TX_TYPE[TX_TYPE["contractCall"] = 43] = "contractCall";
  TX_TYPE[TX_TYPE["channelCreate"] = 50] = "channelCreate";
  TX_TYPE[TX_TYPE["channelDeposit"] = 51] = "channelDeposit";
  TX_TYPE[TX_TYPE["channelWithdraw"] = 52] = "channelWithdraw";
  TX_TYPE[TX_TYPE["channelCloseMutual"] = 53] = "channelCloseMutual";
  TX_TYPE[TX_TYPE["channelCloseSolo"] = 54] = "channelCloseSolo";
  TX_TYPE[TX_TYPE["channelSlash"] = 55] = "channelSlash";
  TX_TYPE[TX_TYPE["channelSettle"] = 56] = "channelSettle";
  TX_TYPE[TX_TYPE["channelOffChain"] = 57] = "channelOffChain";
  TX_TYPE[TX_TYPE["channel"] = 58] = "channel";
  TX_TYPE[TX_TYPE["channelSnapshotSolo"] = 59] = "channelSnapshotSolo";
  TX_TYPE[TX_TYPE["proofOfInclusion"] = 60] = "proofOfInclusion";
  TX_TYPE[TX_TYPE["stateTrees"] = 62] = "stateTrees";
  TX_TYPE[TX_TYPE["merklePatriciaTree"] = 63] = "merklePatriciaTree";
  TX_TYPE[TX_TYPE["merklePatriciaTreeValue"] = 64] = "merklePatriciaTreeValue";
  TX_TYPE[TX_TYPE["sophiaByteCode"] = 70] = "sophiaByteCode";
  TX_TYPE[TX_TYPE["gaAttach"] = 80] = "gaAttach";
  TX_TYPE[TX_TYPE["gaMeta"] = 81] = "gaMeta";
  TX_TYPE[TX_TYPE["payingFor"] = 82] = "payingFor";
  TX_TYPE[TX_TYPE["channelForceProgress"] = 521] = "channelForceProgress";
  TX_TYPE[TX_TYPE["channelOffChainUpdateTransfer"] = 570] = "channelOffChainUpdateTransfer";
  TX_TYPE[TX_TYPE["channelOffChainUpdateDeposit"] = 571] = "channelOffChainUpdateDeposit";
  TX_TYPE[TX_TYPE["channelOffChainUpdateWithdrawal"] = 572] = "channelOffChainUpdateWithdrawal";
  TX_TYPE[TX_TYPE["channelOffChainCreateContract"] = 573] = "channelOffChainCreateContract";
  TX_TYPE[TX_TYPE["channelOffChainCallContract"] = 574] = "channelOffChainCallContract";
  TX_TYPE[TX_TYPE["channelReconnect"] = 575] = "channelReconnect";
  TX_TYPE[TX_TYPE["contractsTree"] = 621] = "contractsTree";
  TX_TYPE[TX_TYPE["contractCallsTree"] = 622] = "contractCallsTree";
  TX_TYPE[TX_TYPE["channelsTree"] = 623] = "channelsTree";
  TX_TYPE[TX_TYPE["nameserviceTree"] = 624] = "nameserviceTree";
  TX_TYPE[TX_TYPE["oraclesTree"] = 625] = "oraclesTree";
  TX_TYPE[TX_TYPE["accountsTree"] = 626] = "accountsTree";
})(TX_TYPE || (TX_TYPE = {}));

const ID_TAG = {
  account: 1,
  name: 2,
  commitment: 3,
  oracle: 4,
  contract: 5,
  channel: 6
};
/**
 * @deprecated use `readId`, `writeId`
 * @hidden
 */

const PREFIX_ID_TAG = {
  ak: ID_TAG.account,
  nm: ID_TAG.name,
  cm: ID_TAG.commitment,
  ok: ID_TAG.oracle,
  ct: ID_TAG.contract,
  ch: ID_TAG.channel
};
/**
 * @deprecated use `readId`, `writeId`
 * @hidden
 */

const ID_TAG_PREFIX = mapObject(PREFIX_ID_TAG, _ref2 => {
  let [key, value] = _ref2;
  return [value, key];
});
/**
 * @deprecated use `getDefaultPointerKey`
 * @hidden
 */

let POINTER_KEY_BY_PREFIX;

(function (POINTER_KEY_BY_PREFIX) {
  POINTER_KEY_BY_PREFIX["ak"] = "account_pubkey";
  POINTER_KEY_BY_PREFIX["ok"] = "oracle_pubkey";
  POINTER_KEY_BY_PREFIX["ct"] = "contract_pubkey";
  POINTER_KEY_BY_PREFIX["ch"] = "channel";
})(POINTER_KEY_BY_PREFIX || (POINTER_KEY_BY_PREFIX = {}));
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js
var defineProperty = __webpack_require__(1125);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
// EXTERNAL MODULE: external "@azure/core-rest-pipeline"
var core_rest_pipeline_ = __webpack_require__(5039);
;// CONCATENATED MODULE: ./src/utils/semver-satisfies.ts
function semverSatisfies(version, geVersion, ltVersion) {
  const getComponents = v => v.split(/[-+]/)[0].split('.').map(i => +i);

  const versionComponents = getComponents(version);
  const geComponents = getComponents(geVersion);
  const ltComponents = getComponents(ltVersion);
  const base = Math.max(...versionComponents, ...geComponents, ...ltComponents) + 1;

  const componentsToNumber = components => components.reverse().reduce((acc, n, idx) => acc + n * base ** idx, 0);

  const vNumber = componentsToNumber(versionComponents);
  const geNumber = componentsToNumber(geComponents);
  const ltNumber = componentsToNumber(ltComponents);
  return vNumber >= geNumber && vNumber < ltNumber;
}
;// CONCATENATED MODULE: ./src/utils/autorest.ts




const genRequestQueuesPolicy = () => {
  const requestQueues = new Map();
  return {
    policy: {
      name: 'request-queues',

      async sendRequest(request, next) {
        var _requestQueues$get;

        const key = request.headers.get('__queue');
        request.headers.delete('__queue');

        const getResponse = async () => next(request);

        if (key == null) return getResponse();
        const req = ((_requestQueues$get = requestQueues.get(key)) !== null && _requestQueues$get !== void 0 ? _requestQueues$get : Promise.resolve()).then(getResponse, getResponse); // TODO: remove after fixing https://github.com/aeternity/aeternity/issues/3803
        // gap to ensure that node won't reject the nonce

        requestQueues.set(key, req.then(async () => pause(750)));
        return req;
      }

    },
    position: 'perCall'
  };
};
const genCombineGetRequestsPolicy = () => {
  const pendingGetRequests = new Map();
  return {
    policy: {
      name: 'combine-requests',

      async sendRequest(request, next) {
        var _pendingGetRequests$g;

        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_pendingGetRequests$g = pendingGetRequests.get(key)) !== null && _pendingGetRequests$g !== void 0 ? _pendingGetRequests$g : next(request);
        pendingGetRequests.set(key, response);

        try {
          return await response;
        } finally {
          pendingGetRequests.delete(key);
        }
      }

    },
    position: 'perCall'
  };
};
const genErrorFormatterPolicy = getMessage => ({
  policy: {
    name: 'error-formatter',

    async sendRequest(request, next) {
      try {
        return await next(request);
      } catch (error) {
        var _error$response;

        if (!(error instanceof core_rest_pipeline_.RestError) || error.request == null) throw error;
        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;
        let body;

        try {
          body = JSON.parse(error.response.bodyAsText);
        } catch (e) {
          throw error;
        }

        error.message = `${new URL(error.request.url).pathname.slice(1)} error`;
        const message = getMessage(body);
        if (message !== '') error.message += `:${message}`;
        throw error;
      }
    }

  },
  position: 'perCall'
});
const genVersionCheckPolicy = (name, ignorePath, versionPromise, geVersion, ltVersion) => ({
  name: 'version-check',

  async sendRequest(request, next) {
    if (new URL(request.url).pathname === ignorePath) return next(request);
    const args = [await versionPromise, geVersion, ltVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError(name, ...args);
    return next(request);
  }

});
// EXTERNAL MODULE: external "@azure/core-client"
var core_client_ = __webpack_require__(4711);
;// CONCATENATED MODULE: ./src/apis/node/models/mappers.ts
const Header = {
  type: {
    name: "Composite",
    className: "Header",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "String"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "String"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const KeyBlock = {
  type: {
    name: "Composite",
    className: "KeyBlock",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        required: true,
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        required: true,
        type: {
          name: "String"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HashResponse = {
  type: {
    name: "Composite",
    className: "HashResponse",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HeightResponse = {
  type: {
    name: "Composite",
    className: "HeightResponse",
    modelProperties: {
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const MicroBlockHeader = {
  type: {
    name: "Composite",
    className: "MicroBlockHeader",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        required: true,
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SignedTxs = {
  type: {
    name: "Composite",
    className: "SignedTxs",
    modelProperties: {
      transactions: {
        serializedName: "transactions",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SignedTx"
            }
          }
        }
      }
    }
  }
};
const SignedTx = {
  type: {
    name: "Composite",
    className: "SignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Tx = {
  type: {
    name: "Composite",
    className: "Tx",
    uberParent: "Tx",
    polymorphicDiscriminator: {
      serializedName: "type",
      clientName: "type"
    },
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      queryFormat: {
        serializedName: "query_format",
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      accountId: {
        serializedName: "account_id",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      queryId: {
        serializedName: "query_id",
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        type: {
          name: "String"
        }
      },
      commitmentId: {
        serializedName: "commitment_id",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      nameSalt: {
        serializedName: "name_salt",
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        type: {
          name: "String"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "String"
        }
      },
      nameTtl: {
        serializedName: "name_ttl",
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        serializedName: "client_ttl",
        type: {
          name: "String"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        type: {
          name: "String"
        }
      },
      deposit: {
        serializedName: "deposit",
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        type: {
          name: "String"
        }
      },
      callerId: {
        serializedName: "caller_id",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      },
      gaId: {
        serializedName: "ga_id",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      },
      payerId: {
        serializedName: "payer_id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SpendTx", "ChannelCreateTx", "ChannelDepositTx", "ChannelWithdrawTx", "ChannelForceProgressTx", "ChannelCloseMutualTx", "ChannelCloseSoloTx", "ChannelSlashTx", "ChannelSettleTx", "ChannelSnapshotSoloTx", "ChannelSetDelegatesTx", "OracleRegisterTx", "OracleExtendTx", "OracleQueryTx", "OracleRespondTx", "NamePreclaimTx", "NameClaimTx", "NameUpdateTx", "NameTransferTx", "NameRevokeTx", "ContractCreateTx", "ContractCallTx", "GAAttachTx", "GAMetaTx", "PayingForTx"]
        }
      }
    }
  }
};
const Delegates = {
  type: {
    name: "Composite",
    className: "Delegates",
    modelProperties: {
      initiator: {
        serializedName: "initiator",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responder: {
        serializedName: "responder",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const OffChainUpdate = {
  type: {
    name: "Composite",
    className: "OffChainUpdate",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: {
      serializedName: "op",
      clientName: "op"
    },
    modelProperties: {
      op: {
        serializedName: "op",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RelativeTTL = {
  type: {
    name: "Composite",
    className: "RelativeTTL",
    modelProperties: {
      type: {
        defaultValue: "delta",
        isConstant: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Ttl = {
  type: {
    name: "Composite",
    className: "Ttl",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["delta", "block"]
        }
      },
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NamePointer = {
  type: {
    name: "Composite",
    className: "NamePointer",
    modelProperties: {
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CountResponse = {
  type: {
    name: "Composite",
    className: "CountResponse",
    modelProperties: {
      count: {
        serializedName: "count",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Generation = {
  type: {
    name: "Composite",
    className: "Generation",
    modelProperties: {
      keyBlock: {
        serializedName: "key_block",
        type: {
          name: "Composite",
          className: "KeyBlock"
        }
      },
      microBlocks: {
        serializedName: "micro_blocks",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Account = {
  type: {
    name: "Composite",
    className: "Account",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      balance: {
        serializedName: "balance",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      payable: {
        serializedName: "payable",
        type: {
          name: "Boolean"
        }
      },
      kind: {
        serializedName: "kind",
        type: {
          name: "Enum",
          allowedValues: ["basic", "generalized"]
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NextNonceResponse = {
  type: {
    name: "Composite",
    className: "NextNonceResponse",
    modelProperties: {
      nextNonce: {
        serializedName: "next_nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DryRunInput = {
  type: {
    name: "Composite",
    className: "DryRunInput",
    modelProperties: {
      top: {
        serializedName: "top",
        type: {
          name: "String"
        }
      },
      accounts: {
        serializedName: "accounts",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunAccount"
            }
          }
        }
      },
      txs: {
        serializedName: "txs",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunInputItem"
            }
          }
        }
      },
      txEvents: {
        defaultValue: false,
        serializedName: "tx_events",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunAccount = {
  type: {
    name: "Composite",
    className: "DryRunAccount",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DryRunInputItem = {
  type: {
    name: "Composite",
    className: "DryRunInputItem",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      callReq: {
        serializedName: "call_req",
        type: {
          name: "Composite",
          className: "DryRunCallReq"
        }
      }
    }
  }
};
const DryRunCallReq = {
  type: {
    name: "Composite",
    className: "DryRunCallReq",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        type: {
          name: "String"
        }
      },
      caller: {
        serializedName: "caller",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "Composite",
          className: "DryRunCallContext"
        }
      }
    }
  }
};
const DryRunCallContext = {
  type: {
    name: "Composite",
    className: "DryRunCallContext",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      },
      stateful: {
        serializedName: "stateful",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunResults = {
  type: {
    name: "Composite",
    className: "DryRunResults",
    modelProperties: {
      results: {
        serializedName: "results",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunResult"
            }
          }
        }
      },
      txEvents: {
        serializedName: "tx_events",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const DryRunResult = {
  type: {
    name: "Composite",
    className: "DryRunResult",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "String"
        }
      },
      reason: {
        serializedName: "reason",
        type: {
          name: "String"
        }
      },
      callObj: {
        serializedName: "call_obj",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      }
    }
  }
};
const ContractCallObject = {
  type: {
    name: "Composite",
    className: "ContractCallObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      callerNonce: {
        serializedName: "caller_nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      gasUsed: {
        serializedName: "gas_used",
        required: true,
        type: {
          name: "String"
        }
      },
      log: {
        serializedName: "log",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Event"
            }
          }
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error", "revert"]
        }
      }
    }
  }
};
const Event = {
  type: {
    name: "Composite",
    className: "Event",
    modelProperties: {
      address: {
        serializedName: "address",
        required: true,
        type: {
          name: "String"
        }
      },
      topics: {
        serializedName: "topics",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TxInfoObject = {
  type: {
    name: "Composite",
    className: "TxInfoObject",
    modelProperties: {
      callInfo: {
        serializedName: "call_info",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      },
      gaInfo: {
        serializedName: "ga_info",
        type: {
          name: "Composite",
          className: "GAObject"
        }
      },
      txInfo: {
        serializedName: "tx_info",
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAObject = {
  type: {
    name: "Composite",
    className: "GAObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      gasUsed: {
        serializedName: "gas_used",
        required: true,
        type: {
          name: "String"
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error"]
        }
      },
      innerObject: {
        serializedName: "inner_object",
        type: {
          name: "Composite",
          className: "TxInfoObject"
        }
      }
    }
  }
};
const EncodedTx = {
  type: {
    name: "Composite",
    className: "EncodedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PostTxResponse = {
  type: {
    name: "Composite",
    className: "PostTxResponse",
    modelProperties: {
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractObject = {
  type: {
    name: "Composite",
    className: "ContractObject",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      referrerIds: {
        serializedName: "referrer_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ByteCode = {
  type: {
    name: "Composite",
    className: "ByteCode",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PoI = {
  type: {
    name: "Composite",
    className: "PoI",
    modelProperties: {
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RegisteredOracle = {
  type: {
    name: "Composite",
    className: "RegisteredOracle",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleQueries = {
  type: {
    name: "Composite",
    className: "OracleQueries",
    modelProperties: {
      oracleQueries: {
        serializedName: "oracle_queries",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleQuery"
            }
          }
        }
      }
    }
  }
};
const OracleQuery = {
  type: {
    name: "Composite",
    className: "OracleQuery",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderNonce: {
        serializedName: "sender_nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameEntry = {
  type: {
    name: "Composite",
    className: "NameEntry",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      owner: {
        serializedName: "owner",
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      }
    }
  }
};
const Channel = {
  type: {
    name: "Composite",
    className: "Channel",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      channelAmount: {
        serializedName: "channel_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      soloRound: {
        serializedName: "solo_round",
        required: true,
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        required: true,
        type: {
          name: "String"
        }
      },
      lockedUntil: {
        serializedName: "locked_until",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerPubKey = {
  type: {
    name: "Composite",
    className: "PeerPubKey",
    modelProperties: {
      pubkey: {
        serializedName: "pubkey",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Status = {
  type: {
    name: "Composite",
    className: "Status",
    modelProperties: {
      genesisKeyBlockHash: {
        serializedName: "genesis_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      solutions: {
        serializedName: "solutions",
        required: true,
        type: {
          name: "String"
        }
      },
      difficulty: {
        serializedName: "difficulty",
        required: true,
        type: {
          name: "String"
        }
      },
      syncing: {
        serializedName: "syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      syncProgress: {
        constraints: {
          InclusiveMaximum: 100,
          InclusiveMinimum: 0
        },
        serializedName: "sync_progress",
        type: {
          name: "Number"
        }
      },
      listening: {
        serializedName: "listening",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      protocols: {
        serializedName: "protocols",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Protocol"
            }
          }
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      peerCount: {
        serializedName: "peer_count",
        required: true,
        type: {
          name: "String"
        }
      },
      peerConnections: {
        serializedName: "peer_connections",
        type: {
          name: "Composite",
          className: "PeerConnections"
        }
      },
      pendingTransactionsCount: {
        serializedName: "pending_transactions_count",
        required: true,
        type: {
          name: "String"
        }
      },
      networkId: {
        serializedName: "network_id",
        required: true,
        type: {
          name: "String"
        }
      },
      peerPubkey: {
        serializedName: "peer_pubkey",
        required: true,
        type: {
          name: "String"
        }
      },
      topKeyBlockHash: {
        serializedName: "top_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topBlockHeight: {
        serializedName: "top_block_height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Protocol = {
  type: {
    name: "Composite",
    className: "Protocol",
    modelProperties: {
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      effectiveAtHeight: {
        serializedName: "effective_at_height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerConnections = {
  type: {
    name: "Composite",
    className: "PeerConnections",
    modelProperties: {
      inbound: {
        serializedName: "inbound",
        required: true,
        type: {
          name: "String"
        }
      },
      outbound: {
        serializedName: "outbound",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SpendTx = {
  type: {
    name: "Composite",
    className: "SpendTx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleRegisterTx = {
  type: {
    name: "Composite",
    className: "OracleRegisterTx",
    modelProperties: {
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleExtendTx = {
  type: {
    name: "Composite",
    className: "OracleExtendTx",
    modelProperties: {
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleQueryTx = {
  type: {
    name: "Composite",
    className: "OracleQueryTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleRespondTx = {
  type: {
    name: "Composite",
    className: "OracleRespondTx",
    modelProperties: {
      queryId: {
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NamePreclaimTx = {
  type: {
    name: "Composite",
    className: "NamePreclaimTx",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameClaimTx = {
  type: {
    name: "Composite",
    className: "NameClaimTx",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameSalt: {
        serializedName: "name_salt",
        required: true,
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameUpdateTx = {
  type: {
    name: "Composite",
    className: "NameUpdateTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nameTtl: {
        serializedName: "name_ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        serializedName: "client_ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameTransferTx = {
  type: {
    name: "Composite",
    className: "NameTransferTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameRevokeTx = {
  type: {
    name: "Composite",
    className: "NameRevokeTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const CommitmentId = {
  type: {
    name: "Composite",
    className: "CommitmentId",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameHash = {
  type: {
    name: "Composite",
    className: "NameHash",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCreateTx = {
  type: {
    name: "Composite",
    className: "ChannelCreateTx",
    modelProperties: {
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        required: true,
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      }
    }
  }
};
const ChannelDepositTx = {
  type: {
    name: "Composite",
    className: "ChannelDepositTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelWithdrawTx = {
  type: {
    name: "Composite",
    className: "ChannelWithdrawTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelForceProgressTx = {
  type: {
    name: "Composite",
    className: "ChannelForceProgressTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCloseMutualTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseMutualTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCloseSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSlashTx = {
  type: {
    name: "Composite",
    className: "ChannelSlashTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSettleTx = {
  type: {
    name: "Composite",
    className: "ChannelSettleTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSnapshotSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelSnapshotSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSetDelegatesTx = {
  type: {
    name: "Composite",
    className: "ChannelSetDelegatesTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const PubKey = {
  type: {
    name: "Composite",
    className: "PubKey",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerDetails = {
  type: {
    name: "Composite",
    className: "PeerDetails",
    modelProperties: {
      host: {
        serializedName: "host",
        required: true,
        type: {
          name: "String"
        }
      },
      port: {
        serializedName: "port",
        required: true,
        type: {
          name: "String"
        }
      },
      firstSeen: {
        serializedName: "first_seen",
        required: true,
        type: {
          name: "String"
        }
      },
      lastSeen: {
        serializedName: "last_seen",
        required: true,
        type: {
          name: "String"
        }
      },
      genesisHash: {
        serializedName: "genesis_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topHash: {
        serializedName: "top_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topDifficulty: {
        serializedName: "top_difficulty",
        required: true,
        type: {
          name: "String"
        }
      },
      networkId: {
        serializedName: "network_id",
        type: {
          name: "String"
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        type: {
          name: "String"
        }
      },
      nodeVendor: {
        serializedName: "node_vendor",
        type: {
          name: "String"
        }
      },
      nodeOs: {
        serializedName: "node_os",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Peers = {
  type: {
    name: "Composite",
    className: "Peers",
    modelProperties: {
      peers: {
        serializedName: "peers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      blocked: {
        serializedName: "blocked",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const PeerCount = {
  type: {
    name: "Composite",
    className: "PeerCount",
    modelProperties: {
      connected: {
        serializedName: "connected",
        type: {
          name: "Composite",
          className: "PeerCountConnected"
        }
      },
      available: {
        serializedName: "available",
        type: {
          name: "Composite",
          className: "PeerCountAvailable"
        }
      },
      blocked: {
        serializedName: "blocked",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerCountConnected = {
  type: {
    name: "Composite",
    className: "PeerCountConnected",
    modelProperties: {
      inbound: {
        serializedName: "inbound",
        type: {
          name: "String"
        }
      },
      outbound: {
        serializedName: "outbound",
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerCountAvailable = {
  type: {
    name: "Composite",
    className: "PeerCountAvailable",
    modelProperties: {
      verified: {
        serializedName: "verified",
        type: {
          name: "String"
        }
      },
      unverified: {
        serializedName: "unverified",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCreateTx = {
  type: {
    name: "Composite",
    className: "ContractCreateTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCallTx = {
  type: {
    name: "Composite",
    className: "ContractCallTx",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const UnsignedTx = {
  type: {
    name: "Composite",
    className: "UnsignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TokenSupply = {
  type: {
    name: "Composite",
    className: "TokenSupply",
    modelProperties: {
      accounts: {
        serializedName: "accounts",
        type: {
          name: "String"
        }
      },
      contracts: {
        serializedName: "contracts",
        type: {
          name: "String"
        }
      },
      contractOracles: {
        serializedName: "contract_oracles",
        type: {
          name: "String"
        }
      },
      locked: {
        serializedName: "locked",
        type: {
          name: "String"
        }
      },
      oracles: {
        serializedName: "oracles",
        type: {
          name: "String"
        }
      },
      oracleQueries: {
        serializedName: "oracle_queries",
        type: {
          name: "String"
        }
      },
      pendingRewards: {
        serializedName: "pending_rewards",
        type: {
          name: "String"
        }
      },
      total: {
        serializedName: "total",
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAAttachTx = {
  type: {
    name: "Composite",
    className: "GAAttachTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAMetaTx = {
  type: {
    name: "Composite",
    className: "GAMetaTx",
    modelProperties: {
      gaId: {
        serializedName: "ga_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const PayingForTx = {
  type: {
    name: "Composite",
    className: "PayingForTx",
    modelProperties: {
      payerId: {
        serializedName: "payer_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const CheckTxInPoolResponse = {
  type: {
    name: "Composite",
    className: "CheckTxInPoolResponse",
    modelProperties: {
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainTransfer = {
  serializedName: "OffChainTransfer",
  type: {
    name: "Composite",
    className: "OffChainTransfer",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: { ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainWithdrawal = {
  serializedName: "OffChainWithdrawal",
  type: {
    name: "Composite",
    className: "OffChainWithdrawal",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: { ...OffChainUpdate.type.modelProperties,
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainDeposit = {
  serializedName: "OffChainDeposit",
  type: {
    name: "Composite",
    className: "OffChainDeposit",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: { ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainNewContract = {
  serializedName: "OffChainNewContract",
  type: {
    name: "Composite",
    className: "OffChainNewContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: { ...OffChainUpdate.type.modelProperties,
      owner: {
        serializedName: "owner",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "Composite",
          className: "ByteCode"
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainCallContract = {
  serializedName: "OffChainCallContract",
  type: {
    name: "Composite",
    className: "OffChainCallContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: { ...OffChainUpdate.type.modelProperties,
      caller: {
        serializedName: "caller",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CreateContractUnsignedTx = {
  type: {
    name: "Composite",
    className: "CreateContractUnsignedTx",
    modelProperties: { ...UnsignedTx.type.modelProperties,
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
let discriminators = {
  "Tx.undefined": Tx,
  OffChainUpdate: OffChainUpdate,
  "OffChainUpdate.OffChainTransfer": OffChainTransfer,
  "OffChainUpdate.OffChainWithdrawal": OffChainWithdrawal,
  "OffChainUpdate.OffChainDeposit": OffChainDeposit,
  "OffChainUpdate.OffChainNewContract": OffChainNewContract,
  "OffChainUpdate.OffChainCallContract": OffChainCallContract
};
;// CONCATENATED MODULE: ./src/apis/node/models/parameters.ts

const accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const $host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const intAsString = {
  parameterPath: "intAsString",
  mapper: {
    defaultValue: false,
    serializedName: "int-as-string",
    type: {
      name: "Boolean"
    }
  }
};
const parameters_hash = {
  parameterPath: "hash",
  mapper: {
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const parameters_height = {
  parameterPath: "height",
  mapper: {
    constraints: {
      InclusiveMaximum: 18446744073709552000,
      InclusiveMinimum: 0
    },
    serializedName: "height",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const index = {
  parameterPath: "index",
  mapper: {
    constraints: {
      InclusiveMinimum: 1
    },
    serializedName: "index",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const pubkey = {
  parameterPath: "pubkey",
  mapper: {
    serializedName: "pubkey",
    required: true,
    type: {
      name: "String"
    }
  }
};
const strategy = {
  parameterPath: ["options", "strategy"],
  mapper: {
    defaultValue: "max",
    serializedName: "strategy",
    type: {
      name: "Enum",
      allowedValues: ["max", "continuity"]
    }
  }
};
const contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const body = {
  parameterPath: "body",
  mapper: DryRunInput
};
const body1 = {
  parameterPath: "body",
  mapper: EncodedTx
};
const fromParam = {
  parameterPath: ["options", "from"],
  mapper: {
    serializedName: "from",
    type: {
      name: "String"
    }
  }
};
const limit = {
  parameterPath: ["options", "limit"],
  mapper: {
    defaultValue: 20,
    constraints: {
      InclusiveMaximum: 1000,
      InclusiveMinimum: 1
    },
    serializedName: "limit",
    type: {
      name: "Number"
    }
  }
};
const typeParam = {
  parameterPath: ["options", "type"],
  mapper: {
    defaultValue: "all",
    serializedName: "type",
    type: {
      name: "Enum",
      allowedValues: ["open", "closed", "all"]
    }
  }
};
const queryId = {
  parameterPath: "queryId",
  mapper: {
    serializedName: "query-id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const parameters_name = {
  parameterPath: "name",
  mapper: {
    serializedName: "name",
    required: true,
    type: {
      name: "String"
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/node/node.ts




class Node extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Node class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint, _options;

    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    } // Initializing default values for options


    if (!options) {
      options = {};
    }

    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-node/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = { ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      baseUri: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);

    if ((_options = options) !== null && _options !== void 0 && _options.pipeline && options.pipeline.getOrderedPolicies().length > 0) {
      const pipelinePolicies = options.pipeline.getOrderedPolicies();
      const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some(pipelinePolicy => pipelinePolicy.name === core_rest_pipeline_.bearerTokenAuthenticationPolicyName);

      if (!bearerTokenAuthenticationPolicyFound) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_.bearerTokenAuthenticationPolicyName
        });
        this.pipeline.addPolicy(core_rest_pipeline_.bearerTokenAuthenticationPolicy({
          scopes: `${optionsWithDefaults.baseUri}/.default`,
          challengeCallbacks: {
            authorizeRequestOnChallenge: core_client_.authorizeRequestOnClaimChallenge
          }
        }));
      }
    } // Parameter assignments


    this.$host = $host;
  }
  /**
   * Get the top header (either key or micro block)
   * @param options The options parameters.
   */


  getTopHeader(options) {
    return this.sendOperationRequest({
      options
    }, getTopHeaderOperationSpec);
  }
  /**
   * Get the current key block
   * @param options The options parameters.
   */


  getCurrentKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockOperationSpec);
  }
  /**
   * Get the hash of the current key block
   * @param options The options parameters.
   */


  getCurrentKeyBlockHash(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHashOperationSpec);
  }
  /**
   * Get the height of the current key block
   * @param options The options parameters.
   */


  getCurrentKeyBlockHeight(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHeightOperationSpec);
  }
  /**
   * Get the pending key block
   * @param options The options parameters.
   */


  getPendingKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getPendingKeyBlockOperationSpec);
  }
  /**
   * Get a key block by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */


  getKeyBlockByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getKeyBlockByHashOperationSpec);
  }
  /**
   * Get a key block by height
   * @param height The height
   * @param options The options parameters.
   */


  getKeyBlockByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getKeyBlockByHeightOperationSpec);
  }
  /**
   * Get a micro block header by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */


  getMicroBlockHeaderByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockHeaderByHashOperationSpec);
  }
  /**
   * Get micro block transactions by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */


  getMicroBlockTransactionsByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsByHashOperationSpec);
  }
  /**
   * Get a micro block transaction by hash and index
   * @param hash The hash of the micro block
   * @param index The index of the transaction in a block
   * @param options The options parameters.
   */


  getMicroBlockTransactionByHashAndIndex(hash, index, options) {
    return this.sendOperationRequest({
      hash,
      index,
      options
    }, getMicroBlockTransactionByHashAndIndexOperationSpec);
  }
  /**
   * Get micro block transaction count by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */


  getMicroBlockTransactionsCountByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsCountByHashOperationSpec);
  }
  /**
   * Get the current generation
   * @param options The options parameters.
   */


  getCurrentGeneration(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentGenerationOperationSpec);
  }
  /**
   * Get a generation by hash
   * @param hash The hash of the key block
   * @param options The options parameters.
   */


  getGenerationByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getGenerationByHashOperationSpec);
  }
  /**
   * Get a generation by height
   * @param height The height
   * @param options The options parameters.
   */


  getGenerationByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getGenerationByHeightOperationSpec);
  }
  /**
   * Get an account by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */


  getAccountByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountByPubkeyOperationSpec);
  }
  /**
   * Get an account by public key after the opening key block of the generation at height
   * @param pubkey The public key of the account
   * @param height The height
   * @param options The options parameters.
   */


  getAccountByPubkeyAndHeight(pubkey, height, options) {
    return this.sendOperationRequest({
      pubkey,
      height,
      options
    }, getAccountByPubkeyAndHeightOperationSpec);
  }
  /**
   * Get an account by public key after the block indicated by hash. Can be either a micro block or a
   * keyblock hash
   * @param pubkey The public key of the account
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */


  getAccountByPubkeyAndHash(pubkey, hash, options) {
    return this.sendOperationRequest({
      pubkey,
      hash,
      options
    }, getAccountByPubkeyAndHashOperationSpec);
  }
  /**
   * Get pending account transactions by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */


  getPendingAccountTransactionsByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getPendingAccountTransactionsByPubkeyOperationSpec);
  }
  /**
   * Get an account's next nonce; This is computed according to whatever is the current account nonce and
   * what transactions are currently present in the transaction pool
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */


  getAccountNextNonce(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountNextNonceOperationSpec);
  }
  /**
   * Dry-run transactions on top of a given block. Supports all TXs except GAMetaTx, PayingForTx and
   * OffchainTx. The maximum gas limit of all calls is capped. The maximum gas limit per request is a
   * global node setting. Since DryRunCallReq object do not have a mandatory gas field, if not set a
   * default value of 1000000 is being used instead.
   * @param body transactions
   * @param options The options parameters.
   */


  protectedDryRunTxs(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, protectedDryRunTxsOperationSpec);
  }
  /**
   * Get a transaction by hash
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */


  getTransactionByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionByHashOperationSpec);
  }
  /**
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */


  getTransactionInfoByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionInfoByHashOperationSpec);
  }
  /**
   * Post a new transaction
   * @param body The new transaction
   * @param options The options parameters.
   */


  postTransaction(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, postTransactionOperationSpec);
  }
  /**
   * Get a contract by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */


  getContract(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractOperationSpec);
  }
  /**
   * Get contract code by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */


  getContractCode(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractCodeOperationSpec);
  }
  /**
   * Get a proof of inclusion for a contract
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */


  getContractPoI(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractPoIOperationSpec);
  }
  /**
   * Get an oracle by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */


  getOracleByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleByPubkeyOperationSpec);
  }
  /**
   * Get oracle queries by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */


  getOracleQueriesByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleQueriesByPubkeyOperationSpec);
  }
  /**
   * Get an oracle query by public key and query ID
   * @param pubkey The public key of the oracle
   * @param queryId The ID of the query
   * @param options The options parameters.
   */


  getOracleQueryByPubkeyAndQueryId(pubkey, queryId, options) {
    return this.sendOperationRequest({
      pubkey,
      queryId,
      options
    }, getOracleQueryByPubkeyAndQueryIdOperationSpec);
  }
  /**
   * Get name entry from naming system
   * @param name The name key of the name entry
   * @param options The options parameters.
   */


  getNameEntryByName(name, options) {
    return this.sendOperationRequest({
      name,
      options
    }, getNameEntryByNameOperationSpec);
  }
  /**
   * Get channel by public key
   * @param pubkey The pubkey of the channel
   * @param options The options parameters.
   */


  getChannelByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getChannelByPubkeyOperationSpec);
  }
  /**
   * Get peer public key
   * @param options The options parameters.
   */


  getPeerPubkey(options) {
    return this.sendOperationRequest({
      options
    }, getPeerPubkeyOperationSpec);
  }
  /**
   * Get the status of a node
   * @param options The options parameters.
   */


  getStatus(options) {
    return this.sendOperationRequest({
      options
    }, getStatusOperationSpec);
  }
  /**
   * Get oldest keyblock hashes counting from genesis including orphans
   * @param options The options parameters.
   */


  getChainEnds(options) {
    return this.sendOperationRequest({
      options
    }, getChainEndsOperationSpec);
  }

} // Operation Specifications

const serializer = core_client_.createSerializer(mappers_namespaceObject,
/* isXml */
false);
const getTopHeaderOperationSpec = {
  path: "/v3/headers/top",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Header
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockOperationSpec = {
  path: "/v3/key-blocks/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHashOperationSpec = {
  path: "/v3/key-blocks/current/hash",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HashResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHeightOperationSpec = {
  path: "/v3/key-blocks/current/height",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HeightResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getPendingKeyBlockOperationSpec = {
  path: "/v3/key-blocks/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHashOperationSpec = {
  path: "/v3/key-blocks/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHeightOperationSpec = {
  path: "/v3/key-blocks/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_height],
  headerParameters: [accept],
  serializer
};
const getMicroBlockHeaderByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/header",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: MicroBlockHeader
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionByHashAndIndexOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/index/{index}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash, index],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsCountByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CountResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getCurrentGenerationOperationSpec = {
  path: "/v3/generations/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getGenerationByHashOperationSpec = {
  path: "/v3/generations/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getGenerationByHeightOperationSpec = {
  path: "/v3/generations/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_height],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHeightOperationSpec = {
  path: "/v3/accounts/{pubkey}/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_height, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHashOperationSpec = {
  path: "/v3/accounts/{pubkey}/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash, pubkey],
  headerParameters: [accept],
  serializer
};
const getPendingAccountTransactionsByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}/transactions/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountNextNonceOperationSpec = {
  path: "/v3/accounts/{pubkey}/next-nonce",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NextNonceResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString, strategy],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const protectedDryRunTxsOperationSpec = {
  path: "/v3/dry-run",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DryRunResults
    },
    403: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body,
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getTransactionByHashOperationSpec = {
  path: "/v3/transactions/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getTransactionInfoByHashOperationSpec = {
  path: "/v3/transactions/{hash}/info",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: TxInfoObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const postTransactionOperationSpec = {
  path: "/v3/transactions",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: PostTxResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body1,
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getContractOperationSpec = {
  path: "/v3/contracts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ContractObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractCodeOperationSpec = {
  path: "/v3/contracts/{pubkey}/code",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ByteCode
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractPoIOperationSpec = {
  path: "/v3/contracts/{pubkey}/poi",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PoI
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: RegisteredOracle
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueriesByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQueries
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString, fromParam, limit, typeParam],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueryByPubkeyAndQueryIdOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries/{query-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQuery
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey, queryId],
  headerParameters: [accept],
  serializer
};
const getNameEntryByNameOperationSpec = {
  path: "/v3/names/{name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameEntry
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_name],
  headerParameters: [accept],
  serializer
};
const getChannelByPubkeyOperationSpec = {
  path: "/v3/channels/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Channel
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getPeerPubkeyOperationSpec = {
  path: "/v3/peers/pubkey",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PeerPubKey
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getStatusOperationSpec = {
  path: "/v3/status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Status
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getChainEndsOperationSpec = {
  path: "/v3/status/chain-ends",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
;// CONCATENATED MODULE: ./src/Node.ts
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

// eslint-disable-next-line max-classes-per-file





/**
 * Obtain networkId from account or node
 */

async function getNetworkId() {
  var _ref, _await$this$api$getSt, _this$api;

  let {
    networkId
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const res = (_ref = networkId !== null && networkId !== void 0 ? networkId : this.networkId) !== null && _ref !== void 0 ? _ref : (_await$this$api$getSt = await ((_this$api = this.api) === null || _this$api === void 0 ? void 0 : _this$api.getStatus())) === null || _await$this$api$getSt === void 0 ? void 0 : _await$this$api$getSt.networkId;
  if (res != null) return res;
  throw new MissingParamError('networkId is not provided');
}
const bigIntPropertyNames = ['balance', 'queryFee', 'fee', 'amount', 'nameFee', 'channelAmount', 'initiatorAmount', 'responderAmount', 'channelReserve', 'initiatorAmountFinal', 'responderAmountFinal', 'gasPrice', 'deposit'];
const numberPropertyNames = ['time', 'gas', 'gasUsed', 'nameSalt', 'nonce', 'nextNonce', 'height', 'blockHeight', 'top', 'topBlockHeight', 'ttl', 'nameTtl', 'clientTtl', 'inbound', 'outbound', 'peerCount', 'pendingTransactionsCount', 'effectiveAtHeight', 'version', 'solutions', 'round'];

var _mapData = /*#__PURE__*/new WeakSet();

var _encodeArg = /*#__PURE__*/new WeakSet();

var _decodeRes = /*#__PURE__*/new WeakSet();

class NodeTransformed extends Node {
  constructor() {
    super(...arguments);

    _classPrivateMethodInitSpec(this, _decodeRes);

    _classPrivateMethodInitSpec(this, _encodeArg);

    _classPrivateMethodInitSpec(this, _mapData);
  }

  async sendOperationRequest(operationArguments, operationSpec) {
    const args = mapObject(operationArguments, _ref2 => {
      let [key, value] = _ref2;
      return [key, _classPrivateMethodGet(this, _encodeArg, _encodeArg2).call(this, value)];
    });
    return _classPrivateMethodGet(this, _decodeRes, _decodeRes2).call(this, await super.sendOperationRequest(args, operationSpec));
  }

}

function _mapData2(data, transform) {
  if (Array.isArray(data)) return data.map(d => _classPrivateMethodGet(this, _mapData, _mapData2).call(this, d, transform));

  if (data != null && typeof data === 'object') {
    return mapObject(data, _ref5 => {
      let [key, value] = _ref5;
      if (value == null) return [key, value];
      if (bigIntPropertyNames.some(k => k === key)) return [key, transform.bigInt(value)];
      if (numberPropertyNames.some(k => k === key)) return [key, transform.number(value)];
      return [key, _classPrivateMethodGet(this, _mapData, _mapData2).call(this, value, transform)];
    });
  }

  return data;
}

function _encodeArg2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => {
      if (value instanceof (external_bignumber_js_default())) return value.toFixed();
      return value.toString();
    },
    number: value => value.toString()
  });
}

function _decodeRes2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => BigInt(value),
    number: value => +value
  });
}

class Node_Node extends NodeTransformed {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Don't check node version
   */
  constructor(url) {
    let {
      ignoreVersion = false,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genErrorFormatterPolicy(body => ` ${body.reason}`)],
      ...options
    });
    this.url = url;

    if (!ignoreVersion) {
      const versionPromise = this.getStatus().then(_ref3 => {
        let {
          nodeVersion
        } = _ref3;
        return nodeVersion;
      });
      this.pipeline.addPolicy(genVersionCheckPolicy('node', '/v3/status', versionPromise, '6.2.0', '7.0.0'));
    }

    this.intAsString = true;
  }

  async getNodeInfo() {
    const {
      nodeVersion: version,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(_ref4 => {
      let {
        effectiveAtHeight
      } = _ref4;
      return topBlockHeight >= effectiveAtHeight;
    }).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    return {
      url: this.url,
      nodeNetworkId,
      version,
      consensusProtocolVersion
    };
  }

}
;// CONCATENATED MODULE: ./src/account/Base.ts


/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */







/**
 * Check is provided object looks like an instance of AccountBase
 * @param acc - Object to check
 */
const isAccountBase = acc => !['sign', 'address', 'signTransaction', 'signMessage'].some(f => typeof acc[f] !== 'function');
/**
 * Account is one of the three basic building blocks of an
 * {@link AeSdk} and provides access to a signing key pair.
 */

class AccountBase {
  /**
   * @param options - Options
   * @param options.networkId - Using for signing transactions
   */
  constructor() {
    var _this$networkId;

    let {
      networkId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    defineProperty_default()(this, "getNetworkId", getNetworkId);

    (_this$networkId = this.networkId) !== null && _this$networkId !== void 0 ? _this$networkId : this.networkId = networkId;
  }
  /**
   * Sign encoded transaction
   * @param tx - Transaction to sign
   * @param opt - Options
   * @param opt.innerTx - Sign as inner transaction for PayingFor
   * @returns Signed transaction
   */


  async signTransaction(tx) {
    let {
      innerTx,
      networkId,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const prefixes = [await this.getNetworkId({
      networkId
    })];
    if (innerTx === true) prefixes.push('inner_tx');
    const rlpBinaryTx = decode(tx);
    const txWithNetworkId = concatBuffers([Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
    const signatures = [await this.sign(txWithNetworkId, options)];
    return buildTx({
      encodedTx: rlpBinaryTx,
      signatures
    }, Tag.SignedTx).tx;
  }
  /**
   * Get network Id
   * @returns Network Id
   */


  /**
   * Sign message
   * @param message - Message to sign
   * @param opt - Options
   * @returns Signature as hex string of Uint8Array
   */
  async signMessage(message) {
    let {
      returnHex = false,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const sig = await this.sign(messageToHash(message), options);
    return returnHex ? Buffer.from(sig).toString('hex') : sig;
  }
  /**
   * Verify message
   * @param message - Message to verify
   * @param signature - Signature
   * @param options - Options
   */


  async verifyMessage(message, signature, options) {
    return verifyMessage(message, typeof signature === 'string' ? Buffer.from(signature, 'hex') : signature, decode(await this.address(options)));
  }
  /**
   * Sign data blob
   * @param data - Data blob to sign
   * @param options - Options
   * @returns Signed data blob
   */


}
;// CONCATENATED MODULE: ./src/account/Memory.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */






const secrets = new WeakMap();

/**
 * In-memory account class
 */
class AccountMemory extends AccountBase {
  /**
   * @param options - Options
   * @param options.keypair - Key pair to use
   * @param options.keypair.publicKey - Public key
   * @param options.keypair.secretKey - Private key
   * @param options.gaId - Address of generalized account
   */
  constructor(_ref) {
    let {
      keypair,
      gaId,
      ...options
    } = _ref;
    super(options);
    this.isGa = gaId != null;

    if (this.isGa && gaId != null) {
      decode(gaId);
      secrets.set(this, {
        publicKey: gaId
      });
      return;
    }

    if (keypair == null) throw new MissingParamError('Either gaId or keypair is required');
    if (!Buffer.isBuffer(keypair.secretKey) && typeof keypair.secretKey === 'string' && !isHex(keypair.secretKey)) throw new InvalidKeypairError('Secret key must be hex string or Buffer');
    const secretKey = typeof keypair.secretKey === 'string' ? Buffer.from(keypair.secretKey, 'hex') : keypair.secretKey;

    if (!isValidKeypair(secretKey, decode(keypair.publicKey))) {
      throw new InvalidKeypairError('Invalid Key Pair');
    }

    secrets.set(this, {
      secretKey,
      publicKey: keypair.publicKey
    });
  }

  async sign(data) {
    if (this.isGa) throw new InvalidKeypairError('You are trying to sign data using generalized account without keypair');
    return sign(data, secrets.get(this).secretKey);
  }

  async signTransaction(tx) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isGa || options.innerTx === true) return super.signTransaction(tx, options);
    const {
      authData,
      authFun,
      onCompiler,
      onNode
    } = options;

    if (authFun == null || authData == null || onCompiler == null || onNode == null) {
      throw new ArgumentError('authData, authFun, onCompiler, onNode', 'provided', null);
    }

    return createMetaTx(tx, authData, authFun, {
      onCompiler,
      onNode,
      onAccount: this
    });
  }

  async address() {
    return secrets.get(this).publicKey;
  }

}
;// CONCATENATED MODULE: ./src/apis/compiler/models/mappers.ts
const Contract = {
  type: {
    name: "Composite",
    className: "Contract",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      }
    }
  }
};
const CompileOpts = {
  type: {
    name: "Composite",
    className: "CompileOpts",
    modelProperties: {
      backend: {
        serializedName: "backend",
        type: {
          name: "String"
        }
      },
      fileSystem: {
        serializedName: "file_system",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      srcFile: {
        serializedName: "src_file",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Aci = {
  type: {
    name: "Composite",
    className: "Aci",
    modelProperties: {
      encodedAci: {
        serializedName: "encoded_aci",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      externalEncodedAci: {
        serializedName: "external_encoded_aci",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      },
      interface: {
        serializedName: "interface",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_CompilerError = {
  type: {
    name: "Composite",
    className: "CompilerError",
    modelProperties: {
      context: {
        serializedName: "context",
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      pos: {
        serializedName: "pos",
        type: {
          name: "Composite",
          className: "ErrorPos"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorPos = {
  type: {
    name: "Composite",
    className: "ErrorPos",
    modelProperties: {
      col: {
        serializedName: "col",
        required: true,
        type: {
          name: "Number"
        }
      },
      file: {
        serializedName: "file",
        type: {
          name: "String"
        }
      },
      line: {
        serializedName: "line",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const APIVersion = {
  type: {
    name: "Composite",
    className: "APIVersion",
    modelProperties: {
      apiVersion: {
        serializedName: "api-version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_ByteCode = {
  type: {
    name: "Composite",
    className: "ByteCode",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ByteCodeInput = {
  type: {
    name: "Composite",
    className: "ByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CompilerVersion = {
  type: {
    name: "Composite",
    className: "CompilerVersion",
    modelProperties: {
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaCallResultInput = {
  type: {
    name: "Composite",
    className: "SophiaCallResultInput",
    modelProperties: {
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const BytecodeCallResultInput = {
  type: {
    name: "Composite",
    className: "BytecodeCallResultInput",
    modelProperties: {
      backend: {
        serializedName: "backend",
        type: {
          name: "String"
        }
      },
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCallresult = {
  type: {
    name: "Composite",
    className: "DecodedCallresult",
    modelProperties: {
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const DecodeCalldataBytecode = {
  type: {
    name: "Composite",
    className: "DecodeCalldataBytecode",
    modelProperties: {
      backend: {
        serializedName: "backend",
        type: {
          name: "String"
        }
      },
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCalldata = {
  type: {
    name: "Composite",
    className: "DecodedCalldata",
    modelProperties: {
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodeCalldataSource = {
  type: {
    name: "Composite",
    className: "DecodeCalldataSource",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaBinaryData = {
  type: {
    name: "Composite",
    className: "SophiaBinaryData",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      },
      sophiaType: {
        serializedName: "sophia-type",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaJsonData = {
  type: {
    name: "Composite",
    className: "SophiaJsonData",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const FunctionCallInput = {
  type: {
    name: "Composite",
    className: "FunctionCallInput",
    modelProperties: {
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Calldata = {
  type: {
    name: "Composite",
    className: "Calldata",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const FateAssembler = {
  type: {
    name: "Composite",
    className: "FateAssembler",
    modelProperties: {
      fateAssembler: {
        serializedName: "fate-assembler",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ValidateByteCodeInput = {
  type: {
    name: "Composite",
    className: "ValidateByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/compiler/models/parameters.ts

const parameters_contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const parameters_body = {
  parameterPath: "body",
  mapper: Contract
};
const parameters_accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const parameters_$host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const parameters_body1 = {
  parameterPath: "body",
  mapper: ByteCodeInput
};
const body2 = {
  parameterPath: "body",
  mapper: SophiaCallResultInput
};
const body3 = {
  parameterPath: "body",
  mapper: BytecodeCallResultInput
};
const body4 = {
  parameterPath: "body",
  mapper: DecodeCalldataBytecode
};
const body5 = {
  parameterPath: "body",
  mapper: DecodeCalldataSource
};
const body6 = {
  parameterPath: "body",
  mapper: SophiaBinaryData
};
const body7 = {
  parameterPath: "body",
  mapper: FunctionCallInput
};
const body8 = {
  parameterPath: "body",
  mapper: ValidateByteCodeInput
};
;// CONCATENATED MODULE: ./src/apis/compiler/compiler.ts




class compiler_Compiler extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Compiler class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint, _options;

    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    } // Initializing default values for options


    if (!options) {
      options = {};
    }

    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-compiler/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = { ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      baseUri: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);

    if ((_options = options) !== null && _options !== void 0 && _options.pipeline && options.pipeline.getOrderedPolicies().length > 0) {
      const pipelinePolicies = options.pipeline.getOrderedPolicies();
      const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some(pipelinePolicy => pipelinePolicy.name === core_rest_pipeline_.bearerTokenAuthenticationPolicyName);

      if (!bearerTokenAuthenticationPolicyFound) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_.bearerTokenAuthenticationPolicyName
        });
        this.pipeline.addPolicy(core_rest_pipeline_.bearerTokenAuthenticationPolicy({
          scopes: `${optionsWithDefaults.baseUri}/.default`,
          challengeCallbacks: {
            authorizeRequestOnChallenge: core_client_.authorizeRequestOnClaimChallenge
          }
        }));
      }
    } // Parameter assignments


    this.$host = $host;
  }
  /**
   * Generate an Aeternity Contract Interface (ACI) for contract
   * @param body contract code
   * @param options The options parameters.
   */


  generateACI(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, generateACIOperationSpec);
  }
  /**
   * Get the Api description
   * @param options The options parameters.
   */


  api(options) {
    return this.sendOperationRequest({
      options
    }, apiOperationSpec);
  }
  /**
   * Get the version of the API
   * @param options The options parameters.
   */


  aPIVersion(options) {
    return this.sendOperationRequest({
      options
    }, aPIVersionOperationSpec);
  }
  /**
   * Compile a sophia contract from source and return byte code
   * @param body contract code
   * @param options The options parameters.
   */


  compileContract(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, compileContractOperationSpec);
  }
  /**
   * Extract compiler version from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */


  getCompilerVersion(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getCompilerVersionOperationSpec);
  }
  /**
   * Decode the result of contract call
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */


  decodeCallResult(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultOperationSpec);
  }
  /**
   * Decode the result of contract call from Bytecode
   * @param body Call result + compiled contract
   * @param options The options parameters.
   */


  decodeCallResultBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultBytecodeOperationSpec);
  }
  /**
   * Identify function name and arguments in Calldata for a compiled contract
   * @param body Calldata + compiled contract
   * @param options The options parameters.
   */


  decodeCalldataBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataBytecodeOperationSpec);
  }
  /**
   * Identify function name and arguments in Calldata for a (partial) contract
   * @param body Calldata + contract (stub) code
   * @param options The options parameters.
   */


  decodeCalldataSource(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataSourceOperationSpec);
  }
  /**
   * Decode data as retuned by a contract call. - Legacy decoding
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */


  decodeData(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeDataOperationSpec);
  }
  /**
   * Encode Sophia function call according to sophia ABI.
   * @param body Sophia function call - contract code + function name + arguments
   * @param options The options parameters.
   */


  encodeCalldata(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, encodeCalldataOperationSpec);
  }
  /**
   * Get FATE assembler code from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */


  getFateAssemblerCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getFateAssemblerCodeOperationSpec);
  }
  /**
   * Verify that an encoded byte array is the result of compiling a given contract
   * @param body contract byte array and source code
   * @param options The options parameters.
   */


  validateByteCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, validateByteCodeOperationSpec);
  }
  /**
   * Get the version of the underlying Sophia compiler version
   * @param options The options parameters.
   */


  version(options) {
    return this.sendOperationRequest({
      options
    }, versionOperationSpec);
  }

} // Operation Specifications

const compiler_serializer = core_client_.createSerializer(models_mappers_namespaceObject,
/* isXml */
false);
const generateACIOperationSpec = {
  path: "/aci",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Aci
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const apiOperationSpec = {
  path: "/api",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const aPIVersionOperationSpec = {
  path: "/api-version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: APIVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const compileContractOperationSpec = {
  path: "/compile",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: mappers_ByteCode
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getCompilerVersionOperationSpec = {
  path: "/compiler-version",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: parameters_body1,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultOperationSpec = {
  path: "/decode-call-result",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "any"
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body2,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultBytecodeOperationSpec = {
  path: "/decode-call-result/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCallresult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body3,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataBytecodeOperationSpec = {
  path: "/decode-calldata/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body4,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataSourceOperationSpec = {
  path: "/decode-calldata/source",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body5,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeDataOperationSpec = {
  path: "/decode-data",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: SophiaJsonData
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body6,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const encodeCalldataOperationSpec = {
  path: "/encode-calldata",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Calldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body7,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getFateAssemblerCodeOperationSpec = {
  path: "/fate-assembler",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: FateAssembler
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: parameters_body1,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const validateByteCodeOperationSpec = {
  path: "/validate-byte-code",
  httpMethod: "POST",
  responses: {
    200: {},
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body8,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const versionOperationSpec = {
  path: "/version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
;// CONCATENATED MODULE: ./src/contract/Compiler.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */



/**
 * Contract Compiler
 *
 * This class include api call's related to contract compiler functionality.
 * @category contract
 * @example Compiler('COMPILER_URL')
 */
class Compiler extends compiler_Compiler {
  /**
   * @param compilerUrl - Url for compiler API
   * @param options - Options
   * @param options.ignoreVersion - Don't check compiler version
   */
  constructor(compilerUrl) {
    let {
      ignoreVersion
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(compilerUrl, {
      allowInsecureConnection: true,
      additionalPolicies: [genErrorFormatterPolicy(body => {
        let message = '';

        if ('reason' in body) {
          message += ` ${body.reason}${body.parameter != null ? ` in ${body.parameter}` : '' // TODO: revising after improving documentation https://github.com/aeternity/aesophia_http/issues/78
          }${body.info != null ? ` (${JSON.stringify(body.info)})` : ''}`;
        }

        if (Array.isArray(body)) {
          message += `\n${body.map(e => `${e.type}:${e.pos.line}:${e.pos.col}: ${e.message}${e.context != null ? `(${e.context})` : ''}`).map(e => e.trim()) // TODO: remove after fixing https://github.com/aeternity/aesophia_http/issues/80
          .join('\n')}`;
        }

        return message;
      })]
    });

    if (ignoreVersion !== true) {
      const versionPromise = this.aPIVersion().then(_ref => {
        let {
          apiVersion
        } = _ref;
        return apiVersion;
      });
      this.pipeline.addPolicy(genVersionCheckPolicy('compiler', '/api-version', versionPromise, '6.1.0', '7.0.0'));
    }
  }

}
;// CONCATENATED MODULE: ./src/AeSdkBase.ts



















function getValueOrErrorProxy(valueCb) {
  try {
    return valueCb();
  } catch (error) {
    return new Proxy({}, Object.fromEntries(['get', 'set', 'has'].map(name => [name, () => {
      throw error;
    }])));
  }
}
/**
 * Basic AeSdk class
 *
 * AeSdkBase objects are the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 * Only by providing the joint functionality of them, most more advanced
 * operations, i.e. the ones with actual use value on the chain, become
 * available.
 */


class AeSdkBase {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   * @param options.compilerUrl - Url for compiler API
   * @param options.ignoreVersion - Don't check node or compiler version
   */
  constructor() {
    let {
      nodes = [],
      compilerUrl,
      ignoreVersion = false,
      ...options
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    defineProperty_default()(this, "_options", {
      denomination: AE_AMOUNT_FORMATS.AETTOS,
      amount: AMOUNT
    });

    defineProperty_default()(this, "pool", new Map());

    defineProperty_default()(this, "getNetworkId", getNetworkId);

    Object.assign(this._options, options);
    nodes.forEach((_ref, i) => {
      let {
        name,
        instance
      } = _ref;
      return this.addNode(name, instance, i === 0);
    });

    if (compilerUrl == null) {
      this.compilerApi = getValueOrErrorProxy(() => {
        throw new CompilerError('You can\'t use Compiler API. Compiler is not ready!');
      });
    } else this.setCompilerUrl(compilerUrl, {
      ignoreVersion
    });
  }

  setCompilerUrl(compilerUrl) {
    let {
      ignoreVersion = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.compilerApi = new Compiler(compilerUrl, {
      ignoreVersion
    });
  }

  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }
  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */


  addNode(name, node) {
    let select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);

    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }
  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */


  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }
  /**
   * Get NetworkId of current Node
   * @example
   * nodePool.getNetworkId()
   */


  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }

  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError('You can\'t use Node API. Node is not connected or not defined!');
    }
  }
  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */


  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }
  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */


  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async _ref2 => {
      let [name, node] = _ref2;
      return {
        name,
        ...(await node.getNodeInfo())
      };
    }));
  } // eslint-disable-next-line class-methods-use-this


  addresses() {
    return [];
  }

  async address() {
    let {
      onAccount
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this._resolveAccount(onAccount).address();
  }

  async sign(data) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).sign(data, options);
  }

  async signTransaction(tx) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).signTransaction(tx, { ...options,
      networkId: await this.getNetworkId(options)
    });
  }

  async signMessage(message) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).signMessage(message, options);
  }

  async verifyMessage(message, signature) {
    let {
      onAccount,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this._resolveAccount(onAccount).verifyMessage(message, signature, options);
  }
  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  // eslint-disable-next-line class-methods-use-this


  _resolveAccount(account) {
    switch (account !== null && typeof account) {
      case 'string':
        throw new NotImplementedError('Address in AccountResolver');

      case 'object':
        return isAccountBase(account) ? account : new AccountMemory({
          keypair: account
        });

      default:
        throw new errors_TypeError('Account should be an address (ak-prefixed string), ' + `keypair, or instance of AccountBase, got ${String(account)} instead`);
    }
  }

  _getOptions() {
    return { ...this._options,
      onNode: getValueOrErrorProxy(() => this.api),
      onAccount: getValueOrErrorProxy(() => this._resolveAccount()),
      onCompiler: getValueOrErrorProxy(() => this.compilerApi)
    };
  }

  async buildTx(txType, options) {
    // @ts-expect-error TODO: need to figure out what's wrong here
    return _buildTx(txType, { ...this._getOptions(),
      ...options
    });
  }

}

const {
  _buildTx: _,
  ...txMethodsOther
} = tx_namespaceObject;
const {
  InvalidTxError: _2,
  ...chainMethodsOther
} = chain_namespaceObject;
const methods = { ...chainMethodsOther,
  ...txMethodsOther,
  ...aens_namespaceObject,
  ...spend_namespaceObject,
  ...oracle_namespaceObject,
  ...methods_namespaceObject,
  ...ga_namespaceObject,
  ...deprecated_methods_namespaceObject
};
Object.assign(AeSdkBase.prototype, mapObject(methods, _ref3 => {
  let [name, handler] = _ref3;
  return [name, function methodWrapper() {
    const instanceOptions = this._getOptions();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    const lastArg = args[args.length - 1];

    if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
      args[args.length - 1] = { ...instanceOptions,
        ...lastArg,
        ...(lastArg.onAccount != null && {
          onAccount: this._resolveAccount(lastArg.onAccount)
        })
      };
    } else args.push(instanceOptions);

    return handler(...args);
  }];
}));
/* harmony default export */ const src_AeSdkBase = (AeSdkBase);
;// CONCATENATED MODULE: ./src/AeSdk.ts




class AeSdk extends src_AeSdkBase {
  constructor() {
    super(...arguments);

    defineProperty_default()(this, "accounts", {});
  }

  _resolveAccount() {
    let account = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedAddress;

    if (typeof account === 'string') {
      const address = account;
      decode(address);
      if (this.accounts[address] == null) throw new UnavailableAccountError(account);
      account = this.accounts[address];
    }

    return super._resolveAccount(account);
  }
  /**
   * Get accounts addresses
   * @example addresses()
   */


  addresses() {
    return Object.keys(this.accounts);
  }
  /**
   * Add specific account
   * @param account - Account instance
   * @param options - Options
   * @param options.select - Select account
   * @example addAccount(account)
   */


  async addAccount(account) {
    let {
      select
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const address = await account.address();
    this.accounts[address] = account;
    if (select === true) this.selectAccount(address);
  }
  /**
   * Remove specific account
   * @param address - Address of account to remove
   * @example removeAccount(address)
   */


  removeAccount(address) {
    if (this.accounts[address] == null) {
      console.warn(`removeAccount: Account for ${address} not available`);
      return;
    }

    delete this.accounts[address]; // eslint-disable-line @typescript-eslint/no-dynamic-delete

    if (this.selectedAddress === address) delete this.selectedAddress;
  }
  /**
   * Select specific account
   * @param address - Address of account to select
   * @example selectAccount('ak_xxxxxxxx')
   */


  selectAccount(address) {
    decode(address);
    if (this.accounts[address] == null) throw new UnavailableAccountError(address);
    this.selectedAddress = address;
  }

}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/schema.ts

// eslint-disable-next-line max-classes-per-file

/**
 * @category aepp wallet communication
 */

let MESSAGE_DIRECTION;
/**
 * @category aepp wallet communication
 */

(function (MESSAGE_DIRECTION) {
  MESSAGE_DIRECTION["to_waellet"] = "to_waellet";
  MESSAGE_DIRECTION["to_aepp"] = "to_aepp";
})(MESSAGE_DIRECTION || (MESSAGE_DIRECTION = {}));

let WALLET_TYPE;
/**
 * @category aepp wallet communication
 */

(function (WALLET_TYPE) {
  WALLET_TYPE["window"] = "window";
  WALLET_TYPE["extension"] = "extension";
})(WALLET_TYPE || (WALLET_TYPE = {}));

let SUBSCRIPTION_TYPES;
/**
 * @category aepp wallet communication
 */

(function (SUBSCRIPTION_TYPES) {
  SUBSCRIPTION_TYPES["subscribe"] = "subscribe";
  SUBSCRIPTION_TYPES["unsubscribe"] = "unsubscribe";
})(SUBSCRIPTION_TYPES || (SUBSCRIPTION_TYPES = {}));

let METHODS;
/**
 * @category aepp wallet communication
 */

(function (METHODS) {
  METHODS["readyToConnect"] = "connection.announcePresence";
  METHODS["updateAddress"] = "address.update";
  METHODS["address"] = "address.get";
  METHODS["connect"] = "connection.open";
  METHODS["sign"] = "transaction.sign";
  METHODS["signMessage"] = "message.sign";
  METHODS["subscribeAddress"] = "address.subscribe";
  METHODS["updateNetwork"] = "networkId.update";
  METHODS["closeConnection"] = "connection.close";
})(METHODS || (METHODS = {}));

let RPC_STATUS;

(function (RPC_STATUS) {
  RPC_STATUS["CONNECTED"] = "CONNECTED";
  RPC_STATUS["DISCONNECTED"] = "DISCONNECTED";
  RPC_STATUS["WAITING_FOR_CONNECTION_REQUEST"] = "WAITING_FOR_CONNECTION_REQUEST";
})(RPC_STATUS || (RPC_STATUS = {}));

const rpcErrors = [];
/**
 * @category exception
 */

class RpcError extends BaseError {
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      data: this.data
    };
  }

  static deserialize(json) {
    const RpcErr = rpcErrors.find(cl => cl.code === json.code);
    if (RpcErr == null) throw new InternalError(`Can't find RpcError with code: ${json.code}`);
    return new RpcErr(json.data);
  }

}
/**
 * @category exception
 */

class RpcInvalidTransactionError extends RpcError {
  constructor(data) {
    super('Invalid transaction');

    defineProperty_default()(this, "code", 2);

    this.data = data;
    this.name = 'RpcInvalidTransactionError';
  }

}

defineProperty_default()(RpcInvalidTransactionError, "code", 2);

rpcErrors.push(RpcInvalidTransactionError);
/**
 * @category exception
 */

class RpcBroadcastError extends RpcError {
  constructor(data) {
    super('Broadcast failed');

    defineProperty_default()(this, "code", 3);

    this.data = data;
    this.name = 'RpcBroadcastError';
  }

}

defineProperty_default()(RpcBroadcastError, "code", 3);

rpcErrors.push(RpcBroadcastError);
/**
 * @category exception
 */

class RpcRejectedByUserError extends RpcError {
  constructor(data) {
    super('Operation rejected by user');

    defineProperty_default()(this, "code", 4);

    this.data = data;
    this.name = 'RpcRejectedByUserError';
  }

}

defineProperty_default()(RpcRejectedByUserError, "code", 4);

rpcErrors.push(RpcRejectedByUserError);
/**
 * @category exception
 */

class RpcUnsupportedProtocolError extends RpcError {
  constructor() {
    super('Unsupported Protocol Version');

    defineProperty_default()(this, "code", 5);

    this.name = 'RpcUnsupportedProtocolError';
  }

}

defineProperty_default()(RpcUnsupportedProtocolError, "code", 5);

rpcErrors.push(RpcUnsupportedProtocolError);
/**
 * @category exception
 */

class RpcConnectionDenyError extends RpcError {
  constructor(data) {
    super('Wallet deny your connection request');

    defineProperty_default()(this, "code", 9);

    this.data = data;
    this.name = 'RpcConnectionDenyError';
  }

}

defineProperty_default()(RpcConnectionDenyError, "code", 9);

rpcErrors.push(RpcConnectionDenyError);
/**
 * @category exception
 */

class RpcNotAuthorizeError extends RpcError {
  constructor() {
    super('You are not connected to the wallet');

    defineProperty_default()(this, "code", 10);

    this.name = 'RpcNotAuthorizeError';
  }

}

defineProperty_default()(RpcNotAuthorizeError, "code", 10);

rpcErrors.push(RpcNotAuthorizeError);
/**
 * @category exception
 */

class RpcPermissionDenyError extends RpcError {
  constructor(address) {
    super(`You are not subscribed for account ${address}`);

    defineProperty_default()(this, "code", 11);

    this.data = address;
    this.name = 'RpcPermissionDenyError';
  }

}

defineProperty_default()(RpcPermissionDenyError, "code", 11);

rpcErrors.push(RpcPermissionDenyError);
/**
 * @category exception
 */

class RpcInternalError extends RpcError {
  constructor() {
    super('The peer failed to execute your request due to unknown error');

    defineProperty_default()(this, "code", 12);

    this.name = 'RpcInternalError';
  }

}

defineProperty_default()(RpcInternalError, "code", 12);

rpcErrors.push(RpcInternalError);
/**
 * @category exception
 */

class RpcMethodNotFoundError extends RpcError {
  constructor() {
    super('Method not found');

    defineProperty_default()(this, "code", -32601);

    this.name = 'RpcMethodNotFoundError';
  }

}

defineProperty_default()(RpcMethodNotFoundError, "code", -32601);

rpcErrors.push(RpcMethodNotFoundError);
;// CONCATENATED MODULE: ./src/account/Rpc.ts




/**
 * Account provided by wallet
 * @param params - Params
 * @param params.rpcClient - RpcClient instance
 * @param params.address - RPC account address
 * @returns AccountRpc instance
 */
class AccountRpc extends AccountBase {
  constructor(_ref) {
    let {
      rpcClient,
      address,
      ...options
    } = _ref;
    super(options);
    this._rpcClient = rpcClient;
    this._address = address;
  } // eslint-disable-next-line class-methods-use-this


  async sign() {
    throw new NotImplementedError('RAW signing using wallet');
  }

  async address() {
    return this._address;
  }
  /**
   * @returns Signed transaction
   */


  async signTransaction(tx) {
    let {
      innerTx,
      networkId
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountRpc');
    const res = await this._rpcClient.request(METHODS.sign, {
      onAccount: this._address,
      tx,
      returnSigned: true,

      /**
       * @deprecated Wallet provided networkId will be used (current network)
       * required to maintain backward compatibility with wallets using SDK v11.0.1 and below
       * @see {@link https://github.com/aeternity/aepp-sdk-js/commit/153fd89a52c4eab39fcd659b356b36d32129c1ba}
       */
      networkId
    });
    return res.signedTransaction;
  }
  /**
   * @returns Signed message
   */


  async signMessage(message) {
    let {
      returnHex = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      signature
    } = await this._rpcClient.request(METHODS.signMessage, {
      onAccount: this._address,
      message
    });
    return returnHex ? signature : Buffer.from(signature, 'hex');
  }

}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/rpc/types.ts

const RPC_VERSION = 1;
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/classPrivateFieldGet.js
var classPrivateFieldGet = __webpack_require__(7667);
var classPrivateFieldGet_default = /*#__PURE__*/__webpack_require__.n(classPrivateFieldGet);
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/classPrivateFieldSet.js
var classPrivateFieldSet = __webpack_require__(719);
var classPrivateFieldSet_default = /*#__PURE__*/__webpack_require__.n(classPrivateFieldSet);
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/rpc/RpcClient.ts



function RpcClient_classPrivateMethodInitSpec(obj, privateSet) { RpcClient_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateFieldInitSpec(obj, privateMap, value) { RpcClient_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function RpcClient_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function RpcClient_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }




var _callbacks = /*#__PURE__*/new WeakMap();

var _messageId = /*#__PURE__*/new WeakMap();

var _methods = /*#__PURE__*/new WeakMap();

var _handleMessage = /*#__PURE__*/new WeakSet();

var _sendRequest = /*#__PURE__*/new WeakSet();

var _sendResponse = /*#__PURE__*/new WeakSet();

var _processResponse = /*#__PURE__*/new WeakSet();

/**
 * Contain functionality for using RPC conection
 * @category aepp wallet communication
 * @param connection - Connection object
 * @param onDisconnect - Disconnect callback
 * @param methods - Object containing handlers for each request by name
 */
class RpcClient {
  constructor(connection, onDisconnect, methods) {
    RpcClient_classPrivateMethodInitSpec(this, _processResponse);

    RpcClient_classPrivateMethodInitSpec(this, _sendResponse);

    RpcClient_classPrivateMethodInitSpec(this, _sendRequest);

    RpcClient_classPrivateMethodInitSpec(this, _handleMessage);

    _classPrivateFieldInitSpec(this, _callbacks, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _messageId, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _methods, {
      writable: true,
      value: void 0
    });

    this.connection = connection;

    classPrivateFieldSet_default()(this, _methods, methods);

    connection.connect(RpcClient_classPrivateMethodGet(this, _handleMessage, _handleMessage2).bind(this), onDisconnect);
  }

  /**
   * Make a request
   * @param name - Method name
   * @param params - Method params
   * @returns Promise which will be resolved after receiving response message
   */
  async request(name, params) {
    RpcClient_classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, classPrivateFieldSet_default()(this, _messageId, classPrivateFieldGet_default()(this, _messageId) + 1), name, params);

    return new Promise((resolve, reject) => {
      classPrivateFieldGet_default()(this, _callbacks).set(classPrivateFieldGet_default()(this, _messageId), {
        resolve,
        reject
      });
    });
  }
  /**
   * Make a notification
   * @param name - Method name
   * @param params - Method params
   */


  notify(name, params) {
    RpcClient_classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, undefined, name, params);
  }
  /**
   * Process response message
   * @param msg - Message object
   */


}

async function _handleMessage2(msg, origin) {
  if ((msg === null || msg === void 0 ? void 0 : msg.jsonrpc) !== '2.0') throw new InvalidRpcMessageError(JSON.stringify(msg));

  if ('result' in msg || 'error' in msg) {
    RpcClient_classPrivateMethodGet(this, _processResponse, _processResponse2).call(this, msg);

    return;
  }

  const request = msg;
  let result;
  let error;

  try {
    if (!(request.method in classPrivateFieldGet_default()(this, _methods))) throw new RpcMethodNotFoundError();
    const methodName = request.method;
    result = await classPrivateFieldGet_default()(this, _methods)[methodName](request.params, origin);
  } catch (e) {
    error = e instanceof RpcError ? e : new RpcInternalError();
  }

  if (request.id != null) {
    RpcClient_classPrivateMethodGet(this, _sendResponse, _sendResponse2).call(this, request.id, request.method, result, error);
  }
}

function _sendRequest2(id, method, params) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    ...(id != null ? {
      id
    } : {}),
    method,
    ...(params != null ? {
      params
    } : {})
  });
}

function _sendResponse2(id, method, // TODO: remove as far it is not required in JSON RPC
result, error) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    id,
    method,
    ...(error != null ? {
      error
    } : {
      result
    })
  });
}

function _processResponse2(_ref) {
  let {
    id,
    error,
    result
  } = _ref;

  const callbacks = classPrivateFieldGet_default()(this, _callbacks).get(id);

  if (callbacks == null) throw new MissingCallbackError(id);
  if (error != null) callbacks.reject(RpcError.deserialize(error));else callbacks.resolve(result);

  classPrivateFieldGet_default()(this, _callbacks).delete(id);
}
;// CONCATENATED MODULE: ./src/AeSdkAepp.ts










/**
 * RPC handler for AEPP side
 * Contain functionality for wallet interaction and connect it to sdk
 * @category aepp wallet communication
 */
class AeSdkAepp extends src_AeSdkBase {
  /**
   * @param options - Options
   * @param options.name - Aepp name
   * @param options.onAddressChange - Call-back function for update address event
   * @param options.onDisconnect - Call-back function for disconnect event
   * @param options.onNetworkChange - Call-back function for update network event
   */
  constructor(_ref) {
    let {
      name,
      onAddressChange = () => {},
      onDisconnect = () => {},
      onNetworkChange = () => {},
      ...other
    } = _ref;
    super(other);
    this.onAddressChange = onAddressChange;
    this.onDisconnect = onDisconnect;
    this.onNetworkChange = onNetworkChange;
    this.name = name;
  }

  _resolveAccount() {
    let account = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.addresses()[0];

    if (typeof account === 'string') {
      var _context;

      const address = account;
      decode(address);
      if (!includes_default()(_context = this.addresses()).call(_context, address)) throw new UnAuthorizedAccountError(address);
      account = new AccountRpc({
        rpcClient: this.rpcClient,
        address
      });
    }

    if (account == null) this._ensureAccountAccess();
    return super._resolveAccount(account);
  }

  addresses() {
    if (this._accounts == null) return [];
    const current = Object.keys(this._accounts.current)[0];
    return [...(current != null ? [current] : []), ...Object.keys(this._accounts.connected)];
  }
  /**
   * Connect to wallet
   * @param connection - Wallet connection object
   * @param options - Options
   * @param options.connectNode - Request wallet to bind node
   * @param options.name - Node name
   * @param options.select - Select this node as current
   */


  async connectToWallet(connection) {
    let {
      connectNode = false,
      name = 'wallet-node',
      select = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (this.rpcClient != null) throw new AlreadyConnectedError('You are already connected to wallet');
    let disconnectParams;
    const client = new RpcClient(connection, () => {
      delete this.rpcClient;
      delete this._accounts;
      this.onDisconnect(disconnectParams);
    }, {
      [METHODS.updateAddress]: params => {
        this._accounts = params;
        this.onAddressChange(params);
      },
      [METHODS.updateNetwork]: params => {
        const {
          node
        } = params;
        if (node != null) this.addNode(node.name, new Node_Node(node.url), true);
        this.onNetworkChange(params);
      },
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    const {
      node,
      ...walletInfo
    } = await client.request(METHODS.connect, {
      name: this.name,
      version: RPC_VERSION,
      connectNode
    });

    if (connectNode) {
      if (node == null) throw new RpcConnectionError('Missing URLs of the Node');
      this.addNode(name, new Node_Node(node.url), select);
    }

    this.rpcClient = client;
    return walletInfo;
  }
  /**
   * Disconnect from wallet
   */


  disconnectWallet() {
    this._ensureConnected();

    this.rpcClient.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    this.rpcClient.connection.disconnect();
  }
  /**
   * Ask addresses from wallet
   * @returns Addresses from wallet
   */


  async askAddresses() {
    this._ensureAccountAccess();

    return this.rpcClient.request(METHODS.address, undefined);
  }
  /**
   * Subscribe for addresses from wallet
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */


  async subscribeAddress(type, value) {
    this._ensureConnected();

    const result = await this.rpcClient.request(METHODS.subscribeAddress, {
      type,
      value
    });
    this._accounts = result.address;
    return result;
  }

  _ensureConnected() {
    if (this.rpcClient != null) return;
    throw new NoWalletConnectedError('You are not connected to Wallet');
  }

  _ensureAccountAccess() {
    this._ensureConnected();

    if (this.addresses().length !== 0) return;
    throw new UnsubscribedAccountError();
  }

}
// EXTERNAL MODULE: external "json-bigint"
var external_json_bigint_ = __webpack_require__(2716);
var external_json_bigint_default = /*#__PURE__*/__webpack_require__.n(external_json_bigint_);
;// CONCATENATED MODULE: ./src/utils/json-big.ts



const jsonBig = external_json_bigint_default()({
  storeAsString: true
});

const convertValuesToBigNumbers = value => {
  if (typeof value === 'object' && value !== null && value.constructor === Object) {
    return mapObject(value, _ref => {
      let [k, v] = _ref;
      return [k, convertValuesToBigNumbers(v)];
    });
  }

  if (Array.isArray(value)) {
    return value.map(item => convertValuesToBigNumbers(item));
  }

  if (typeof value === 'string' && new (external_bignumber_js_default())(value).toString(10) === value) {
    const bn = new (external_bignumber_js_default())(value);

    bn.toJSON = () => bn.toString(10);

    return bn;
  }

  return value;
};

/* harmony default export */ const json_big = ({
  stringify: function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return jsonBig.stringify(convertValuesToBigNumbers(args[0]), ...args.slice(1));
  },
  parse: jsonBig.parse
});
;// CONCATENATED MODULE: ./src/AeSdkWallet.ts










/**
 * Contain functionality for aepp interaction and managing multiple aepps
 * @category aepp wallet communication
 */
class AeSdkWallet extends AeSdk {
  /**
   * @param options - Options
   * @param options.name - Wallet name
   * @param options.id - Wallet id
   * @param options.type - Wallet type
   * @param options.onConnection - Call-back function for incoming AEPP connection
   * @param options.onSubscription - Call-back function for incoming AEPP account subscription
   * @param options.onSign - Call-back function for incoming AEPP sign request
   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request
   * @param options.onMessageSign - Call-back function for incoming AEPP sign message request
   * @param options.onDisconnect - Call-back function for disconnect event
   */
  constructor(_ref) {
    let {
      name,
      id,
      type,
      onConnection,
      onSubscription,
      onSign,
      onDisconnect,
      onAskAccounts,
      onMessageSign,
      ...options
    } = _ref;
    super(options);
    this.onConnection = onConnection;
    this.onSubscription = onSubscription;
    this.onSign = onSign;
    this.onDisconnect = onDisconnect;
    this.onAskAccounts = onAskAccounts;
    this.onMessageSign = onMessageSign;
    this._clients = new Map();
    this.name = name;
    this.id = id;
    this._type = type;
  }

  _pushAccountsToApps() {
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientSubscribed(clientId)).map(clientId => this._getClient(clientId).rpc).forEach(client => client.notify(METHODS.updateAddress, this.getAccounts()));
  }

  selectAccount(address) {
    super.selectAccount(address);

    this._pushAccountsToApps();
  }

  async addAccount(account, options) {
    await super.addAccount(account, options);

    this._pushAccountsToApps();
  }

  _getNode() {
    this.ensureNodeConnected();
    return {
      node: {
        url: this.api.url,
        name: this.selectedNodeName
      }
    };
  }

  async selectNode(name) {
    super.selectNode(name);
    const networkId = await this.getNetworkId();
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {
      client.rpc.notify(METHODS.updateNetwork, {
        networkId,
        ...(client.connectNode && this._getNode())
      });
    });
  }

  _getClient(clientId) {
    const client = this._clients.get(clientId);

    if (client == null) throw new UnknownRpcClientError(clientId);
    return client;
  }

  _isRpcClientSubscribed(clientId) {
    return this._isRpcClientConnected(clientId) && this._getClient(clientId).addressSubscription.size !== 0;
  }

  _isRpcClientConnected(clientId) {
    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();
  }

  _disconnectRpcClient(clientId) {
    const client = this._getClient(clientId);

    client.rpc.connection.disconnect();
    client.status = RPC_STATUS.DISCONNECTED;
    client.addressSubscription = new Set();
  }
  /**
   * Remove specific RpcClient by ID
   * @param id - Client ID
   */


  removeRpcClient(id) {
    this._disconnectRpcClient(id);

    this._clients.delete(id);
  }
  /**
   * Add new client by AEPP connection
   * @param clientConnection - AEPP connection object
   * @returns Client ID
   */


  addRpcClient(clientConnection) {
    // @TODO  detect if aepp has some history based on origin????
    // if yes use this instance for connection
    const id = (0,uuid_.v4)();
    let disconnectParams;
    const client = {
      id,
      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,
      addressSubscription: new Set(),
      connectNode: false,
      rpc: new RpcClient(clientConnection, () => {
        this._clients.delete(id);

        this.onDisconnect(id, disconnectParams); // also related info
      }, {
        [METHODS.closeConnection]: params => {
          disconnectParams = params;

          this._disconnectRpcClient(id);
        },
        // Store client info and prepare two fn for each client `connect` and `denyConnection`
        // which automatically prepare and send response for that client
        [METHODS.connect]: async (_ref2, origin) => {
          let {
            name,
            version,
            icons,
            connectNode
          } = _ref2;
          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();
          await this.onConnection(id, {
            name,
            icons,
            connectNode
          }, origin);
          client.status = RPC_STATUS.CONNECTED;
          client.connectNode = connectNode;
          return { ...(await this.getWalletInfo()),
            ...(connectNode && this._getNode())
          };
        },
        [METHODS.subscribeAddress]: async (_ref3, origin) => {
          let {
            type,
            value
          } = _ref3;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onSubscription(id, {
            type,
            value
          }, origin);

          switch (type) {
            case SUBSCRIPTION_TYPES.subscribe:
              client.addressSubscription.add(value);
              break;

            case SUBSCRIPTION_TYPES.unsubscribe:
              client.addressSubscription.delete(value);
              break;

            default:
              throw new InternalError(`Unknown subscription type: ${type}`);
          }

          return {
            subscription: Array.from(client.addressSubscription),
            address: this.getAccounts()
          };
        },
        [METHODS.address]: async (params, origin) => {
          if (!this._isRpcClientSubscribed(id)) throw new RpcNotAuthorizeError();
          await this.onAskAccounts(id, params, origin);
          return this.addresses();
        },
        [METHODS.sign]: async (_ref4, origin) => {
          var _onAccount, _context, _overrides$onAccount, _overrides$tx;

          let {
            tx,
            onAccount,
            returnSigned
          } = _ref4;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          (_onAccount = onAccount) !== null && _onAccount !== void 0 ? _onAccount : onAccount = await this.address();

          if (!includes_default()(_context = this.addresses()).call(_context, onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }

          const overrides = await this.onSign(id, {
            tx,
            returnSigned,
            onAccount
          }, origin);
          onAccount = (_overrides$onAccount = overrides === null || overrides === void 0 ? void 0 : overrides.onAccount) !== null && _overrides$onAccount !== void 0 ? _overrides$onAccount : onAccount;
          tx = (_overrides$tx = overrides === null || overrides === void 0 ? void 0 : overrides.tx) !== null && _overrides$tx !== void 0 ? _overrides$tx : tx;

          if (returnSigned) {
            return {
              signedTransaction: await this.signTransaction(tx, {
                onAccount
              })
            };
          }

          try {
            return json_big.parse(json_big.stringify({
              transactionHash: await this.send(tx, {
                onAccount,
                verify: false
              })
            }));
          } catch (error) {
            const validation = await verifyTransaction(tx, this.api);
            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);
            throw new RpcBroadcastError(error.message);
          }
        },
        [METHODS.signMessage]: async (_ref5, origin) => {
          var _onAccount2, _context2, _overrides$onAccount2;

          let {
            message,
            onAccount
          } = _ref5;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          (_onAccount2 = onAccount) !== null && _onAccount2 !== void 0 ? _onAccount2 : onAccount = await this.address();

          if (!includes_default()(_context2 = this.addresses()).call(_context2, onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }

          const overrides = await this.onMessageSign(id, {
            message,
            onAccount
          }, origin);
          onAccount = (_overrides$onAccount2 = overrides === null || overrides === void 0 ? void 0 : overrides.onAccount) !== null && _overrides$onAccount2 !== void 0 ? _overrides$onAccount2 : onAccount;
          return {
            // TODO: fix signMessage return type
            signature: await this.signMessage(message, {
              onAccount,
              returnHex: true
            })
          };
        }
      })
    };

    this._clients.set(id, client);

    return id;
  }
  /**
   * Send shareWalletInfo message to notify AEPP about wallet
   * @param clientId - ID of RPC client send message to
   */


  async shareWalletInfo(clientId) {
    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());
  }
  /**
   * Get Wallet info object
   * @returns Object with wallet information
   */


  async getWalletInfo() {
    return {
      id: this.id,
      name: this.name,
      networkId: await this.getNetworkId(),
      origin: window.location.origin,
      type: this._type
    };
  }
  /**
   * Get Wallet accounts
   * @returns Object with accounts information (\{ connected: Object, current: Object \})
   */


  getAccounts() {
    return {
      current: this.selectedAddress != null ? {
        [this.selectedAddress]: {}
      } : {},
      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({ ...acc,
        [a]: {}
      }), {})
    };
  }

}
// EXTERNAL MODULE: external "websocket"
var external_websocket_ = __webpack_require__(8079);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(3735);
;// CONCATENATED MODULE: ./src/channel/internal.ts


/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */





// Send ping message every 10 seconds
const PING_TIMEOUT_MS = 10000; // Close connection if pong message is not received within 5 seconds

const PONG_TIMEOUT_MS = 5000; // TODO: move to Channel instance to avoid is-null checks and for easier debugging

const options = new WeakMap();
const internal_status = new WeakMap();
const internal_state = new WeakMap();
const fsm = new WeakMap();
const websockets = new WeakMap();
const eventEmitters = new WeakMap();
const messageQueue = new WeakMap();
const messageQueueLocked = new WeakMap();
const actionQueue = new WeakMap();
const actionQueueLocked = new WeakMap();
const sequence = new WeakMap();
const channelId = new WeakMap();
const rpcCallbacks = new WeakMap();
const pingTimeoutId = new WeakMap();
const pongTimeoutId = new WeakMap();
const fsmId = new WeakMap();
function emit(channel) {
  var _eventEmitters$get;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  const [eventName, ...rest] = args;
  (_eventEmitters$get = eventEmitters.get(channel)) === null || _eventEmitters$get === void 0 ? void 0 : _eventEmitters$get.emit(eventName, ...rest);
}

function enterState(channel, nextState) {
  var _nextState$handler;

  if (nextState == null) {
    throw new UnknownChannelStateError();
  }

  fsm.set(channel, nextState);

  if ((nextState === null || nextState === void 0 ? void 0 : (_nextState$handler = nextState.handler) === null || _nextState$handler === void 0 ? void 0 : _nextState$handler.enter) != null) {
    nextState.handler.enter(channel);
  } // eslint-disable-next-line @typescript-eslint/no-use-before-define


  void dequeueAction(channel);
}

function changeStatus(channel, newStatus) {
  const prevStatus = internal_status.get(channel);

  if (newStatus !== prevStatus) {
    internal_status.set(channel, newStatus);
    emit(channel, 'statusChanged', newStatus);
  }
}
function changeState(channel, newState) {
  internal_state.set(channel, newState);
  emit(channel, 'stateChanged', newState);
}
function internal_send(channel, message) {
  var _options$get$debug, _options$get, _websockets$get;

  const debug = (_options$get$debug = (_options$get = options.get(channel)) === null || _options$get === void 0 ? void 0 : _options$get.debug) !== null && _options$get$debug !== void 0 ? _options$get$debug : false;
  if (debug) console.log('Send message: ', message);
  (_websockets$get = websockets.get(channel)) === null || _websockets$get === void 0 ? void 0 : _websockets$get.send(json_big.stringify(message));
}

async function dequeueAction(channel) {
  var _actionQueue$get;

  const locked = actionQueueLocked.get(channel);
  const queue = (_actionQueue$get = actionQueue.get(channel)) !== null && _actionQueue$get !== void 0 ? _actionQueue$get : [];

  if (Boolean(locked) || queue.length === 0) {
    return;
  }

  const singleFsm = fsm.get(channel);
  if (singleFsm == null) return;
  const index = queue.findIndex(action => action.guard(channel, singleFsm));

  if (index === -1) {
    return;
  }

  actionQueue.set(channel, queue.filter((_, i) => index !== i));
  actionQueueLocked.set(channel, true);
  const nextState = await Promise.resolve(queue[index].action(channel, singleFsm));
  actionQueueLocked.set(channel, false);
  enterState(channel, nextState);
}

function enqueueAction(channel, guard, action) {
  var _actionQueue$get2;

  const queue = (_actionQueue$get2 = actionQueue.get(channel)) !== null && _actionQueue$get2 !== void 0 ? _actionQueue$get2 : [];
  actionQueue.set(channel, [...queue, {
    guard,
    action
  }]);
  void dequeueAction(channel);
}

async function handleMessage(channel, message) {
  const fsmState = fsm.get(channel);
  if (fsmState == null) throw new UnknownChannelStateError();
  const {
    handler,
    state: st
  } = fsmState;
  enterState(channel, await Promise.resolve(handler(channel, message, st)));
}

async function dequeueMessage(channel) {
  var _messageQueueLocked$g, _messageQueue$get;

  const locked = (_messageQueueLocked$g = messageQueueLocked.get(channel)) !== null && _messageQueueLocked$g !== void 0 ? _messageQueueLocked$g : false;
  if (locked) return;
  const messages = (_messageQueue$get = messageQueue.get(channel)) !== null && _messageQueue$get !== void 0 ? _messageQueue$get : [];
  if (messages.length === 0) return;
  messageQueueLocked.set(channel, true);

  while (messages.length > 0) {
    var _messages$shift;

    const message = (_messages$shift = messages.shift()) !== null && _messages$shift !== void 0 ? _messages$shift : '';

    try {
      await handleMessage(channel, message);
    } catch (error) {
      console.error('Error handling incoming message:');
      console.error(message);
      console.error(error);
    }
  }

  messageQueueLocked.set(channel, false);
}

function disconnect(channel) {
  var _websockets$get2;

  (_websockets$get2 = websockets.get(channel)) === null || _websockets$get2 === void 0 ? void 0 : _websockets$get2.close();
  const pingTimeoutIdValue = pingTimeoutId.get(channel);
  const pongTimeoutIdValue = pongTimeoutId.get(channel);
  if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
  if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
}

function ping(channel) {
  const pingTimeoutIdValue = pingTimeoutId.get(channel);
  const pongTimeoutIdValue = pongTimeoutId.get(channel);
  if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
  if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
  pingTimeoutId.set(channel, setTimeout(() => {
    internal_send(channel, {
      jsonrpc: '2.0',
      method: 'channels.system',
      params: {
        action: 'ping'
      }
    });
    pongTimeoutId.set(channel, setTimeout(() => {
      disconnect(channel);
      emit(channel, 'error', new ChannelPingTimedOutError());
    }, PONG_TIMEOUT_MS));
  }, PING_TIMEOUT_MS));
}

function onMessage(channel, data) {
  var _options$get$debug2, _options$get2, _messageQueue$get2;

  const message = json_big.parse(data);
  const debug = (_options$get$debug2 = (_options$get2 = options.get(channel)) === null || _options$get2 === void 0 ? void 0 : _options$get2.debug) !== null && _options$get$debug2 !== void 0 ? _options$get$debug2 : false;
  if (debug) console.log('Receive message: ', message);

  if (message.id != null) {
    var _rpcCallbacks$get;

    const callback = (_rpcCallbacks$get = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get === void 0 ? void 0 : _rpcCallbacks$get.get(message.id);

    try {
      callback === null || callback === void 0 ? void 0 : callback(message);
    } finally {
      var _rpcCallbacks$get2;

      (_rpcCallbacks$get2 = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get2 === void 0 ? void 0 : _rpcCallbacks$get2.delete(message.id);
    }

    return;
  }

  if (message.method === 'channels.message') {
    emit(channel, 'message', message.params.data.message);
    return;
  }

  if (message.method === 'channels.system.pong') {
    if (message.params.channel_id === channelId.get(channel) // Skip channelId check if channelId is not known yet
    || channelId.get(channel) == null) {
      ping(channel);
    }

    return;
  }

  (_messageQueue$get2 = messageQueue.get(channel)) === null || _messageQueue$get2 === void 0 ? void 0 : _messageQueue$get2.push(message);
  void dequeueMessage(channel);
}

async function call(channel, method, params) {
  return new Promise((resolve, reject) => {
    var _sequence$get, _sequence$set$get, _rpcCallbacks$get3;

    const currentSequence = (_sequence$get = sequence.get(channel)) !== null && _sequence$get !== void 0 ? _sequence$get : 0;
    const id = (_sequence$set$get = sequence.set(channel, currentSequence + 1).get(channel)) !== null && _sequence$set$get !== void 0 ? _sequence$set$get : 1;
    (_rpcCallbacks$get3 = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get3 === void 0 ? void 0 : _rpcCallbacks$get3.set(id, message => {
      if (message.error != null) {
        var _message$error$data;

        const [{
          message: details
        } = {
          message: ''
        }] = (_message$error$data = message.error.data) !== null && _message$error$data !== void 0 ? _message$error$data : [];
        return reject(new ChannelCallError(message.error.message + details));
      }

      return resolve(message.result);
    });
    internal_send(channel, {
      jsonrpc: '2.0',
      method,
      id,
      params
    });
  });
}
async function initialize(channel, connectionHandler, openHandler, _ref) {
  let {
    url,
    ...channelOptions
  } = _ref;
  options.set(channel, {
    url,
    ...channelOptions
  });
  fsm.set(channel, {
    handler: connectionHandler
  });
  eventEmitters.set(channel, new external_events_.EventEmitter());
  sequence.set(channel, 0);
  rpcCallbacks.set(channel, new Map());
  messageQueue.set(channel, []);
  const wsUrl = new URL(url);
  Object.entries(channelOptions).filter(_ref2 => {
    var _context;

    let [key] = _ref2;
    return !includes_default()(_context = ['sign', 'debug']).call(_context, key);
  }).forEach(_ref3 => {
    let [key, value] = _ref3;
    return wsUrl.searchParams.set(pascalToSnake(key), value);
  });
  wsUrl.searchParams.set('protocol', 'json-rpc');
  changeStatus(channel, 'connecting');
  const ws = new external_websocket_.w3cwebsocket(wsUrl.toString());
  await new Promise((resolve, reject) => {
    Object.assign(ws, {
      onerror: reject,
      onopen: async () => {
        resolve();
        changeStatus(channel, 'connected');

        if (channelOptions.reconnectTx != null) {
          enterState(channel, {
            handler: openHandler
          });
          const signedTx = (await call(channel, 'channels.get.offchain_state', {})).signed_tx;
          changeState(channel, signedTx);
        }

        ping(channel);
      },
      onclose: () => {
        changeStatus(channel, 'disconnected');
        const pingTimeoutIdValue = pingTimeoutId.get(channel);
        const pongTimeoutIdValue = pongTimeoutId.get(channel);
        if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
        if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
      },
      onmessage: _ref4 => {
        let {
          data
        } = _ref4;
        return onMessage(channel, data);
      }
    });
  });
  websockets.set(channel, ws);
}
;// CONCATENATED MODULE: ./src/channel/handlers.ts


/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/* eslint-disable consistent-return */

/* eslint-disable default-case */

/* eslint-disable @typescript-eslint/no-use-before-define */






async function appendSignature(tx, signFn) {
  const {
    signatures,
    encodedTx
  } = unpackTx(tx, Tag.SignedTx).tx;
  const result = await signFn(encode(encodedTx.rlpEncoded, Encoding.Transaction));

  if (typeof result === 'string') {
    const {
      tx: signedTx
    } = unpackTx(result, Tag.SignedTx);
    return buildTx({
      signatures: signatures.concat(signedTx.signatures),
      encodedTx: signedTx.encodedTx.rlpEncoded
    }, Tag.SignedTx).tx;
  }

  return result;
}

function handleUnexpectedMessage(_channel, message, state) {
  var _state$reject;

  state === null || state === void 0 ? void 0 : (_state$reject = state.reject) === null || _state$reject === void 0 ? void 0 : _state$reject.call(state, Object.assign(new UnexpectedChannelMessageError(`Unexpected message received:\n\n${JSON.stringify(message)}`), {
    wsMessage: message
  }));
  return {
    handler: channelOpen
  };
}

function awaitingConnection(channel, message) {
  if (message.method === 'channels.info') {
    var _context;

    const channelInfoStatus = message.params.data.event;

    if (includes_default()(_context = ['channel_accept', 'funding_created']).call(_context, channelInfoStatus)) {
      changeStatus(channel, {
        channel_accept: 'accepted',
        funding_created: 'halfSigned'
      }[channelInfoStatus]);
      return {
        handler: awaitingChannelCreateTx
      };
    }

    if (message.params.data.event === 'channel_reestablished') {
      return {
        handler: awaitingOpenConfirmation
      };
    }

    if (message.params.data.event === 'fsm_up') {
      fsmId.set(channel, message.params.data.fsm_id);
      return {
        handler: awaitingConnection
      };
    }

    return {
      handler: awaitingConnection
    };
  }

  if (message.method === 'channels.error') {
    var _message$payload;

    emit(channel, 'error', new ChannelConnectionError(message === null || message === void 0 ? void 0 : (_message$payload = message.payload) === null || _message$payload === void 0 ? void 0 : _message$payload.message));
    return {
      handler: channelClosed
    };
  }
}
async function awaitingReconnection(channel, message, state) {
  if (message.method === 'channels.info') {
    if (message.params.data.event === 'fsm_up') {
      fsmId.set(channel, message.params.data.fsm_id);
      changeState(channel, (await call(channel, 'channels.get.offchain_state', {})).signed_tx);
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingChannelCreateTx(channel, message) {
  const channelOptions = options.get(channel);

  if (channelOptions != null) {
    const tag = {
      initiator: 'initiator_sign',
      responder: 'responder_sign'
    }[channelOptions.role];

    if (message.method === `channels.sign.${tag}`) {
      if (message.params.data.tx != null) {
        const signedTx = await channelOptions.sign(tag, message.params.data.tx);
        internal_send(channel, {
          jsonrpc: '2.0',
          method: `channels.${tag}`,
          params: {
            tx: signedTx
          }
        });
        return {
          handler: awaitingOnChainTx
        };
      }

      const signedTx = await appendSignature(message.params.data.signed_tx, async tx => channelOptions.sign(tag, tx));
      internal_send(channel, {
        jsonrpc: '2.0',
        method: `channels.${tag}`,
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingOnChainTx
      };
    }
  }
}
function awaitingOnChainTx(channel, message) {
  const channelOptions = options.get(channel);

  if (channelOptions != null) {
    if (message.method === 'channels.on_chain_tx') {
      if (message.params.data.info === 'funding_signed' && channelOptions.role === 'initiator') {
        return {
          handler: awaitingBlockInclusion
        };
      }

      if (message.params.data.info === 'funding_created' && channelOptions.role === 'responder') {
        return {
          handler: awaitingBlockInclusion
        };
      }
    }

    if (message.method === 'channels.info' && message.params.data.event === 'funding_signed' && channelOptions.role === 'initiator') {
      channelId.set(channel, message.params.channel_id);
      changeStatus(channel, 'signed');
      return {
        handler: awaitingOnChainTx
      };
    }
  }
}
function awaitingBlockInclusion(channel, message) {
  if (message.method === 'channels.info') {
    const handlers = {
      funding_created: awaitingBlockInclusion,
      own_funding_locked: awaitingBlockInclusion,
      funding_locked: awaitingOpenConfirmation
    };
    const handler = handlers[message.params.data.event];

    if (handler != null) {
      return {
        handler
      };
    }
  }

  if (message.method === 'channels.on_chain_tx') {
    emit(channel, 'onChainTx', message.params.data.tx, {
      info: message.params.data.info,
      type: message.params.data.type
    });
    return {
      handler: awaitingBlockInclusion
    };
  }
}
function awaitingOpenConfirmation(channel, message) {
  if (message.method === 'channels.info' && message.params.data.event === 'open') {
    channelId.set(channel, message.params.channel_id);
    return {
      handler: awaitingInitialState
    };
  }
}
function awaitingInitialState(channel, message) {
  if (message.method === 'channels.update') {
    changeState(channel, message.params.data.state);
    return {
      handler: channelOpen
    };
  }
}
async function channelOpen(channel, message, state) {
  switch (message.method) {
    case 'channels.info':
      switch (message.params.data.event) {
        case 'update':
        case 'withdraw_created':
        case 'deposit_created':
          return {
            handler: awaitingTxSignRequest
          };

        case 'own_withdraw_locked':
        case 'withdraw_locked':
        case 'own_deposit_locked':
        case 'deposit_locked':
        case 'peer_disconnected':
        case 'channel_reestablished':
        case 'open':
          // TODO: Better handling of peer_disconnected event.
          //
          //       We should enter intermediate state where offchain transactions
          //       are blocked until channel is reestablished.
          emit(channel, message.params.data.event);
          return {
            handler: channelOpen
          };

        case 'fsm_up':
          fsmId.set(channel, message.params.data.fsm_id);
          return {
            handler: channelOpen
          };

        case 'timeout':
        case 'close_mutual':
          return {
            handler: channelOpen
          };

        case 'closing':
          changeStatus(channel, 'closing');
          return {
            handler: channelOpen
          };

        case 'closed_confirmed':
          changeStatus(channel, 'closed');
          return {
            handler: channelClosed
          };

        case 'died':
          changeStatus(channel, 'died');
          return {
            handler: channelClosed
          };

        case 'shutdown':
          return {
            handler: channelOpen
          };
      }

      break;

    case 'channels.on_chain_tx':
      emit(channel, 'onChainTx', message.params.data.tx, {
        info: message.params.data.info,
        type: message.params.data.type
      });
      return {
        handler: channelOpen
      };

    case 'channels.leave':
      // TODO: emit event
      return {
        handler: channelOpen
      };

    case 'channels.update':
      changeState(channel, message.params.data.state);
      return {
        handler: channelOpen
      };

    case 'channels.sign.shutdown_sign_ack':
      return awaitingTxSignRequest(channel, message, state);
  }
}

channelOpen.enter = channel => {
  changeStatus(channel, 'open');
};

async function awaitingOffChainTx(channel, message, state) {
  if (message.method === 'channels.sign.update') {
    const {
      sign
    } = state;

    if (message.params.data.tx != null) {
      const signedTx = await sign(message.params.data.tx, {
        updates: message.params.data.updates
      });
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingOffChainUpdate,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => sign(tx, {
      updates: message.params.data.updates
    }));

    if (typeof signedTx === 'string') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingOffChainUpdate,
        state
      };
    }

    if (typeof signedTx === 'number') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          error: signedTx
        }
      });
      return {
        handler: awaitingOffChainTx,
        state
      };
    }
  }

  if (message.method === 'channels.error') {
    state.reject(new ChannelConnectionError(message.data.message));
    return {
      handler: channelOpen
    };
  }

  if (message.error != null) {
    var _message$error;

    const {
      data
    } = (_message$error = message.error) !== null && _message$error !== void 0 ? _message$error : {
      data: []
    };

    if (data.find(i => i.code === 1001) != null) {
      state.reject(new InsufficientBalanceError('Insufficient balance'));
    } else if (data.find(i => i.code === 1002) != null) {
      state.reject(new IllegalArgumentError('Amount cannot be negative'));
    } else {
      state.reject(new ChannelConnectionError(message.error.message));
    }

    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingOffChainUpdate(channel, message, state) {
  if (message.method === 'channels.update') {
    changeState(channel, message.params.data.state);
    state.resolve({
      accepted: true,
      signedTx: message.params.data.state
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  if (message.error != null) {
    state.reject(new ChannelConnectionError(message.error.message));
    return {
      handler: channelOpen
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingTxSignRequest(channel, message, state) {
  var _message$method$match;

  const [, tag] = (_message$method$match = message.method.match(/^channels\.sign\.([^.]+)$/)) !== null && _message$method$match !== void 0 ? _message$method$match : [];
  const channelOptions = options.get(channel);

  if (tag != null && channelOptions != null) {
    if (message.params.data.tx != null) {
      const signedTx = await channelOptions.sign(tag, message.params.data.tx, {
        updates: message.params.data.updates
      });

      if (signedTx != null) {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: `channels.${tag}`,
          params: {
            tx: signedTx
          }
        });
        return {
          handler: channelOpen
        };
      }
    } else {
      const signedTx = await appendSignature(message.params.data.signed_tx, async tx => channelOptions.sign(tag, tx, {
        updates: message.params.data.updates
      }));

      if (typeof signedTx === 'string') {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: `channels.${tag}`,
          params: {
            signed_tx: signedTx
          }
        });
        return {
          handler: channelOpen
        };
      }

      if (typeof signedTx === 'number') {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: `channels.${tag}`,
          params: {
            error: signedTx
          }
        });
        return {
          handler: awaitingUpdateConflict,
          state
        };
      }
    } // soft-reject via competing update


    internal_send(channel, {
      jsonrpc: '2.0',
      method: 'channels.update.new',
      params: {
        from: generateKeyPair().publicKey,
        to: generateKeyPair().publicKey,
        amount: 1
      }
    });
    return {
      handler: awaitingUpdateConflict,
      state
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingUpdateConflict(channel, message, state) {
  if (message.error != null) {
    return {
      handler: awaitingUpdateConflict,
      state
    };
  }

  if (message.method === 'channels.conflict') {
    return {
      handler: channelOpen
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingShutdownTx(channel, message, state) {
  if (message.method === 'channels.sign.shutdown_sign') {
    if (message.params.data.tx != null) {
      const signedTx = await state.sign(message.params.data.tx);
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.shutdown_sign',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingShutdownOnChainTx,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => state.sign(tx));
    internal_send(channel, {
      jsonrpc: '2.0',
      method: 'channels.shutdown_sign',
      params: {
        signed_tx: signedTx
      }
    });
    return {
      handler: awaitingShutdownOnChainTx,
      state
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingShutdownOnChainTx(channel, message, state) {
  if (message.method === 'channels.on_chain_tx') {
    // state.resolve(message.params.data.tx)
    return {
      handler: channelClosed,
      state
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingLeave(channel, message, state) {
  if (message.method === 'channels.leave') {
    state.resolve({
      channelId: message.params.channel_id,
      signedTx: message.params.data.state
    });
    disconnect(channel);
    return {
      handler: channelClosed
    };
  }

  if (message.method === 'channels.error') {
    state.reject(new ChannelConnectionError(message.data.message));
    return {
      handler: channelOpen
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingWithdrawTx(channel, message, state) {
  if (message.method === 'channels.sign.withdraw_tx') {
    const {
      sign
    } = state;

    if (message.params.data.tx != null) {
      const signedTx = await sign(message.params.data.tx, {
        updates: message.params.data.updates
      });
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.withdraw_tx',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingWithdrawCompletion,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => sign(tx, {
      updates: message.params.data.updates
    }));

    if (typeof signedTx === 'string') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.withdraw_tx',
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingWithdrawCompletion,
        state
      };
    }

    if (typeof signedTx === 'number') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.withdraw_tx',
        params: {
          error: signedTx
        }
      });
      return {
        handler: awaitingWithdrawCompletion,
        state
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingWithdrawCompletion(channel, message, state) {
  if (message.method === 'channels.on_chain_tx') {
    var _state$onOnChainTx;

    (_state$onOnChainTx = state.onOnChainTx) === null || _state$onOnChainTx === void 0 ? void 0 : _state$onOnChainTx.call(state, message.params.data.tx);
    return {
      handler: awaitingWithdrawCompletion,
      state
    };
  }

  if (message.method === 'channels.info') {
    var _context2;

    if (includes_default()(_context2 = ['own_withdraw_locked', 'withdraw_locked']).call(_context2, message.params.data.event)) {
      var _callbacks$message$pa;

      const callbacks = {
        own_withdraw_locked: state.onOwnWithdrawLocked,
        withdraw_locked: state.onWithdrawLocked
      };
      (_callbacks$message$pa = callbacks[message.params.data.event]) === null || _callbacks$message$pa === void 0 ? void 0 : _callbacks$message$pa.call(callbacks);
      return {
        handler: awaitingWithdrawCompletion,
        state
      };
    }
  }

  if (message.method === 'channels.update') {
    changeState(channel, message.params.data.state);
    state.resolve({
      accepted: true,
      signedTx: message.params.data.state
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingDepositTx(channel, message, state) {
  if (message.method === 'channels.sign.deposit_tx') {
    const {
      sign
    } = state;

    if (message.params.data.tx != null) {
      const signedTx = await sign(message.params.data.tx, {
        updates: message.params.data.updates
      });
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.deposit_tx',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingDepositCompletion,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => sign(tx, {
      updates: message.params.data.updates
    }));

    if (typeof signedTx === 'string') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.deposit_tx',
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingDepositCompletion,
        state
      };
    }

    if (typeof signedTx === 'number') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.deposit_tx',
        params: {
          error: signedTx
        }
      });
      return {
        handler: awaitingDepositCompletion,
        state
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingDepositCompletion(channel, message, state) {
  if (message.method === 'channels.on_chain_tx') {
    var _state$onOnChainTx2;

    (_state$onOnChainTx2 = state.onOnChainTx) === null || _state$onOnChainTx2 === void 0 ? void 0 : _state$onOnChainTx2.call(state, message.params.data.tx);
    return {
      handler: awaitingDepositCompletion,
      state
    };
  }

  if (message.method === 'channels.info') {
    var _context3;

    if (includes_default()(_context3 = ['own_deposit_locked', 'deposit_locked']).call(_context3, message.params.data.event)) {
      var _callbacks$message$pa2;

      const callbacks = {
        own_deposit_locked: state.onOwnDepositLocked,
        deposit_locked: state.onDepositLocked
      };
      (_callbacks$message$pa2 = callbacks[message.params.data.event]) === null || _callbacks$message$pa2 === void 0 ? void 0 : _callbacks$message$pa2.call(callbacks);
      return {
        handler: awaitingDepositCompletion,
        state
      };
    }
  }

  if (message.method === 'channels.update') {
    changeState(channel, message.params.data.state);
    state.resolve({
      accepted: true,
      signedTx: message.params.data.state
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingNewContractTx(channel, message, state) {
  if (message.method === 'channels.sign.update') {
    if (message.params.data.tx != null) {
      const signedTx = await state.sign(message.params.data.tx);
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingNewContractCompletion,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => state.sign(tx));

    if (typeof signedTx === 'string') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingNewContractCompletion,
        state
      };
    }

    if (typeof signedTx === 'number') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          error: signedTx
        }
      });
      return {
        handler: awaitingNewContractCompletion,
        state
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingNewContractCompletion(channel, message, state) {
  const channelOptions = options.get(channel);

  if (message.method === 'channels.update') {
    const {
      round
    } = unpackTx(message.params.data.state, Tag.SignedTx).tx.encodedTx.tx;

    if ((channelOptions === null || channelOptions === void 0 ? void 0 : channelOptions.role) != null) {
      let role = null;
      if (channelOptions.role === 'initiator') role = 'initiatorId';
      if (channelOptions.role === 'responder') role = 'responderId';

      if (role != null) {
        const owner = channelOptions === null || channelOptions === void 0 ? void 0 : channelOptions[role];
        changeState(channel, message.params.data.state);
        state.resolve({
          accepted: true,
          address: encodeContractAddress(owner, round),
          signedTx: message.params.data.state
        });
        return {
          handler: channelOpen
        };
      }
    }
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingCallContractUpdateTx(channel, message, state) {
  if (message.method === 'channels.sign.update') {
    if (message.params.data.tx != null) {
      const signedTx = await state.sign(message.params.data.tx, {
        updates: message.params.data.updates
      });
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          tx: signedTx
        }
      });
      return {
        handler: awaitingCallContractCompletion,
        state
      };
    }

    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => state.sign(tx, {
      updates: message.params.data.updates
    }));

    if (typeof signedTx === 'string') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          signed_tx: signedTx
        }
      });
      return {
        handler: awaitingCallContractCompletion,
        state
      };
    }

    if (typeof signedTx === 'number') {
      internal_send(channel, {
        jsonrpc: '2.0',
        method: 'channels.update',
        params: {
          error: signedTx
        }
      });
      return {
        handler: awaitingCallContractCompletion,
        state
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingCallContractForceProgressUpdate(channel, message, state) {
  if (message.method === 'channels.sign.force_progress_tx') {
    const signedTx = await appendSignature(message.params.data.signed_tx, async tx => state.sign(tx, {
      updates: message.params.data.updates
    }));
    internal_send(channel, {
      jsonrpc: '2.0',
      method: 'channels.force_progress_sign',
      params: {
        signed_tx: signedTx
      }
    });
    return {
      handler: awaitingForceProgressCompletion,
      state
    };
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingForceProgressCompletion(channel, message, state) {
  if (message.method === 'channels.on_chain_tx') {
    var _state$onOnChainTx3;

    (_state$onOnChainTx3 = state.onOnChainTx) === null || _state$onOnChainTx3 === void 0 ? void 0 : _state$onOnChainTx3.call(state, message.params.data.tx);
    emit(channel, 'onChainTx', message.params.data.tx, {
      info: message.params.data.info,
      type: message.params.data.type
    });
    state.resolve({
      accepted: true,
      tx: message.params.data.tx
    });
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingCallContractCompletion(channel, message, state) {
  if (message.method === 'channels.update') {
    changeState(channel, message.params.data.state);
    state.resolve({
      accepted: true,
      signedTx: message.params.data.state
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }

  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }

  return handleUnexpectedMessage(channel, message, state);
}
function awaitingCallsPruned(_channels, message, state) {
  if (message.method === 'channels.calls_pruned.reply') {
    state.resolve();
    return {
      handler: channelOpen
    };
  }

  state.reject(new UnexpectedChannelMessageError('Unexpected message received'));
  return {
    handler: channelClosed
  };
}
function channelClosed(_channel, message, state) {
  if (state == null) return {
    handler: channelClosed
  };
  if (message.params.data.event === 'closing') return {
    handler: channelClosed,
    state
  };

  if (message.params.data.info === 'channel_closed') {
    state.closeTx = message.params.data.tx;
    return {
      handler: channelClosed,
      state
    };
  }

  if (message.params.data.event === 'closed_confirmed') {
    state.resolve(state.closeTx);
    return {
      handler: channelClosed
    };
  }

  return {
    handler: channelClosed,
    state
  };
}
;// CONCATENATED MODULE: ./src/channel/index.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */








function snakeToPascalObjKeys(obj) {
  return Object.entries(obj).reduce((result, _ref) => {
    let [key, val] = _ref;
    return { ...result,
      [snakeToPascal(key)]: val
    };
  }, {});
}

/**
 * Channel
 * @example
 * ```js
 * await Channel.initialize({
 *   url: 'ws://localhost:3001',
 *   role: 'initiator'
 *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
 *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
 *   initiatorAmount: 1e18,
 *   responderAmount: 1e18,
 *   pushAmount: 0,
 *   channelReserve: 0,
 *   ttl: 1000,
 *   host: 'localhost',
 *   port: 3002,
 *   lockPeriod: 10,
 *   async sign (tag, tx) => await account.signTransaction(tx)
 * })
 * ```
 */
class channel_Channel {
  /**
   * @param options - Channel params
   * @param options.url - Channel url (for example: "ws://localhost:3001")
   * @param options.role - Participant role ("initiator" or "responder")
   * @param options.initiatorId - Initiator's public key
   * @param options.responderId - Responder's public key
   * @param options.pushAmount - Initial deposit in favour of the responder by the initiator
   * @param options.initiatorAmount - Amount of coins the initiator has committed to
   * the channel
   * @param options.responderAmount - Amount of coins the responder has committed to
   * the channel
   * @param options.channelReserve - The minimum amount both peers need to maintain
   * @param options.ttl - Minimum block height to include the channel_create_tx
   * @param options.host - Host of the responder's node
   * @param options.port - The port of the responders node
   * @param options.lockPeriod - Amount of blocks for disputing a solo close
   * @param options.existingChannelId - Existing channel id (required if reestablishing a
   * channel)
   * @param options.offchainTx - Offchain transaction (required if reestablishing
   * a channel)
   * @param options.timeoutIdle - The time waiting for a new event to be initiated
   * (default: 600000)
   * @param options.timeoutFundingCreate - The time waiting for the initiator to produce
   * the create channel transaction after the noise session had been established (default: 120000)
   * @param options.timeoutFundingSign - The time frame the other client has to sign an
   * off-chain update after our client had initiated and signed it. This applies only for double
   * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.
   * (default: 120000)
   * @param options.timeoutFundingLock - The time frame the other client has to confirm an
   * on-chain transaction reaching maturity (passing minimum depth) after the local node has
   * detected this. This applies only for double signed on-chain intended updates: channel create
   * transaction, deposit, withdrawal and etc. (default: 360000)
   * @param options.timeoutSign - The time frame the client has to return a signed
   * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)
   * @param options.timeoutAccept - The time frame the other client has to react to an
   * event. This applies for all off-chain updates that are not meant to land on-chain, as well as
   * some special cases: opening a noise connection, mutual closing acknowledgement and
   * reestablishing an existing channel (default: 120000)
   * @param options.timeoutInitialized - the time frame the responder has to accept an
   * incoming noise session. Applicable only for initiator (default: timeout_accept's value)
   * @param options.timeoutAwaitingOpen - The time frame the initiator has to start an
   * outgoing noise session to the responder's node. Applicable only for responder (default:
   * timeout_idle's value)
   * @param options.debug=false - Log websocket communication
   * @param options.sign - Function which verifies and signs transactions
   */
  static async initialize(options) {
    const channel = new channel_Channel();
    await initialize(channel, options.existingFsmId != null ? awaitingReconnection : awaitingConnection, channelOpen, options);
    return channel;
  }
  /**
   * Register event listener function
   *
   * Possible events:
   *
   *   - "error"
   *   - "onChainTx"
   *   - "ownWithdrawLocked"
   *   - "withdrawLocked"
   *   - "ownDepositLocked"
   *   - "depositLocked"
   *
   * TODO: the event list looks outdated
   *
   * @param eventName - Event name
   * @param callback - Callback function
   */
  // TODO define specific callback type depending on the event name


  on(eventName, callback) {
    const eventEmitter = eventEmitters.get(this);
    if (eventEmitter == null) throw new UnknownChannelStateError();
    eventEmitter.on(eventName, callback);
  }
  /**
   * Remove event listener function
   * @param eventName - Event name
   * @param callback - Callback function
   */


  off(eventName, callback) {
    const eventEmitter = eventEmitters.get(this);
    if (eventEmitter == null) throw new UnknownChannelStateError();
    eventEmitter.removeListener(eventName, callback);
  }
  /**
   * Close the connection
   */


  disconnect() {
    return disconnect(this);
  }
  /**
   * Get current status
   *
   */


  status() {
    const status = internal_status.get(this);
    if (status == null) throw new UnknownChannelStateError();
    return status;
  }
  /**
   * Get current state
   */


  async state() {
    return snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}));
  }
  /**
   * Get current round
   *
   * If round cannot be determined (for example when channel has not been opened)
   * it will return `null`.
   *
   */


  round() {
    const state = internal_state.get(this);

    if (state == null) {
      return null;
    }

    const {
      txType,
      tx
    } = unpackTx(state, Tag.SignedTx).tx.encodedTx;

    switch (txType) {
      case Tag.ChannelCreateTx:
        return 1;

      case Tag.ChannelOffChainTx:
      case Tag.ChannelWithdrawTx:
      case Tag.ChannelDepositTx:
        return tx.round;

      default:
        return null;
    }
  }
  /**
   * Get channel id
   *
   */


  id() {
    const id = channelId.get(this);
    if (id == null) throw new ChannelError('Channel is not initialized');
    return id;
  }
  /**
   * Get channel's fsm id
   *
   */


  fsmId() {
    const id = fsmId.get(this);
    if (id == null) throw new ChannelError('Channel is not initialized');
    return id;
  }
  /**
   * Trigger a transfer update
   *
   * The transfer update is moving coins from one channel account to another.
   * The update is a change to be applied on top of the latest state.
   *
   * Sender and receiver are the channel parties. Both the initiator and responder
   * can take those roles. Any public key outside the channel is considered invalid.
   *
   * @param from - Sender's public address
   * @param to - Receiver's public address
   * @param amount - Transaction amount
   * @param sign - Function which verifies and signs offchain transaction
   * @param metadata - Metadata
    * @example
   * ```js
   * channel.update(
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
   *   10,
   *   async (tx) => await account.signTransaction(tx)
   * ).then(({ accepted, signedTx }) =>
   *   if (accepted) {
   *     console.log('Update has been accepted')
   *   }
   * )
   * ```
   */


  async update(from, to, amount, sign) {
    let metadata = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.update.new',
          params: {
            from,
            to,
            amount,
            meta: metadata
          }
        });
        return {
          handler: awaitingOffChainTx,
          state: {
            resolve,
            reject,
            sign
          }
        };
      });
    });
  }
  /**
   * Get proof of inclusion
   *
   * If a certain address of an account or a contract is not found
   * in the state tree - the response is an error.
   *
   * @param addresses - Addresses
   * @param addresses.accounts - List of account addresses to include in poi
   * @param addresses.contracts - List of contract addresses to include in poi
   * @example
   * ```js
   * channel.poi({
   *   accounts: [
   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   ],
   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']
   * }).then(poi => console.log(poi))
   * ```
   */


  async poi(_ref2) {
    let {
      accounts,
      contracts
    } = _ref2;
    return (await call(this, 'channels.get.poi', {
      accounts,
      contracts
    })).poi;
  }
  /**
   * Get balances
   *
   * The accounts param contains a list of addresses to fetch balances of.
   * Those can be either account balances or a contract ones, encoded as an account addresses.
   *
   * If a certain account address had not being found in the state tree - it is simply
   * skipped in the response.
   *
   * @param accounts - List of addresses to fetch balances from
   * @example
   * ```js
   * channel.balances([
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'
   * ]).then(balances =>
   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])
   * )
   * ```
   */


  async balances(accounts) {
    return Object.fromEntries((await call(this, 'channels.get.balances', {
      accounts
    })).map(item => [item.account, item.balance]));
  }
  /**
   * Leave channel
   *
   * It is possible to leave a channel and then later reestablish the channel
   * off-chain state and continue operation. When a leave method is called,
   * the channel fsm passes it on to the peer fsm, reports the current mutually
   * signed state and then terminates.
   *
   * The channel can be reestablished by instantiating another Channel instance
   * with two extra params: existingChannelId and offchainTx (returned from leave
   * method as channelId and signedTx respectively).
   *
   * @example
   * ```js
   * channel.leave().then(({ channelId, signedTx }) => {
   *   console.log(channelId)
   *   console.log(signedTx)
   * })
   * ```
   */


  async leave() {
    return new Promise((resolve, reject) => {
      enqueueAction(this, (channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.leave',
          params: {}
        });
        return {
          handler: awaitingLeave,
          state: {
            resolve,
            reject
          }
        };
      });
    });
  }
  /**
   * Trigger mutual close
   *
   * At any moment after the channel is opened, a closing procedure can be triggered.
   * This can be done by either of the parties. The process is similar to the off-chain updates.
   *
   * @param sign - Function which verifies and signs mutual close transaction
   * @example
   * ```js
   * channel.shutdown(
   *   async (tx) => await account.signTransaction(tx)
   * ).then(tx => console.log('on_chain_tx', tx))
   * ```
   */


  async shutdown(sign) {
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.shutdown',
          params: {}
        });
        return {
          handler: awaitingShutdownTx,
          state: {
            sign,
            resolve,
            reject
          }
        };
      });
    });
  }
  /**
   * Withdraw coins from the channel
   *
   * After the channel had been opened any of the participants can initiate a withdrawal.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a withdrawal. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the withdraw transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onWithdrawLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to withdraw
   * @param sign - Function which verifies and signs withdraw transaction
   * @param callbacks - Callbacks
   * @param callbacks.onOnChainTx - Called when withdraw transaction has been posted
   * on chain
   * @param callbacks.onOwnWithdrawLocked
   * @param callbacks.onWithdrawLocked
   * @example
   * ```js
   * channel.withdraw(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Withdrawal has been accepted')
   *   } else {
   *     console.log('Withdrawal has been rejected')
   *   }
   * })
   * ```
   */


  async withdraw(amount, sign) {
    let {
      onOnChainTx,
      onOwnWithdrawLocked,
      onWithdrawLocked
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.withdraw',
          params: {
            amount
          }
        });
        return {
          handler: awaitingWithdrawTx,
          state: {
            sign,
            resolve,
            reject,
            onOnChainTx,
            onOwnWithdrawLocked,
            onWithdrawLocked
          }
        };
      });
    });
  }
  /**
   * Deposit coins into the channel
   *
   * After the channel had been opened any of the participants can initiate a deposit.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_deposit_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a deposit. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The deposit amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the deposit transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnDepositLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onDepositLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to deposit
   * @param sign - Function which verifies and signs deposit transaction
   * @param callbacks - Callbacks
   * @param callbacks.onOnChainTx - Called when deposit transaction has been posted
   * on chain
   * @param callbacks.onOwnDepositLocked
   * @param callbacks.onDepositLocked
   * @example
   * ```js
   * channel.deposit(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, state }) => {
   *   if (accepted) {
   *     console.log('Deposit has been accepted')
   *     console.log('The new state is:', state)
   *   } else {
   *     console.log('Deposit has been rejected')
   *   }
   * })
   * ```
   */


  async deposit(amount, sign) {
    let {
      onOnChainTx,
      onOwnDepositLocked,
      onDepositLocked
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.deposit',
          params: {
            amount
          }
        });
        return {
          handler: awaitingDepositTx,
          state: {
            sign,
            resolve,
            reject,
            onOnChainTx,
            onOwnDepositLocked,
            onDepositLocked
          }
        };
      });
    });
  }
  /**
   * Trigger create contract update
   *
   * The create contract update is creating a contract inside the channel's internal state tree.
   * The update is a change to be applied on top of the latest state.
   *
   * That would create a contract with the poster being the owner of it. Poster commits initially
   * a deposit amount of coins to the new contract.
   *
   * @param options - Options
   * @param options.code - Api encoded compiled AEVM byte code
   * @param options.callData - Api encoded compiled AEVM call data for the code
   * @param options.deposit - Initial amount the owner of the contract commits to it
   * @param options.vmVersion - Version of the Virtual Machine
   * @param options.abiVersion - Version of the Application Binary Interface
   * @param sign - Function which verifies and signs create contract transaction
   * @example
   * ```js
   * channel.createContract({
   *   code: 'cb_HKtpipK4aCgYb17wZ...',
   *   callData: 'cb_1111111111111111...',
   *   deposit: 10,
   *   vmVersion: 3,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx, address }) => {
   *   if (accepted) {
   *     console.log('New contract has been created')
   *     console.log('Contract address:', address)
   *   } else {
   *     console.log('New contract has been rejected')
   *   }
   * })
   * ```
   */


  async createContract(_ref3, sign) {
    let {
      code,
      callData,
      deposit,
      vmVersion,
      abiVersion
    } = _ref3;
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.update.new_contract',
          params: {
            code,
            call_data: callData,
            deposit,
            vm_version: vmVersion,
            abi_version: abiVersion
          }
        });
        return {
          handler: awaitingNewContractTx,
          state: {
            sign,
            resolve,
            reject
          }
        };
      });
    });
  }
  /**
   * Trigger call a contract update
   *
   * The call contract update is calling a preexisting contract inside the channel's
   * internal state tree. The update is a change to be applied on top of the latest state.
   *
   * That would call a contract with the poster being the caller of it. Poster commits
   * an amount of coins to the contract.
   *
   * The call would also create a call object inside the channel state tree. It contains
   * the result of the contract call.
   *
   * It is worth mentioning that the gas is not consumed, because this is an off-chain
   * contract call. It would be consumed if it were an on-chain one. This could happen
   * if a call with a similar computation amount is to be forced on-chain.
   *
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @param sign - Function which verifies and signs contract call transaction
   * @example
   * ```js
   * channel.callContract({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract called succesfully')
   *   } else {
   *     console.log('Contract call has been rejected')
   *   }
   * })
   * ```
   */


  async callContract(_ref4, sign) {
    let {
      amount,
      callData,
      contract,
      abiVersion
    } = _ref4;
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.update.call_contract',
          params: {
            amount,
            call_data: callData,
            contract_id: contract,
            abi_version: abiVersion
          }
        });
        return {
          handler: awaitingCallContractUpdateTx,
          state: {
            resolve,
            reject,
            sign
          }
        };
      });
    });
  }
  /**
   * Trigger a force progress contract call
   * This call is going on-chain
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @param options.gasPrice=1000000000]
   * @param options.gasLimit=1000000]
   * @param sign - Function which verifies and signs contract force progress transaction
   * @param callbacks - Callbacks
   * @example
   * ```js
   * channel.forceProgress({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1,
   *   gasPrice: 1000005554
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract force progress call successful')
   *   } else {
   *     console.log('Contract force progress call has been rejected')
   *   }
   * })
   * ```
   */


  async forceProgress(_ref5, sign) {
    let {
      amount,
      callData,
      contract,
      abiVersion,
      gasLimit = 1000000,
      gasPrice = MIN_GAS_PRICE
    } = _ref5;
    let {
      onOnChainTx
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.force_progress',
          params: {
            amount,
            call_data: callData,
            contract_id: contract,
            abi_version: abiVersion,
            gas_price: gasPrice,
            gas: gasLimit
          }
        });
        return {
          handler: awaitingCallContractForceProgressUpdate,
          state: {
            resolve,
            reject,
            sign,
            onOnChainTx
          }
        };
      });
    });
  }
  /**
   * Call contract using dry-run
   *
   * In order to get the result of a potential contract call, one might need to
   * dry-run a contract call. It takes the exact same arguments as a call would
   * and returns the call object.
   *
   * The call is executed in the channel's state, but it does not impact the state
   * whatsoever. It uses as an environment the latest channel's state and the current
   * top of the blockchain as seen by the node.
   *
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @example
   * ```js
   * channel.callContractStatic({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ returnValue, gasUsed }) => {
   *   console.log('Returned value:', returnValue)
   *   console.log('Gas used:', gasUsed)
   * })
   * ```
   */


  async callContractStatic(_ref6) {
    let {
      amount,
      callData,
      contract,
      abiVersion
    } = _ref6;
    return snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {
      amount,
      call_data: callData,
      contract_id: contract,
      abi_version: abiVersion
    }));
  }
  /**
   * Get contract call result
   *
   * The combination of a caller, contract and a round of execution determines the
   * contract call. Providing an incorrect set of those results in an error response.
   *
   * @param options - Options
   * @param options.caller - Address of contract caller
   * @param options.contract - Address of the contract
   * @param options.round - Round when contract was called
   * @example
   * ```js
   * channel.getContractCall({
   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   round: 3
   * }).then(({ returnType, returnValue }) => {
   *   if (returnType === 'ok') console.log(returnValue)
   * })
   * ```
   */


  async getContractCall(_ref7) {
    let {
      caller,
      contract,
      round
    } = _ref7;
    return snakeToPascalObjKeys(await call(this, 'channels.get.contract_call', {
      caller_id: caller,
      contract_id: contract,
      round
    }));
  }
  /**
   * Get the latest contract state
   *
   * @param contract - Address of the contract
   * @example
   * ```js
   * channel.getContractState(
   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'
   * ).then(({ contract }) => {
   *   console.log('deposit:', contract.deposit)
   * })
   * ```
   */


  async getContractState(contract) {
    const result = await call(this, 'channels.get.contract', {
      pubkey: contract
    });
    return snakeToPascalObjKeys({ ...result,
      contract: snakeToPascalObjKeys(result.contract)
    });
  }
  /**
   * Clean up all locally stored contract calls
   *
   * Contract calls are kept locally in order for the participant to be able to look them up.
   * They consume memory and in order for the participant to free it - one can prune all messages.
   * This cleans up all locally stored contract calls and those will no longer be available for
   * fetching and inspection.
   */


  async cleanContractCalls() {
    return new Promise((resolve, reject) => {
      enqueueAction(this, (_channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, channel => {
        internal_send(channel, {
          jsonrpc: '2.0',
          method: 'channels.clean_contract_calls',
          params: {}
        });
        return {
          handler: awaitingCallsPruned,
          state: {
            resolve,
            reject
          }
        };
      });
    });
  }
  /**
   * Send generic message
   *
   * If message is an object it will be serialized into JSON string
   * before sending.
   *
   * If there is ongoing update that has not yet been finished the message
   * will be sent after that update is finalized.
   *
   * @param message - Message
   * @param recipient - Address of the recipient
   * @example
   * ```js
   * channel.sendMessage(
   *   'hello world',
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'
   * )
   * ```
   */


  async sendMessage(message, recipient) {
    const info = typeof message === 'object' ? JSON.stringify(message) : message;

    if (this.status() === 'connecting') {
      await new Promise(resolve => {
        const onStatusChanged = status => {
          if (status === 'connecting') return;
          resolve();
          this.off('statusChanged', onStatusChanged);
        };

        this.on('statusChanged', onStatusChanged);
      }); // For some reason we can't immediately send a message when connection is
      // established. Thus we wait 500ms which seems to work.

      await pause(500);
    }

    internal_send(this, {
      jsonrpc: '2.0',
      method: 'channels.message',
      params: {
        info,
        to: recipient
      }
    });
  }

  static async reconnect(options, txParams) {
    const {
      sign
    } = options;
    return channel_Channel.initialize({ ...options,
      reconnectTx: await sign('reconnect', buildTx(txParams, Tag.ChannelClientReconnectTx).tx)
    });
  }

}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection-proxy.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Browser connection proxy
 * Provide functionality to easily forward messages from one connection to another and back
 * @category aepp wallet communication
 * @param con1 - first connection
 * @param con2 - second connection
 * @returns a function to stop proxying
 */
/* harmony default export */ const connection_proxy = ((con1, con2) => {
  con1.connect(msg => con2.sendMessage(msg), () => con2.disconnect());
  con2.connect(msg => con1.sendMessage(msg), () => con1.disconnect());
  return () => {
    con1.disconnect();
    con2.disconnect();
  };
});
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/Browser.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Browser connection base interface
 * @category aepp wallet communication
 */

class BrowserConnection {
  constructor(_ref) {
    let {
      debug = false
    } = _ref;
    this.debug = debug;
  }
  /**
   * Connect
   * @param onMessage - Message handler
   * @param onDisconnect - trigger when runtime connection in closed
   */


  connect( // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMessage, // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDisconnect) {
    if (this.isConnected()) throw new AlreadyConnectedError('You already connected');
  }
  /**
   * Disconnect
   */


  disconnect() {
    if (!this.isConnected()) throw new NoWalletConnectedError('You dont have connection. Please connect before');
  }
  /**
   * Receive message
   */


  receiveMessage(message) {
    if (this.debug) console.log('Receive message:', message);
  }
  /**
   * Send message
   */


  sendMessage(message) {
    if (this.debug) console.log('Send message:', message);
  }
  /**
   * Check if connected
   * @returns Is connected
   */


}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/BrowserWindowMessage.ts



function BrowserWindowMessage_classPrivateFieldInitSpec(obj, privateMap, value) { BrowserWindowMessage_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function BrowserWindowMessage_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */




var _onDisconnect = /*#__PURE__*/new WeakMap();

var _target = /*#__PURE__*/new WeakMap();

var _self = /*#__PURE__*/new WeakMap();

/**
 * Browser window Post Message connector module
 * @category aepp wallet communication
 */
class BrowserWindowMessageConnection extends BrowserConnection {
  /**
   * @param options - Options
   * @param options.target Target window for message
   * @param options.self Host window for message
   * @param options.origin Origin of receiver
   * @param options.sendDirection Wrapping messages into additional struct
   * `({ type: 'to_aepp' || 'to_waellet', data })`
   * Used for handling messages between content script and page
   * @param options.receiveDirection Unwrapping messages from additional struct
   */
  constructor() {
    let {
      target,
      self = window,
      origin,
      sendDirection,
      receiveDirection = MESSAGE_DIRECTION.to_aepp,
      ...options
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(options);

    BrowserWindowMessage_classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: void 0
    });

    BrowserWindowMessage_classPrivateFieldInitSpec(this, _target, {
      writable: true,
      value: void 0
    });

    BrowserWindowMessage_classPrivateFieldInitSpec(this, _self, {
      writable: true,
      value: void 0
    });

    classPrivateFieldSet_default()(this, _target, target);

    classPrivateFieldSet_default()(this, _self, self);

    this.origin = origin;
    this.sendDirection = sendDirection;
    this.receiveDirection = receiveDirection;
  }

  isConnected() {
    return this.listener != null;
  }

  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);

    this.listener = message => {
      var _message$data$jsonrpc, _message$data$data;

      // TODO: strict validate origin and source instead of checking message structure
      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : (_message$data$data = message.data.data) === null || _message$data$data === void 0 ? void 0 : _message$data$data.jsonrpc) !== '2.0') return;
      if (this.origin != null && this.origin !== message.origin) return;
      if (classPrivateFieldGet_default()(this, _target) != null && classPrivateFieldGet_default()(this, _target) !== message.source) return;
      this.receiveMessage(message);
      let {
        data
      } = message;

      if (data.type != null) {
        if (message.data.type !== this.receiveDirection) return;
        data = data.data;
      }

      onMessage(data, message.origin, message.source);
    };

    classPrivateFieldGet_default()(this, _self).addEventListener('message', this.listener);

    classPrivateFieldSet_default()(this, _onDisconnect, onDisconnect);
  }

  disconnect() {
    super.disconnect();

    if (this.listener == null || classPrivateFieldGet_default()(this, _onDisconnect) == null) {
      throw new InternalError('Expected to not happen, required for TS');
    }

    classPrivateFieldGet_default()(this, _self).removeEventListener('message', this.listener);

    delete this.listener;

    classPrivateFieldGet_default()(this, _onDisconnect).call(this);

    classPrivateFieldSet_default()(this, _onDisconnect, undefined);
  }

  sendMessage(msg) {
    var _this$origin;

    if (classPrivateFieldGet_default()(this, _target) == null) throw new RpcConnectionError('Can\'t send messages without target');
    const message = this.sendDirection != null ? {
      type: this.sendDirection,
      data: msg
    } : msg;
    super.sendMessage(message);

    classPrivateFieldGet_default()(this, _target).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');
  }

}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/wallet-detector.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */




/**
 * A function to detect available wallets
 * @category aepp wallet communication
 * @param connection - connection to use to detect wallets
 * @param onDetected - call-back function which trigger on new wallet
 * @returns a function to stop scanning
 */
/* harmony default export */ const wallet_detector = ((connection, onDetected) => {
  if (window == null) throw new UnsupportedPlatformError('Window object not found, you can run wallet detector only in browser');
  const wallets = {};
  connection.connect((_ref, origin, source) => {
    let {
      method,
      params
    } = _ref;
    if (method !== METHODS.readyToConnect || wallets[params.id] != null) return;
    const wallet = {
      info: params,

      getConnection() {
        const isExtension = params.type === 'extension';
        return new BrowserWindowMessageConnection({
          sendDirection: isExtension ? MESSAGE_DIRECTION.to_waellet : undefined,
          receiveDirection: isExtension ? MESSAGE_DIRECTION.to_aepp : undefined,
          target: source,
          origin: isExtension ? window.origin : params.origin
        });
      }

    };
    wallets[wallet.info.id] = wallet;
    onDetected({
      wallets,
      newWallet: wallet
    });
  }, () => {});
  if (Object.keys(wallets).length > 0) onDetected({
    wallets
  });
  return () => connection.disconnect();
});
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/BrowserRuntime.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * BrowserRuntimeConnection
 * Handle browser runtime communication
 * @category aepp wallet communication
 */

class BrowserRuntimeConnection extends BrowserConnection {
  constructor(_ref) {
    let {
      port,
      ...options
    } = _ref;
    super(options);
    this.port = port;
  }

  disconnect() {
    super.disconnect();
    this.port.disconnect();
  }

  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    this.port.onMessage.addListener((message, port) => {
      this.receiveMessage(message);
      onMessage(message, port.name, port);
    });
    this.port.onDisconnect.addListener(onDisconnect);
  }

  sendMessage(message) {
    super.sendMessage(message);
    this.port.postMessage(message);
  }

  isConnected() {
    return this.port.onMessage.hasListeners();
  }

}
;// CONCATENATED MODULE: ./src/index.ts
/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */



































})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=aepp-sdk.js.map