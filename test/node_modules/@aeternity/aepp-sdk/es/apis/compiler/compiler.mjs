import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import * as Parameters from "./models/parameters.mjs";
import * as Mappers from "./models/mappers.mjs";
export class Compiler extends coreClient.ServiceClient {
  /**
   * Initializes a new instance of the Compiler class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint, _options;

    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    } // Initializing default values for options


    if (!options) {
      options = {};
    }

    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-compiler/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = { ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      baseUri: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);

    if ((_options = options) !== null && _options !== void 0 && _options.pipeline && options.pipeline.getOrderedPolicies().length > 0) {
      const pipelinePolicies = options.pipeline.getOrderedPolicies();
      const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some(pipelinePolicy => pipelinePolicy.name === coreRestPipeline.bearerTokenAuthenticationPolicyName);

      if (!bearerTokenAuthenticationPolicyFound) {
        this.pipeline.removePolicy({
          name: coreRestPipeline.bearerTokenAuthenticationPolicyName
        });
        this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          scopes: `${optionsWithDefaults.baseUri}/.default`,
          challengeCallbacks: {
            authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge
          }
        }));
      }
    } // Parameter assignments


    this.$host = $host;
  }
  /**
   * Generate an Aeternity Contract Interface (ACI) for contract
   * @param body contract code
   * @param options The options parameters.
   */


  generateACI(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, generateACIOperationSpec);
  }
  /**
   * Get the Api description
   * @param options The options parameters.
   */


  api(options) {
    return this.sendOperationRequest({
      options
    }, apiOperationSpec);
  }
  /**
   * Get the version of the API
   * @param options The options parameters.
   */


  aPIVersion(options) {
    return this.sendOperationRequest({
      options
    }, aPIVersionOperationSpec);
  }
  /**
   * Compile a sophia contract from source and return byte code
   * @param body contract code
   * @param options The options parameters.
   */


  compileContract(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, compileContractOperationSpec);
  }
  /**
   * Extract compiler version from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */


  getCompilerVersion(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getCompilerVersionOperationSpec);
  }
  /**
   * Decode the result of contract call
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */


  decodeCallResult(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultOperationSpec);
  }
  /**
   * Decode the result of contract call from Bytecode
   * @param body Call result + compiled contract
   * @param options The options parameters.
   */


  decodeCallResultBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultBytecodeOperationSpec);
  }
  /**
   * Identify function name and arguments in Calldata for a compiled contract
   * @param body Calldata + compiled contract
   * @param options The options parameters.
   */


  decodeCalldataBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataBytecodeOperationSpec);
  }
  /**
   * Identify function name and arguments in Calldata for a (partial) contract
   * @param body Calldata + contract (stub) code
   * @param options The options parameters.
   */


  decodeCalldataSource(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataSourceOperationSpec);
  }
  /**
   * Decode data as retuned by a contract call. - Legacy decoding
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */


  decodeData(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeDataOperationSpec);
  }
  /**
   * Encode Sophia function call according to sophia ABI.
   * @param body Sophia function call - contract code + function name + arguments
   * @param options The options parameters.
   */


  encodeCalldata(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, encodeCalldataOperationSpec);
  }
  /**
   * Get FATE assembler code from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */


  getFateAssemblerCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getFateAssemblerCodeOperationSpec);
  }
  /**
   * Verify that an encoded byte array is the result of compiling a given contract
   * @param body contract byte array and source code
   * @param options The options parameters.
   */


  validateByteCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, validateByteCodeOperationSpec);
  }
  /**
   * Get the version of the underlying Sophia compiler version
   * @param options The options parameters.
   */


  version(options) {
    return this.sendOperationRequest({
      options
    }, versionOperationSpec);
  }

} // Operation Specifications

const serializer = coreClient.createSerializer(Mappers,
/* isXml */
false);
const generateACIOperationSpec = {
  path: "/aci",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Aci
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const apiOperationSpec = {
  path: "/api",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    },
    400: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const aPIVersionOperationSpec = {
  path: "/api-version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.APIVersion
    },
    500: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const compileContractOperationSpec = {
  path: "/compile",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ByteCode
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getCompilerVersionOperationSpec = {
  path: "/compiler-version",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.CompilerVersion
    },
    400: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  requestBody: Parameters.body1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decodeCallResultOperationSpec = {
  path: "/decode-call-result",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "any"
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body2,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decodeCallResultBytecodeOperationSpec = {
  path: "/decode-call-result/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DecodedCallresult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body3,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decodeCalldataBytecodeOperationSpec = {
  path: "/decode-calldata/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DecodedCalldata
    },
    400: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  requestBody: Parameters.body4,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decodeCalldataSourceOperationSpec = {
  path: "/decode-calldata/source",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DecodedCalldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body5,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decodeDataOperationSpec = {
  path: "/decode-data",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.SophiaJsonData
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body6,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const encodeCalldataOperationSpec = {
  path: "/encode-calldata",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Calldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body7,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getFateAssemblerCodeOperationSpec = {
  path: "/fate-assembler",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.FateAssembler
    },
    400: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  requestBody: Parameters.body1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const validateByteCodeOperationSpec = {
  path: "/validate-byte-code",
  httpMethod: "POST",
  responses: {
    200: {},
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: Parameters.body8,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const versionOperationSpec = {
  path: "/version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CompilerVersion
    },
    500: {
      bodyMapper: Mappers.ErrorModel,
      isError: true
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
//# sourceMappingURL=compiler.mjs.map