import { Tag } from '../tx/builder/constants';
import { BuildTxOptions } from '../tx';
import { Encoded } from '../utils/encoder';
import AccountBase from '../account/Base';
import { SendOptions } from '../spend';
import Node from '../Node';
import { getAccount } from '../chain';
import Compiler from './Compiler';
/**
 * Check if account is GA
 * @category contract
 * @param address - Account address
 * @param options - Options
 * @returns if account is GA
 */
export declare function isGA(address: Encoded.AccountAddress, options: Parameters<typeof getAccount>[1]): Promise<boolean>;
/**
 * Convert current account to GA
 * @category contract
 * @param authFnName - Authorization function name
 * @param source - Auth contract source code
 * @param args - init arguments
 * @param options - Options
 * @returns General Account Object
 */
export declare function createGeneralizedAccount(authFnName: string, source: string, args: any[], { onAccount, onCompiler, onNode, ...options }: CreateGeneralizedAccountOptions): Promise<Readonly<{
    owner: Encoded.AccountAddress;
    transaction: Encoded.TxHash;
    rawTx: Encoded.Transaction;
    gaContractId: Encoded.ContractAddress;
}>>;
interface CreateGeneralizedAccountOptions extends BuildTxOptions<Tag.GaAttachTx, 'authFun' | 'callData' | 'code' | 'ownerId' | 'gasLimit'>, SendOptions {
    onAccount: AccountBase;
    onCompiler: Compiler;
    onNode: Node;
    gasLimit?: number;
}
/**
 * Create a metaTx transaction
 * @category contract
 * @param rawTransaction - Inner transaction
 * @param authData - Object with gaMeta params
 * @param authFnName - Authorization function name
 * @param options - Options
 * @param options.onAccount - Account to use
 * @returns Transaction string
 */
export declare function createMetaTx(rawTransaction: Encoded.Transaction, authData: {
    gasLimit?: number;
    callData?: Encoded.ContractBytearray;
    source?: string;
    args?: any[];
}, authFnName: string, { onAccount, onCompiler, onNode, ...options }: {
    onAccount: AccountBase;
    onCompiler: Compiler;
    onNode: Node;
} & Parameters<AccountBase['address']>[0]): Promise<Encoded.Transaction>;
/**
 * Build a transaction hash the same as `Auth.tx_hash`
 * @category contract
 * @param transaction - tx-encoded transaction
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */
export declare function buildAuthTxHash(transaction: Encoded.Transaction, { onNode }: {
    onNode: Node;
}): Promise<Uint8Array>;
export {};
