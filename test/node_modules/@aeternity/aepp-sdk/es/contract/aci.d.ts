import { AensName } from '../tx/builder/constants';
import { send } from '../spend';
import { Encoded } from '../utils/encoder';
import { Aci as BaseAci } from '../apis/compiler';
import { ContractCallReturnType } from '../apis/node';
import Compiler from './Compiler';
import Node from '../Node';
import AccountBase from '../account/Base';
interface FunctionACI {
    arguments: any[];
    name: string;
    payable: boolean;
    returns: string;
    stateful: boolean;
}
interface Aci extends BaseAci {
    encodedAci: {
        contract: {
            name: string;
            event: any;
            kind: string;
            state: any;
            type_defs: any[];
            functions: FunctionACI[];
        };
    };
    externalEncodedAci: any[];
}
interface Event {
    address: Encoded.ContractAddress;
    data: string;
    topics: Array<string | number>;
}
interface DecodedEvent {
    name: string;
    args: unknown;
    contract: {
        name: string;
        address: Encoded.ContractAddress;
    };
}
declare type TxData = Awaited<ReturnType<typeof send>>;
export interface ContractInstance {
    _aci: Aci;
    _name: string;
    calldata: any;
    source?: string;
    bytecode?: Encoded.ContractBytearray;
    deployInfo: {
        address?: Encoded.ContractAddress;
        result?: {
            callerId: string;
            callerNonce: string;
            contractId: string;
            gasPrice: bigint;
            gasUsed: number;
            height: number;
            log: any[];
            returnType: ContractCallReturnType;
            returnValue: string;
        };
        owner?: Encoded.AccountAddress;
        transaction?: string;
        rawTx?: string;
        txData?: TxData;
    };
    options: any;
    compile: (options?: {}) => Promise<Encoded.ContractBytearray>;
    _estimateGas: (name: string, params: any[], options: object) => Promise<number>;
    deploy: (params?: any[], options?: object) => Promise<any>;
    call: (fn: string, params?: any[], options?: {}) => Promise<{
        hash: string;
        tx: any;
        txData: TxData;
        rawTx: string;
        result: {
            callerId: Encoded.AccountAddress;
            callerNonce: number;
            contractId: Encoded.ContractAddress;
            gasPrice: number;
            gasUsed: number;
            height: number;
            log: any[];
            returnType: ContractCallReturnType;
            returnValue: string;
        };
        decodedResult: any;
        decodedEvents: DecodedEvent[];
    }>;
    decodeEvents: (events: Event[], options?: {
        omitUnknown?: boolean;
        contractAddressToName?: any;
    }) => DecodedEvent[];
    methods: any;
}
/**
 * Generate contract ACI object with predefined js methods for contract usage - can be used for
 * creating a reference to already deployed contracts
 * @category contract
 * @param options - Options object
 * @returns JS Contract API
 * @example
 * ```js
 * const contractIns = await aeSdk.getContractInstance({ source })
 * await contractIns.deploy([321]) or await contractIns.methods.init(321)
 * const callResult = await contractIns.call('setState', [123]) or
 * await contractIns.methods.setState.send(123, options)
 * const staticCallResult = await contractIns.call('setState', [123], { callStatic: true }) or
 * await contractIns.methods.setState.get(123, options)
 * ```
 * Also you can call contract like: `await contractIns.methods.setState(123, options)`
 * Then sdk decide to make on-chain or static call(dry-run API) transaction based on function is
 * stateful or not
 */
export default function getContractInstance({ onAccount, onCompiler, onNode, source, bytecode, aci: _aci, contractAddress, fileSystem, validateBytecode, ...otherOptions }: {
    onAccount?: AccountBase;
    onCompiler: Compiler;
    onNode: Node;
    source?: string;
    bytecode?: Encoded.ContractBytearray;
    aci?: Aci;
    contractAddress?: Encoded.ContractAddress | AensName;
    fileSystem?: Record<string, string>;
    validateBytecode?: boolean;
    [key: string]: any;
}): Promise<ContractInstance>;
export {};
