{"version":3,"file":"aci.mjs","names":["DRY_RUN_ACCOUNT","AMOUNT","Tag","buildContractIdByContractTx","unpackTx","_buildTx","send","decode","MissingContractDefError","MissingContractAddressError","InactiveContractError","BytecodeMismatchError","DuplicateContractError","MissingFunctionNameError","InvalidMethodInvocationError","NotPayableFunctionError","TypeError","NodeInvocationError","IllegalArgumentError","NoSuchContractFunctionError","MissingEventDefinitionError","AmbiguousEventDefinitionError","UnexpectedTsError","InternalError","hash","calcHash","getAccount","getContract","getContractByteCode","getKeyBlock","resolveName","txDryRun","getContractInstance","onAccount","onCompiler","onNode","source","bytecode","aci","_aci","contractAddress","fileSystem","validateBytecode","otherOptions","generateACI","code","options","resolveByNode","contract","active","instance","_name","encodedAci","name","calldata","Calldata","externalEncodedAci","deployInfo","address","amount","callStatic","compile","_options","_estimateGas","_params","deploy","call","_fn","decodeEvents","_events","methods","undefined","onChanBytecode","isValid","validateByteCode","then","compileContract","handleCallError","transaction","returnType","returnValue","message","decodeFateString","toString","sendAndProcess","tx","txData","result","rawTx","blockHeight","callInfo","getTransactionInfoByHash","Object","assign","params","gasUsed","Math","floor","opt","ownerId","ContractCreateTx","gasLimit","callData","encode","contractId","freeze","owner","getFunctionACI","fn","functions","find","f","payable","fnACI","callerId","Promise","resolve","catch","error","pub","res","top","txOpt","nonce","ContractCallTx","callObj","dryRunOther","decodedResult","returns","decodedEvents","log","getContractNameByEvent","nameHash","contractAddressToName","addressToName","matchedEvents","filter","event","map","variant","events","keys","flat","eventName","BigInt","length","omitUnknown","topics","t","contractName","decoded","decodeEvent","data","args","entries","e","fromEntries","arguments","aciArgs","stateful","genHandler","pop","get"],"sources":["../../src/contract/aci.ts"],"sourcesContent":["/*\n* ISC License (ISC)\n* Copyright (c) 2022 aeternity developers\n*\n*  Permission to use, copy, modify, and/or distribute this software for any\n*  purpose with or without fee is hereby granted, provided that the above\n*  copyright notice and this permission notice appear in all copies.\n*\n*  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n*  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n*  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n*  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n*  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n*  PERFORMANCE OF THIS SOFTWARE.\n*/\nimport { Encoder as Calldata } from '@aeternity/aepp-calldata';\nimport { DRY_RUN_ACCOUNT, AMOUNT } from '../tx/builder/schema';\nimport { Tag, AensName } from '../tx/builder/constants';\nimport { buildContractIdByContractTx, unpackTx } from '../tx/builder';\nimport { _buildTx } from '../tx';\nimport { send } from '../spend';\nimport { decode, Encoded } from '../utils/encoder';\nimport {\n  MissingContractDefError,\n  MissingContractAddressError,\n  InactiveContractError,\n  BytecodeMismatchError,\n  DuplicateContractError,\n  MissingFunctionNameError,\n  InvalidMethodInvocationError,\n  NotPayableFunctionError,\n  TypeError,\n  NodeInvocationError,\n  IllegalArgumentError,\n  NoSuchContractFunctionError,\n  MissingEventDefinitionError,\n  AmbiguousEventDefinitionError,\n  UnexpectedTsError,\n  InternalError,\n} from '../utils/errors';\nimport { hash as calcHash } from '../utils/crypto';\nimport { Aci as BaseAci } from '../apis/compiler';\nimport { ContractCallReturnType } from '../apis/node';\nimport Compiler from './Compiler';\nimport Node from '../Node';\nimport {\n  getAccount, getContract, getContractByteCode, getKeyBlock, resolveName, txDryRun,\n} from '../chain';\nimport AccountBase from '../account/Base';\n\ninterface FunctionACI {\n  arguments: any[];\n  name: string;\n  payable: boolean;\n  returns: string;\n  stateful: boolean;\n}\n\ninterface Aci extends BaseAci {\n  encodedAci: {\n    contract: {\n      name: string;\n      event: any;\n      kind: string;\n      state: any;\n      type_defs: any[];\n      functions: FunctionACI[];\n    };\n  };\n  externalEncodedAci: any[];\n}\n\ninterface Event {\n  address: Encoded.ContractAddress;\n  data: string;\n  topics: Array<string | number>;\n}\n\ninterface DecodedEvent {\n  name: string;\n  args: unknown;\n  contract: {\n    name: string;\n    address: Encoded.ContractAddress;\n  };\n}\n\ntype TxData = Awaited<ReturnType<typeof send>>;\n\nexport interface ContractInstance {\n  _aci: Aci;\n  _name: string;\n  calldata: any;\n  source?: string;\n  bytecode?: Encoded.ContractBytearray;\n  deployInfo: {\n    address?: Encoded.ContractAddress;\n    result?: {\n      callerId: string;\n      callerNonce: string;\n      contractId: string;\n      gasPrice: bigint;\n      gasUsed: number;\n      height: number;\n      log: any[];\n      returnType: ContractCallReturnType;\n      returnValue: string;\n    };\n    owner?: Encoded.AccountAddress;\n    transaction?: string;\n    rawTx?: string;\n    txData?: TxData;\n  };\n  options: any;\n  compile: (options?: {}) => Promise<Encoded.ContractBytearray>;\n  _estimateGas: (name: string, params: any[], options: object) => Promise<number>;\n  deploy: (params?: any[], options?: object) => Promise<any>;\n  call: (fn: string, params?: any[], options?: {}) => Promise<{\n    hash: string;\n    tx: any;\n    txData: TxData;\n    rawTx: string;\n    result: {\n      callerId: Encoded.AccountAddress;\n      callerNonce: number;\n      contractId: Encoded.ContractAddress;\n      gasPrice: number;\n      gasUsed: number;\n      height: number;\n      log: any[];\n      returnType: ContractCallReturnType;\n      returnValue: string;\n    };\n    decodedResult: any;\n    decodedEvents: DecodedEvent[];\n  }>;\n  decodeEvents: (\n    events: Event[], options?: { omitUnknown?: boolean; contractAddressToName?: any }\n  ) => DecodedEvent[];\n  methods: any;\n}\n\n/**\n * Generate contract ACI object with predefined js methods for contract usage - can be used for\n * creating a reference to already deployed contracts\n * @category contract\n * @param options - Options object\n * @returns JS Contract API\n * @example\n * ```js\n * const contractIns = await aeSdk.getContractInstance({ source })\n * await contractIns.deploy([321]) or await contractIns.methods.init(321)\n * const callResult = await contractIns.call('setState', [123]) or\n * await contractIns.methods.setState.send(123, options)\n * const staticCallResult = await contractIns.call('setState', [123], { callStatic: true }) or\n * await contractIns.methods.setState.get(123, options)\n * ```\n * Also you can call contract like: `await contractIns.methods.setState(123, options)`\n * Then sdk decide to make on-chain or static call(dry-run API) transaction based on function is\n * stateful or not\n */\nexport default async function getContractInstance({\n  onAccount,\n  onCompiler,\n  onNode,\n  source,\n  bytecode,\n  aci: _aci,\n  contractAddress,\n  fileSystem = {},\n  validateBytecode,\n  ...otherOptions\n}: {\n  onAccount?: AccountBase;\n  onCompiler: Compiler;\n  onNode: Node;\n  source?: string;\n  bytecode?: Encoded.ContractBytearray;\n  aci?: Aci;\n  contractAddress?: Encoded.ContractAddress | AensName;\n  fileSystem?: Record<string, string>;\n  validateBytecode?: boolean;\n  [key: string]: any;\n}): Promise<ContractInstance> {\n  if (_aci == null && source != null) {\n    // TODO: should be fixed when the compiledAci interface gets updated\n    _aci = await onCompiler.generateACI({ code: source, options: { fileSystem } }) as Aci;\n  }\n  if (_aci == null) throw new MissingContractDefError();\n\n  if (contractAddress != null) {\n    contractAddress = await resolveName(\n      contractAddress,\n      'contract_pubkey',\n      { resolveByNode: true, onNode },\n    ) as Encoded.ContractAddress;\n  }\n\n  if (contractAddress == null && source == null && bytecode == null) {\n    throw new MissingContractAddressError('Can\\'t create instance by ACI without address');\n  }\n\n  if (contractAddress != null) {\n    const contract = await getContract(contractAddress, { onNode });\n    if (contract.active == null) throw new InactiveContractError(contractAddress);\n  }\n\n  const instance: ContractInstance = {\n    _aci,\n    _name: _aci.encodedAci.contract.name,\n    calldata: new Calldata([_aci.encodedAci, ..._aci.externalEncodedAci]),\n    source,\n    bytecode,\n    deployInfo: { address: contractAddress },\n    options: {\n      onAccount,\n      onCompiler,\n      onNode,\n      amount: AMOUNT,\n      callStatic: false,\n      fileSystem,\n      ...otherOptions,\n    },\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    /* eslint-disable @typescript-eslint/no-empty-function */\n    async compile(_options?: {}): Promise<any> {},\n    async _estimateGas(_name: string, _params: any[], _options: object): Promise<any> {},\n    async deploy(_params?: any[], _options?: any): Promise<any> {},\n    async call(_fn: string, _params?: any[], _options?: {}): Promise<any> {},\n    decodeEvents(_events: Event[], options?: { omitUnknown?: boolean }): any {},\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    /* eslint-enable @typescript-eslint/no-empty-function */\n    methods: undefined,\n  };\n\n  if (validateBytecode != null) {\n    if (contractAddress == null) throw new MissingContractAddressError('Can\\'t validate bytecode without contract address');\n    const onChanBytecode = (await getContractByteCode(contractAddress, { onNode })).bytecode;\n    const isValid: boolean = source != null\n      ? await onCompiler.validateByteCode(\n        { bytecode: onChanBytecode, source, options: instance.options },\n      ).then(() => true, () => false)\n      : bytecode === onChanBytecode;\n    if (!isValid) throw new BytecodeMismatchError(source != null ? 'source' : 'bytecode');\n  }\n\n  /**\n   * Compile contract\n   * @returns bytecode\n   */\n  instance.compile = async (options = {}): Promise<Encoded.ContractBytearray> => {\n    if (instance.bytecode != null) throw new IllegalArgumentError('Contract already compiled');\n    if (instance.source == null) throw new IllegalArgumentError('Can\\'t compile without source code');\n    instance.bytecode = (await onCompiler.compileContract({\n      code: instance.source, options: { ...instance.options, ...options },\n    })).bytecode as Encoded.ContractBytearray;\n    return instance.bytecode;\n  };\n\n  const handleCallError = (\n    { returnType, returnValue }: {\n      returnType: ContractCallReturnType;\n      returnValue: Encoded.ContractBytearray;\n    },\n    transaction: string,\n  ): void => {\n    let message: string;\n    switch (returnType) {\n      case 'ok': return;\n      case 'revert':\n        message = instance.calldata.decodeFateString(returnValue);\n        break;\n      case 'error':\n        message = decode(returnValue).toString();\n        break;\n      default:\n        throw new InternalError(`Unknown return type: ${returnType}`);\n    }\n    throw new NodeInvocationError(message, transaction);\n  };\n\n  const sendAndProcess = async (tx: Encoded.Transaction, options: any): Promise<{\n    result?: ContractInstance['deployInfo']['result'];\n    hash: TxData['hash'];\n    tx: Awaited<ReturnType<typeof unpackTx<Tag.ContractCallTx | Tag.ContractCreateTx>>>;\n    txData: TxData;\n    rawTx: Encoded.Transaction;\n  }> => {\n    options = { ...instance.options, ...options };\n    const txData = await send(tx, options);\n    const result = {\n      hash: txData.hash,\n      tx: unpackTx<Tag.ContractCallTx | Tag.ContractCreateTx>(txData.rawTx),\n      txData,\n      rawTx: txData.rawTx,\n    };\n    if (txData.blockHeight == null) return result;\n    const { callInfo } = await onNode.getTransactionInfoByHash(txData.hash);\n    Object.assign(result.txData, callInfo); // TODO: don't duplicate data in result\n    // @ts-expect-error TODO api should be updated to match types\n    handleCallError(callInfo, tx);\n    return { ...result, result: callInfo };\n  };\n\n  instance._estimateGas = async (name: string, params: any[], options: object): Promise<number> => {\n    const { result: { gasUsed } } = await instance\n      .call(name, params, { ...options, callStatic: true });\n    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771\n    return Math.floor(gasUsed * 1.25);\n  };\n\n  /**\n   * Deploy contract\n   * @param params - Contract init function arguments array\n   * @param options - Options\n   * @returns deploy info\n   */\n  instance.deploy = async (\n    params = [],\n    options?:\n    Parameters<typeof instance.compile>[0] &\n    Parameters<typeof instance.call>[2] &\n    Parameters<AccountBase['address']>[0] &\n    Parameters<typeof sendAndProcess>[1],\n  ): Promise<ContractInstance['deployInfo']> => {\n    const opt = { ...instance.options, ...options };\n    if (instance.bytecode == null) await instance.compile(opt);\n    // @ts-expect-error TODO: need to fix compatibility between return types of `deploy` and `call`\n    if (opt.callStatic === true) return instance.call('init', params, opt);\n    if (instance.deployInfo.address != null) throw new DuplicateContractError();\n\n    const ownerId = await opt.onAccount.address(options);\n    const tx = await _buildTx(Tag.ContractCreateTx, {\n      ...opt,\n      gasLimit: opt.gasLimit ?? await instance._estimateGas('init', params, opt),\n      callData: instance.calldata.encode(instance._name, 'init', params),\n      code: instance.bytecode,\n      ownerId,\n      onNode,\n    });\n    const contractId = buildContractIdByContractTx(tx);\n    const {\n      hash, rawTx, result, txData,\n    } = await sendAndProcess(tx, opt);\n    instance.deployInfo = Object.freeze({\n      result,\n      owner: ownerId,\n      transaction: hash,\n      rawTx,\n      txData,\n      address: contractId,\n    });\n    return instance.deployInfo;\n  };\n\n  /**\n   * Get function schema from contract ACI object\n   * @param name - Function name\n   * @returns function ACI\n   */\n  function getFunctionACI(name: string): Partial<FunctionACI> {\n    const fn = instance._aci.encodedAci.contract.functions.find(\n      (f: { name: string }) => f.name === name,\n    );\n    if (fn != null) {\n      return fn;\n    }\n    if (name === 'init') return { payable: false };\n    throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);\n  }\n\n  /**\n   * Call contract function\n   * @param fn - Function name\n   * @param params - Array of function arguments\n   * @param options - Array of function arguments\n   * @returns CallResult\n   */\n  instance.call = async (fn: string, params: any[] = [], options: object = {}) => {\n    const opt = { ...instance.options, ...options };\n    const fnACI = getFunctionACI(fn);\n    const contractId = instance.deployInfo.address;\n\n    if (fn == null) throw new MissingFunctionNameError();\n    if (fn === 'init' && opt.callStatic === false) throw new InvalidMethodInvocationError('\"init\" can be called only via dryRun');\n    if (contractId == null && fn !== 'init') throw new InvalidMethodInvocationError('You need to deploy contract before calling!');\n    if (fn !== 'init' && opt.amount > 0 && fnACI.payable === false) throw new NotPayableFunctionError(opt.amount, fn);\n\n    const callerId = await Promise.resolve()\n      .then(() => opt.onAccount.address(opt))\n      .catch((error: any) => {\n        if (opt.callStatic === true) return DRY_RUN_ACCOUNT.pub;\n        throw error;\n      }) as Encoded.AccountAddress;\n    const callData = instance.calldata.encode(instance._name, fn, params);\n\n    let res: any;\n    if (opt.callStatic === true) {\n      if (typeof opt.top === 'number') {\n        opt.top = (await getKeyBlock(opt.top, { onNode })).hash;\n      }\n      const txOpt = { ...opt, onNode, callData };\n      if (opt.nonce == null && opt.top != null) {\n        opt.nonce = (await getAccount(callerId, { hash: opt.top, onNode })).nonce + 1;\n      }\n      const tx = await (fn === 'init'\n        ? _buildTx(Tag.ContractCreateTx, { ...txOpt, code: instance.bytecode, ownerId: callerId })\n        : _buildTx(Tag.ContractCallTx, { ...txOpt, callerId, contractId }));\n\n      const { callObj, ...dryRunOther } = await txDryRun(tx, callerId, { onNode, ...opt });\n      if (callObj == null) throw new UnexpectedTsError();\n      handleCallError({\n        returnType: callObj.returnType as ContractCallReturnType,\n        returnValue: callObj.returnValue as Encoded.ContractBytearray,\n      }, tx);\n      res = { ...dryRunOther, tx: unpackTx(tx), result: callObj };\n    } else {\n      const tx = await _buildTx(Tag.ContractCallTx, {\n        ...opt,\n        onNode,\n        gasLimit: opt.gasLimit ?? await instance._estimateGas(fn, params, opt),\n        callerId,\n        contractId,\n        callData,\n      });\n      res = await sendAndProcess(tx, opt);\n    }\n    if (opt.callStatic === true || res.txData.blockHeight != null) {\n      res.decodedResult = fnACI.returns != null && fnACI.returns !== 'unit' && fn !== 'init'\n        && instance.calldata.decode(instance._name, fn, res.result.returnValue);\n      res.decodedEvents = instance.decodeEvents(res.result.log, opt);\n    }\n    return res;\n  };\n\n  /**\n   * @param address - Contract address that emitted event\n   * @param nameHash - Hash of emitted event name\n   * @param options - Options\n   * @returns Contract name\n   * @throws {@link MissingEventDefinitionError}\n   * @throws {@link AmbiguousEventDefinitionError}\n   */\n  function getContractNameByEvent(\n    address: Encoded.ContractAddress,\n    nameHash: BigInt,\n    { contractAddressToName }: {\n      contractAddressToName?: { [key: Encoded.ContractAddress]: string };\n    },\n  ): string {\n    const addressToName = { ...instance.options.contractAddressToName, ...contractAddressToName };\n    if (addressToName[address] != null) return addressToName[address];\n\n    const matchedEvents = [\n      instance._aci.encodedAci,\n      ...instance._aci.externalEncodedAci,\n    ]\n      .filter(({ contract }) => contract?.event)\n      .map(({ contract }) => [contract.name, contract.event.variant])\n      .map(([name, events]) => events.map((event: {}) => [name, Object.keys(event)[0]]))\n      .flat()\n      .filter(([, eventName]) => BigInt(`0x${calcHash(eventName).toString('hex')}`) === nameHash);\n    switch (matchedEvents.length) {\n      case 0: throw new MissingEventDefinitionError(nameHash.toString(), address);\n      case 1: return matchedEvents[0][0];\n      default: throw new AmbiguousEventDefinitionError(address, matchedEvents);\n    }\n  }\n\n  /**\n   * Decode Events\n   * @param events - Array of encoded events (callRes.result.log)\n   * @param options - Options\n   * @returns DecodedEvents\n   */\n  instance.decodeEvents = (\n    events: Event[],\n    { omitUnknown, ...opt }: { omitUnknown?: boolean } = {},\n  ): DecodedEvent[] => events\n    .map((event) => {\n      const topics = event.topics.map((t: string | number) => BigInt(t));\n      let contractName;\n      try {\n        contractName = getContractNameByEvent(event.address, topics[0], opt);\n      } catch (error) {\n        if ((omitUnknown ?? false) && error instanceof MissingEventDefinitionError) return null;\n        throw error;\n      }\n      const decoded = instance.calldata.decodeEvent(contractName, event.data, topics);\n      const [name, args] = Object.entries(decoded)[0];\n      return {\n        name,\n        args,\n        contract: {\n          name: contractName,\n          address: event.address,\n        },\n      };\n    }).filter((e: DecodedEvent | null): e is DecodedEvent => e != null);\n\n  /**\n   * Generate proto function based on contract function using Contract ACI schema\n   * All function can be called like:\n   * ```js\n   * await contract.methods.testFunction()\n   * ```\n   * then sdk will decide to use dry-run or send tx\n   * on-chain base on if function stateful or not.\n   * Also, you can manually do that:\n   * ```js\n   * await contract.methods.testFunction.get() // use call-static (dry-run)\n   * await contract.methods.testFunction.send() // send tx on-chain\n   * ```\n   */\n  instance.methods = Object.fromEntries(instance._aci.encodedAci.contract.functions\n    .map(({ name, arguments: aciArgs, stateful }: FunctionACI) => {\n      const genHandler = (callStatic: boolean) => async (...args: any[]) => {\n        const options = args.length === aciArgs.length + 1 ? args.pop() : {};\n        if (typeof options !== 'object') throw new TypeError(`Options should be an object: ${options as string}`);\n        if (name === 'init') return instance.deploy(args, { callStatic, ...options });\n        return instance.call(name, args, { callStatic, ...options });\n      };\n      return [\n        name,\n        Object.assign(\n          genHandler(name === 'init' ? false : !stateful),\n          {\n            get: genHandler(true),\n            send: genHandler(false),\n          },\n        ),\n      ];\n    }));\n\n  return instance;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAoC,0BAApC;;;;SACSA,e,EAAiBC,M;SACjBC,G;SACAC,2B,EAA6BC,Q;SAC7BC,Q;SACAC,I;SACAC,M;SAEPC,uB,EACAC,2B,EACAC,qB,EACAC,qB,EACAC,sB,EACAC,wB,EACAC,4B,EACAC,uB,EACAC,S,EACAC,mB,EACAC,oB,EACAC,2B,EACAC,2B,EACAC,6B,EACAC,iB,EACAC,a;SAEOC,IAAI,IAAIC,Q;SAMfC,U,EAAYC,W,EAAaC,mB,EAAqBC,W,EAAaC,W,EAAaC,Q;;AAgG1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAeC,mBAAf,OAsBe;EAAA,IAtBoB;IAChDC,SADgD;IAEhDC,UAFgD;IAGhDC,MAHgD;IAIhDC,MAJgD;IAKhDC,QALgD;IAMhDC,GAAG,EAAEC,IAN2C;IAOhDC,eAPgD;IAQhDC,UAAU,GAAG,EARmC;IAShDC,gBATgD;IAUhD,GAAGC;EAV6C,CAsBpB;;EAC5B,IAAIJ,IAAI,IAAI,IAAR,IAAgBH,MAAM,IAAI,IAA9B,EAAoC;IAClC;IACAG,IAAI,GAAG,MAAML,UAAU,CAACU,WAAX,CAAuB;MAAEC,IAAI,EAAET,MAAR;MAAgBU,OAAO,EAAE;QAAEL;MAAF;IAAzB,CAAvB,CAAb;EACD;;EACD,IAAIF,IAAI,IAAI,IAAZ,EAAkB,MAAM,IAAI/B,uBAAJ,EAAN;;EAElB,IAAIgC,eAAe,IAAI,IAAvB,EAA6B;IAC3BA,eAAe,GAAG,MAAMV,WAAW,CACjCU,eADiC,EAEjC,iBAFiC,EAGjC;MAAEO,aAAa,EAAE,IAAjB;MAAuBZ;IAAvB,CAHiC,CAAnC;EAKD;;EAED,IAAIK,eAAe,IAAI,IAAnB,IAA2BJ,MAAM,IAAI,IAArC,IAA6CC,QAAQ,IAAI,IAA7D,EAAmE;IACjE,MAAM,IAAI5B,2BAAJ,CAAgC,+CAAhC,CAAN;EACD;;EAED,IAAI+B,eAAe,IAAI,IAAvB,EAA6B;IAC3B,MAAMQ,QAAQ,GAAG,MAAMrB,WAAW,CAACa,eAAD,EAAkB;MAAEL;IAAF,CAAlB,CAAlC;IACA,IAAIa,QAAQ,CAACC,MAAT,IAAmB,IAAvB,EAA6B,MAAM,IAAIvC,qBAAJ,CAA0B8B,eAA1B,CAAN;EAC9B;;EAED,MAAMU,QAA0B,GAAG;IACjCX,IADiC;IAEjCY,KAAK,EAAEZ,IAAI,CAACa,UAAL,CAAgBJ,QAAhB,CAAyBK,IAFC;IAGjCC,QAAQ,EAAE,IAAIC,QAAJ,CAAa,CAAChB,IAAI,CAACa,UAAN,EAAkB,GAAGb,IAAI,CAACiB,kBAA1B,CAAb,CAHuB;IAIjCpB,MAJiC;IAKjCC,QALiC;IAMjCoB,UAAU,EAAE;MAAEC,OAAO,EAAElB;IAAX,CANqB;IAOjCM,OAAO,EAAE;MACPb,SADO;MAEPC,UAFO;MAGPC,MAHO;MAIPwB,MAAM,EAAE1D,MAJD;MAKP2D,UAAU,EAAE,KALL;MAMPnB,UANO;MAOP,GAAGE;IAPI,CAPwB;;IAgBjC;;IACA;IACA,MAAMkB,OAAN,CAAcC,QAAd,EAA2C,CAAE,CAlBZ;;IAmBjC,MAAMC,YAAN,CAAmBZ,KAAnB,EAAkCa,OAAlC,EAAkDF,QAAlD,EAAkF,CAAE,CAnBnD;;IAoBjC,MAAMG,MAAN,CAAaD,OAAb,EAA8BF,QAA9B,EAA4D,CAAE,CApB7B;;IAqBjC,MAAMI,IAAN,CAAWC,GAAX,EAAwBH,OAAxB,EAAyCF,QAAzC,EAAsE,CAAE,CArBvC;;IAsBjCM,YAAY,CAACC,OAAD,EAAmBvB,OAAnB,EAA6D,CAAE,CAtB1C;;IAuBjC;;IACA;IACAwB,OAAO,EAAEC;EAzBwB,CAAnC;;EA4BA,IAAI7B,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,IAAIF,eAAe,IAAI,IAAvB,EAA6B,MAAM,IAAI/B,2BAAJ,CAAgC,mDAAhC,CAAN;IAC7B,MAAM+D,cAAc,GAAG,CAAC,MAAM5C,mBAAmB,CAACY,eAAD,EAAkB;MAAEL;IAAF,CAAlB,CAA1B,EAAyDE,QAAhF;IACA,MAAMoC,OAAgB,GAAGrC,MAAM,IAAI,IAAV,GACrB,MAAMF,UAAU,CAACwC,gBAAX,CACN;MAAErC,QAAQ,EAAEmC,cAAZ;MAA4BpC,MAA5B;MAAoCU,OAAO,EAAEI,QAAQ,CAACJ;IAAtD,CADM,EAEN6B,IAFM,CAED,MAAM,IAFL,EAEW,MAAM,KAFjB,CADe,GAIrBtC,QAAQ,KAAKmC,cAJjB;IAKA,IAAI,CAACC,OAAL,EAAc,MAAM,IAAI9D,qBAAJ,CAA0ByB,MAAM,IAAI,IAAV,GAAiB,QAAjB,GAA4B,UAAtD,CAAN;EACf;EAED;AACF;AACA;AACA;;;EACEc,QAAQ,CAACW,OAAT,GAAmB,kBAA4D;IAAA,IAArDf,OAAqD,uEAA3C,EAA2C;IAC7E,IAAII,QAAQ,CAACb,QAAT,IAAqB,IAAzB,EAA+B,MAAM,IAAInB,oBAAJ,CAAyB,2BAAzB,CAAN;IAC/B,IAAIgC,QAAQ,CAACd,MAAT,IAAmB,IAAvB,EAA6B,MAAM,IAAIlB,oBAAJ,CAAyB,oCAAzB,CAAN;IAC7BgC,QAAQ,CAACb,QAAT,GAAoB,CAAC,MAAMH,UAAU,CAAC0C,eAAX,CAA2B;MACpD/B,IAAI,EAAEK,QAAQ,CAACd,MADqC;MAC7BU,OAAO,EAAE,EAAE,GAAGI,QAAQ,CAACJ,OAAd;QAAuB,GAAGA;MAA1B;IADoB,CAA3B,CAAP,EAEhBT,QAFJ;IAGA,OAAOa,QAAQ,CAACb,QAAhB;EACD,CAPD;;EASA,MAAMwC,eAAe,GAAG,QAKtBC,WALsB,KAMb;IAAA,IALT;MAAEC,UAAF;MAAcC;IAAd,CAKS;IACT,IAAIC,OAAJ;;IACA,QAAQF,UAAR;MACE,KAAK,IAAL;QAAW;;MACX,KAAK,QAAL;QACEE,OAAO,GAAG/B,QAAQ,CAACI,QAAT,CAAkB4B,gBAAlB,CAAmCF,WAAnC,CAAV;QACA;;MACF,KAAK,OAAL;QACEC,OAAO,GAAG1E,MAAM,CAACyE,WAAD,CAAN,CAAoBG,QAApB,EAAV;QACA;;MACF;QACE,MAAM,IAAI5D,aAAJ,CAAmB,wBAAuBwD,UAAW,EAArD,CAAN;IATJ;;IAWA,MAAM,IAAI9D,mBAAJ,CAAwBgE,OAAxB,EAAiCH,WAAjC,CAAN;EACD,CApBD;;EAsBA,MAAMM,cAAc,GAAG,OAAOC,EAAP,EAAgCvC,OAAhC,KAMjB;IACJA,OAAO,GAAG,EAAE,GAAGI,QAAQ,CAACJ,OAAd;MAAuB,GAAGA;IAA1B,CAAV;IACA,MAAMwC,MAAM,GAAG,MAAMhF,IAAI,CAAC+E,EAAD,EAAKvC,OAAL,CAAzB;IACA,MAAMyC,MAAM,GAAG;MACb/D,IAAI,EAAE8D,MAAM,CAAC9D,IADA;MAEb6D,EAAE,EAAEjF,QAAQ,CAA4CkF,MAAM,CAACE,KAAnD,CAFC;MAGbF,MAHa;MAIbE,KAAK,EAAEF,MAAM,CAACE;IAJD,CAAf;IAMA,IAAIF,MAAM,CAACG,WAAP,IAAsB,IAA1B,EAAgC,OAAOF,MAAP;IAChC,MAAM;MAAEG;IAAF,IAAe,MAAMvD,MAAM,CAACwD,wBAAP,CAAgCL,MAAM,CAAC9D,IAAvC,CAA3B;IACAoE,MAAM,CAACC,MAAP,CAAcN,MAAM,CAACD,MAArB,EAA6BI,QAA7B,EAXI,CAWoC;IACxC;;IACAb,eAAe,CAACa,QAAD,EAAWL,EAAX,CAAf;IACA,OAAO,EAAE,GAAGE,MAAL;MAAaA,MAAM,EAAEG;IAArB,CAAP;EACD,CArBD;;EAuBAxC,QAAQ,CAACa,YAAT,GAAwB,OAAOV,IAAP,EAAqByC,MAArB,EAAoChD,OAApC,KAAyE;IAC/F,MAAM;MAAEyC,MAAM,EAAE;QAAEQ;MAAF;IAAV,IAA0B,MAAM7C,QAAQ,CAC3CgB,IADmC,CAC9Bb,IAD8B,EACxByC,MADwB,EAChB,EAAE,GAAGhD,OAAL;MAAcc,UAAU,EAAE;IAA1B,CADgB,CAAtC,CAD+F,CAG/F;;IACA,OAAOoC,IAAI,CAACC,KAAL,CAAWF,OAAO,GAAG,IAArB,CAAP;EACD,CALD;EAOA;AACF;AACA;AACA;AACA;AACA;;;EACE7C,QAAQ,CAACe,MAAT,GAAkB,kBAO4B;IAAA;;IAAA,IAN5C6B,MAM4C,uEANnC,EAMmC;IAAA,IAL5ChD,OAK4C;IAC5C,MAAMoD,GAAG,GAAG,EAAE,GAAGhD,QAAQ,CAACJ,OAAd;MAAuB,GAAGA;IAA1B,CAAZ;IACA,IAAII,QAAQ,CAACb,QAAT,IAAqB,IAAzB,EAA+B,MAAMa,QAAQ,CAACW,OAAT,CAAiBqC,GAAjB,CAAN,CAFa,CAG5C;;IACA,IAAIA,GAAG,CAACtC,UAAJ,KAAmB,IAAvB,EAA6B,OAAOV,QAAQ,CAACgB,IAAT,CAAc,MAAd,EAAsB4B,MAAtB,EAA8BI,GAA9B,CAAP;IAC7B,IAAIhD,QAAQ,CAACO,UAAT,CAAoBC,OAApB,IAA+B,IAAnC,EAAyC,MAAM,IAAI9C,sBAAJ,EAAN;IAEzC,MAAMuF,OAAO,GAAG,MAAMD,GAAG,CAACjE,SAAJ,CAAcyB,OAAd,CAAsBZ,OAAtB,CAAtB;IACA,MAAMuC,EAAE,GAAG,MAAMhF,QAAQ,CAACH,GAAG,CAACkG,gBAAL,EAAuB,EAC9C,GAAGF,GAD2C;MAE9CG,QAAQ,mBAAEH,GAAG,CAACG,QAAN,yDAAkB,MAAMnD,QAAQ,CAACa,YAAT,CAAsB,MAAtB,EAA8B+B,MAA9B,EAAsCI,GAAtC,CAFc;MAG9CI,QAAQ,EAAEpD,QAAQ,CAACI,QAAT,CAAkBiD,MAAlB,CAAyBrD,QAAQ,CAACC,KAAlC,EAAyC,MAAzC,EAAiD2C,MAAjD,CAHoC;MAI9CjD,IAAI,EAAEK,QAAQ,CAACb,QAJ+B;MAK9C8D,OAL8C;MAM9ChE;IAN8C,CAAvB,CAAzB;IAQA,MAAMqE,UAAU,GAAGrG,2BAA2B,CAACkF,EAAD,CAA9C;IACA,MAAM;MACJ7D,IADI;MACEgE,KADF;MACSD,MADT;MACiBD;IADjB,IAEF,MAAMF,cAAc,CAACC,EAAD,EAAKa,GAAL,CAFxB;IAGAhD,QAAQ,CAACO,UAAT,GAAsBmC,MAAM,CAACa,MAAP,CAAc;MAClClB,MADkC;MAElCmB,KAAK,EAAEP,OAF2B;MAGlCrB,WAAW,EAAEtD,IAHqB;MAIlCgE,KAJkC;MAKlCF,MALkC;MAMlC5B,OAAO,EAAE8C;IANyB,CAAd,CAAtB;IAQA,OAAOtD,QAAQ,CAACO,UAAhB;EACD,CApCD;EAsCA;AACF;AACA;AACA;AACA;;;EACE,SAASkD,cAAT,CAAwBtD,IAAxB,EAA4D;IAC1D,MAAMuD,EAAE,GAAG1D,QAAQ,CAACX,IAAT,CAAca,UAAd,CAAyBJ,QAAzB,CAAkC6D,SAAlC,CAA4CC,IAA5C,CACRC,CAAD,IAAyBA,CAAC,CAAC1D,IAAF,KAAWA,IAD3B,CAAX;;IAGA,IAAIuD,EAAE,IAAI,IAAV,EAAgB;MACd,OAAOA,EAAP;IACD;;IACD,IAAIvD,IAAI,KAAK,MAAb,EAAqB,OAAO;MAAE2D,OAAO,EAAE;IAAX,CAAP;IACrB,MAAM,IAAI7F,2BAAJ,CAAiC,YAAWkC,IAAK,4BAAjD,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEH,QAAQ,CAACgB,IAAT,GAAgB,gBAAO0C,EAAP,EAAgE;IAAA,IAA7Cd,MAA6C,uEAA7B,EAA6B;IAAA,IAAzBhD,OAAyB,uEAAP,EAAO;IAC9E,MAAMoD,GAAG,GAAG,EAAE,GAAGhD,QAAQ,CAACJ,OAAd;MAAuB,GAAGA;IAA1B,CAAZ;IACA,MAAMmE,KAAK,GAAGN,cAAc,CAACC,EAAD,CAA5B;IACA,MAAMJ,UAAU,GAAGtD,QAAQ,CAACO,UAAT,CAAoBC,OAAvC;IAEA,IAAIkD,EAAE,IAAI,IAAV,EAAgB,MAAM,IAAI/F,wBAAJ,EAAN;IAChB,IAAI+F,EAAE,KAAK,MAAP,IAAiBV,GAAG,CAACtC,UAAJ,KAAmB,KAAxC,EAA+C,MAAM,IAAI9C,4BAAJ,CAAiC,sCAAjC,CAAN;IAC/C,IAAI0F,UAAU,IAAI,IAAd,IAAsBI,EAAE,KAAK,MAAjC,EAAyC,MAAM,IAAI9F,4BAAJ,CAAiC,6CAAjC,CAAN;IACzC,IAAI8F,EAAE,KAAK,MAAP,IAAiBV,GAAG,CAACvC,MAAJ,GAAa,CAA9B,IAAmCsD,KAAK,CAACD,OAAN,KAAkB,KAAzD,EAAgE,MAAM,IAAIjG,uBAAJ,CAA4BmF,GAAG,CAACvC,MAAhC,EAAwCiD,EAAxC,CAAN;IAEhE,MAAMM,QAAQ,GAAG,MAAMC,OAAO,CAACC,OAAR,GACpBzC,IADoB,CACf,MAAMuB,GAAG,CAACjE,SAAJ,CAAcyB,OAAd,CAAsBwC,GAAtB,CADS,EAEpBmB,KAFoB,CAEbC,KAAD,IAAgB;MACrB,IAAIpB,GAAG,CAACtC,UAAJ,KAAmB,IAAvB,EAA6B,OAAO5D,eAAe,CAACuH,GAAvB;MAC7B,MAAMD,KAAN;IACD,CALoB,CAAvB;IAMA,MAAMhB,QAAQ,GAAGpD,QAAQ,CAACI,QAAT,CAAkBiD,MAAlB,CAAyBrD,QAAQ,CAACC,KAAlC,EAAyCyD,EAAzC,EAA6Cd,MAA7C,CAAjB;IAEA,IAAI0B,GAAJ;;IACA,IAAItB,GAAG,CAACtC,UAAJ,KAAmB,IAAvB,EAA6B;MAC3B,IAAI,OAAOsC,GAAG,CAACuB,GAAX,KAAmB,QAAvB,EAAiC;QAC/BvB,GAAG,CAACuB,GAAJ,GAAU,CAAC,MAAM5F,WAAW,CAACqE,GAAG,CAACuB,GAAL,EAAU;UAAEtF;QAAF,CAAV,CAAlB,EAAyCX,IAAnD;MACD;;MACD,MAAMkG,KAAK,GAAG,EAAE,GAAGxB,GAAL;QAAU/D,MAAV;QAAkBmE;MAAlB,CAAd;;MACA,IAAIJ,GAAG,CAACyB,KAAJ,IAAa,IAAb,IAAqBzB,GAAG,CAACuB,GAAJ,IAAW,IAApC,EAA0C;QACxCvB,GAAG,CAACyB,KAAJ,GAAY,CAAC,MAAMjG,UAAU,CAACwF,QAAD,EAAW;UAAE1F,IAAI,EAAE0E,GAAG,CAACuB,GAAZ;UAAiBtF;QAAjB,CAAX,CAAjB,EAAwDwF,KAAxD,GAAgE,CAA5E;MACD;;MACD,MAAMtC,EAAE,GAAG,OAAOuB,EAAE,KAAK,MAAP,GACdvG,QAAQ,CAACH,GAAG,CAACkG,gBAAL,EAAuB,EAAE,GAAGsB,KAAL;QAAY7E,IAAI,EAAEK,QAAQ,CAACb,QAA3B;QAAqC8D,OAAO,EAAEe;MAA9C,CAAvB,CADM,GAEd7G,QAAQ,CAACH,GAAG,CAAC0H,cAAL,EAAqB,EAAE,GAAGF,KAAL;QAAYR,QAAZ;QAAsBV;MAAtB,CAArB,CAFD,CAAX;MAIA,MAAM;QAAEqB,OAAF;QAAW,GAAGC;MAAd,IAA8B,MAAM/F,QAAQ,CAACsD,EAAD,EAAK6B,QAAL,EAAe;QAAE/E,MAAF;QAAU,GAAG+D;MAAb,CAAf,CAAlD;MACA,IAAI2B,OAAO,IAAI,IAAf,EAAqB,MAAM,IAAIvG,iBAAJ,EAAN;MACrBuD,eAAe,CAAC;QACdE,UAAU,EAAE8C,OAAO,CAAC9C,UADN;QAEdC,WAAW,EAAE6C,OAAO,CAAC7C;MAFP,CAAD,EAGZK,EAHY,CAAf;MAIAmC,GAAG,GAAG,EAAE,GAAGM,WAAL;QAAkBzC,EAAE,EAAEjF,QAAQ,CAACiF,EAAD,CAA9B;QAAoCE,MAAM,EAAEsC;MAA5C,CAAN;IACD,CAnBD,MAmBO;MAAA;;MACL,MAAMxC,EAAE,GAAG,MAAMhF,QAAQ,CAACH,GAAG,CAAC0H,cAAL,EAAqB,EAC5C,GAAG1B,GADyC;QAE5C/D,MAF4C;QAG5CkE,QAAQ,oBAAEH,GAAG,CAACG,QAAN,2DAAkB,MAAMnD,QAAQ,CAACa,YAAT,CAAsB6C,EAAtB,EAA0Bd,MAA1B,EAAkCI,GAAlC,CAHY;QAI5CgB,QAJ4C;QAK5CV,UAL4C;QAM5CF;MAN4C,CAArB,CAAzB;MAQAkB,GAAG,GAAG,MAAMpC,cAAc,CAACC,EAAD,EAAKa,GAAL,CAA1B;IACD;;IACD,IAAIA,GAAG,CAACtC,UAAJ,KAAmB,IAAnB,IAA2B4D,GAAG,CAAClC,MAAJ,CAAWG,WAAX,IAA0B,IAAzD,EAA+D;MAC7D+B,GAAG,CAACO,aAAJ,GAAoBd,KAAK,CAACe,OAAN,IAAiB,IAAjB,IAAyBf,KAAK,CAACe,OAAN,KAAkB,MAA3C,IAAqDpB,EAAE,KAAK,MAA5D,IACf1D,QAAQ,CAACI,QAAT,CAAkB/C,MAAlB,CAAyB2C,QAAQ,CAACC,KAAlC,EAAyCyD,EAAzC,EAA6CY,GAAG,CAACjC,MAAJ,CAAWP,WAAxD,CADL;MAEAwC,GAAG,CAACS,aAAJ,GAAoB/E,QAAQ,CAACkB,YAAT,CAAsBoD,GAAG,CAACjC,MAAJ,CAAW2C,GAAjC,EAAsChC,GAAtC,CAApB;IACD;;IACD,OAAOsB,GAAP;EACD,CAvDD;EAyDA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE,SAASW,sBAAT,CACEzE,OADF,EAEE0E,QAFF,SAMU;IAAA,IAHR;MAAEC;IAAF,CAGQ;IACR,MAAMC,aAAa,GAAG,EAAE,GAAGpF,QAAQ,CAACJ,OAAT,CAAiBuF,qBAAtB;MAA6C,GAAGA;IAAhD,CAAtB;IACA,IAAIC,aAAa,CAAC5E,OAAD,CAAb,IAA0B,IAA9B,EAAoC,OAAO4E,aAAa,CAAC5E,OAAD,CAApB;IAEpC,MAAM6E,aAAa,GAAG,CACpBrF,QAAQ,CAACX,IAAT,CAAca,UADM,EAEpB,GAAGF,QAAQ,CAACX,IAAT,CAAciB,kBAFG,EAInBgF,MAJmB,CAIZ;MAAA,IAAC;QAAExF;MAAF,CAAD;MAAA,OAAkBA,QAAlB,aAAkBA,QAAlB,uBAAkBA,QAAQ,CAAEyF,KAA5B;IAAA,CAJY,EAKnBC,GALmB,CAKf;MAAA,IAAC;QAAE1F;MAAF,CAAD;MAAA,OAAkB,CAACA,QAAQ,CAACK,IAAV,EAAgBL,QAAQ,CAACyF,KAAT,CAAeE,OAA/B,CAAlB;IAAA,CALe,EAMnBD,GANmB,CAMf;MAAA,IAAC,CAACrF,IAAD,EAAOuF,MAAP,CAAD;MAAA,OAAoBA,MAAM,CAACF,GAAP,CAAYD,KAAD,IAAe,CAACpF,IAAD,EAAOuC,MAAM,CAACiD,IAAP,CAAYJ,KAAZ,EAAmB,CAAnB,CAAP,CAA1B,CAApB;IAAA,CANe,EAOnBK,IAPmB,GAQnBN,MARmB,CAQZ;MAAA,IAAC,GAAGO,SAAH,CAAD;MAAA,OAAmBC,MAAM,CAAE,KAAIvH,QAAQ,CAACsH,SAAD,CAAR,CAAoB5D,QAApB,CAA6B,KAA7B,CAAoC,EAA1C,CAAN,KAAuDiD,QAA1E;IAAA,CARY,CAAtB;;IASA,QAAQG,aAAa,CAACU,MAAtB;MACE,KAAK,CAAL;QAAQ,MAAM,IAAI7H,2BAAJ,CAAgCgH,QAAQ,CAACjD,QAAT,EAAhC,EAAqDzB,OAArD,CAAN;;MACR,KAAK,CAAL;QAAQ,OAAO6E,aAAa,CAAC,CAAD,CAAb,CAAiB,CAAjB,CAAP;;MACR;QAAS,MAAM,IAAIlH,6BAAJ,CAAkCqC,OAAlC,EAA2C6E,aAA3C,CAAN;IAHX;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACErF,QAAQ,CAACkB,YAAT,GAAwB,UACtBwE,MADsB;IAAA,IAEtB;MAAEM,WAAF;MAAe,GAAGhD;IAAlB,CAFsB,uEAE+B,EAF/B;IAAA,OAGH0C,MAAM,CACxBF,GADkB,CACbD,KAAD,IAAW;MACd,MAAMU,MAAM,GAAGV,KAAK,CAACU,MAAN,CAAaT,GAAb,CAAkBU,CAAD,IAAwBJ,MAAM,CAACI,CAAD,CAA/C,CAAf;MACA,IAAIC,YAAJ;;MACA,IAAI;QACFA,YAAY,GAAGlB,sBAAsB,CAACM,KAAK,CAAC/E,OAAP,EAAgByF,MAAM,CAAC,CAAD,CAAtB,EAA2BjD,GAA3B,CAArC;MACD,CAFD,CAEE,OAAOoB,KAAP,EAAc;QACd,IAAI,CAAC4B,WAAD,aAACA,WAAD,cAACA,WAAD,GAAgB,KAAhB,KAA0B5B,KAAK,YAAYlG,2BAA/C,EAA4E,OAAO,IAAP;QAC5E,MAAMkG,KAAN;MACD;;MACD,MAAMgC,OAAO,GAAGpG,QAAQ,CAACI,QAAT,CAAkBiG,WAAlB,CAA8BF,YAA9B,EAA4CZ,KAAK,CAACe,IAAlD,EAAwDL,MAAxD,CAAhB;MACA,MAAM,CAAC9F,IAAD,EAAOoG,IAAP,IAAe7D,MAAM,CAAC8D,OAAP,CAAeJ,OAAf,EAAwB,CAAxB,CAArB;MACA,OAAO;QACLjG,IADK;QAELoG,IAFK;QAGLzG,QAAQ,EAAE;UACRK,IAAI,EAAEgG,YADE;UAER3F,OAAO,EAAE+E,KAAK,CAAC/E;QAFP;MAHL,CAAP;IAQD,CApBkB,EAoBhB8E,MApBgB,CAoBRmB,CAAD,IAA+CA,CAAC,IAAI,IApB3C,CAHG;EAAA,CAAxB;EAyBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEzG,QAAQ,CAACoB,OAAT,GAAmBsB,MAAM,CAACgE,WAAP,CAAmB1G,QAAQ,CAACX,IAAT,CAAca,UAAd,CAAyBJ,QAAzB,CAAkC6D,SAAlC,CACnC6B,GADmC,CAC/B,SAAyD;IAAA,IAAxD;MAAErF,IAAF;MAAQwG,SAAS,EAAEC,OAAnB;MAA4BC;IAA5B,CAAwD;;IAC5D,MAAMC,UAAU,GAAIpG,UAAD,IAAyB,kBAA0B;MAAA,kCAAhB6F,IAAgB;QAAhBA,IAAgB;MAAA;;MACpE,MAAM3G,OAAO,GAAG2G,IAAI,CAACR,MAAL,KAAgBa,OAAO,CAACb,MAAR,GAAiB,CAAjC,GAAqCQ,IAAI,CAACQ,GAAL,EAArC,GAAkD,EAAlE;MACA,IAAI,OAAOnH,OAAP,KAAmB,QAAvB,EAAiC,MAAM,IAAI9B,SAAJ,CAAe,gCAA+B8B,OAAkB,EAAhE,CAAN;MACjC,IAAIO,IAAI,KAAK,MAAb,EAAqB,OAAOH,QAAQ,CAACe,MAAT,CAAgBwF,IAAhB,EAAsB;QAAE7F,UAAF;QAAc,GAAGd;MAAjB,CAAtB,CAAP;MACrB,OAAOI,QAAQ,CAACgB,IAAT,CAAcb,IAAd,EAAoBoG,IAApB,EAA0B;QAAE7F,UAAF;QAAc,GAAGd;MAAjB,CAA1B,CAAP;IACD,CALD;;IAMA,OAAO,CACLO,IADK,EAELuC,MAAM,CAACC,MAAP,CACEmE,UAAU,CAAC3G,IAAI,KAAK,MAAT,GAAkB,KAAlB,GAA0B,CAAC0G,QAA5B,CADZ,EAEE;MACEG,GAAG,EAAEF,UAAU,CAAC,IAAD,CADjB;MAEE1J,IAAI,EAAE0J,UAAU,CAAC,KAAD;IAFlB,CAFF,CAFK,CAAP;EAUD,CAlBmC,CAAnB,CAAnB;EAoBA,OAAO9G,QAAP;AACD"}