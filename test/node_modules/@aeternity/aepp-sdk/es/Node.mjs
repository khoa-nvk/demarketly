function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

// eslint-disable-next-line max-classes-per-file
import BigNumber from 'bignumber.js';
import { genRequestQueuesPolicy, genCombineGetRequestsPolicy, genErrorFormatterPolicy, genVersionCheckPolicy } from "./utils/autorest.mjs";
import { Node as NodeApi } from "./apis/node/index.mjs";
import { mapObject } from "./utils/other.mjs";
import { MissingParamError } from "./utils/errors.mjs";
/**
 * Obtain networkId from account or node
 */

export async function getNetworkId() {
  var _ref, _await$this$api$getSt, _this$api;

  let {
    networkId
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const res = (_ref = networkId !== null && networkId !== void 0 ? networkId : this.networkId) !== null && _ref !== void 0 ? _ref : (_await$this$api$getSt = await ((_this$api = this.api) === null || _this$api === void 0 ? void 0 : _this$api.getStatus())) === null || _await$this$api$getSt === void 0 ? void 0 : _await$this$api$getSt.networkId;
  if (res != null) return res;
  throw new MissingParamError('networkId is not provided');
}
const bigIntPropertyNames = ['balance', 'queryFee', 'fee', 'amount', 'nameFee', 'channelAmount', 'initiatorAmount', 'responderAmount', 'channelReserve', 'initiatorAmountFinal', 'responderAmountFinal', 'gasPrice', 'deposit'];
const numberPropertyNames = ['time', 'gas', 'gasUsed', 'nameSalt', 'nonce', 'nextNonce', 'height', 'blockHeight', 'top', 'topBlockHeight', 'ttl', 'nameTtl', 'clientTtl', 'inbound', 'outbound', 'peerCount', 'pendingTransactionsCount', 'effectiveAtHeight', 'version', 'solutions', 'round'];

var _mapData = /*#__PURE__*/new WeakSet();

var _encodeArg = /*#__PURE__*/new WeakSet();

var _decodeRes = /*#__PURE__*/new WeakSet();

class NodeTransformed extends NodeApi {
  constructor() {
    super(...arguments);

    _classPrivateMethodInitSpec(this, _decodeRes);

    _classPrivateMethodInitSpec(this, _encodeArg);

    _classPrivateMethodInitSpec(this, _mapData);
  }

  async sendOperationRequest(operationArguments, operationSpec) {
    const args = mapObject(operationArguments, _ref2 => {
      let [key, value] = _ref2;
      return [key, _classPrivateMethodGet(this, _encodeArg, _encodeArg2).call(this, value)];
    });
    return _classPrivateMethodGet(this, _decodeRes, _decodeRes2).call(this, await super.sendOperationRequest(args, operationSpec));
  }

}

function _mapData2(data, transform) {
  if (Array.isArray(data)) return data.map(d => _classPrivateMethodGet(this, _mapData, _mapData2).call(this, d, transform));

  if (data != null && typeof data === 'object') {
    return mapObject(data, _ref5 => {
      let [key, value] = _ref5;
      if (value == null) return [key, value];
      if (bigIntPropertyNames.some(k => k === key)) return [key, transform.bigInt(value)];
      if (numberPropertyNames.some(k => k === key)) return [key, transform.number(value)];
      return [key, _classPrivateMethodGet(this, _mapData, _mapData2).call(this, value, transform)];
    });
  }

  return data;
}

function _encodeArg2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => {
      if (value instanceof BigNumber) return value.toFixed();
      return value.toString();
    },
    number: value => value.toString()
  });
}

function _decodeRes2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => BigInt(value),
    number: value => +value
  });
}

export default class Node extends NodeTransformed {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Don't check node version
   */
  constructor(url) {
    let {
      ignoreVersion = false,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genErrorFormatterPolicy(body => ` ${body.reason}`)],
      ...options
    });
    this.url = url;

    if (!ignoreVersion) {
      const versionPromise = this.getStatus().then(_ref3 => {
        let {
          nodeVersion
        } = _ref3;
        return nodeVersion;
      });
      this.pipeline.addPolicy(genVersionCheckPolicy('node', '/v3/status', versionPromise, '6.2.0', '7.0.0'));
    }

    this.intAsString = true;
  }

  async getNodeInfo() {
    const {
      nodeVersion: version,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(_ref4 => {
      let {
        effectiveAtHeight
      } = _ref4;
      return topBlockHeight >= effectiveAtHeight;
    }).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    return {
      url: this.url,
      nodeNetworkId,
      version,
      consensusProtocolVersion
    };
  }

}
//# sourceMappingURL=Node.mjs.map