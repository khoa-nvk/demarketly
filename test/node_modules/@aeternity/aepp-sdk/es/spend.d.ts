import { sendTransaction, resolveName } from './chain';
import { BuildTxOptions } from './tx';
import { Encoded } from './utils/encoder';
import { Tag, AensName } from './tx/builder/constants';
import AccountBase from './account/Base';
/**
 * Sign and post a transaction to the chain
 * @category chain
 * @param tx - Transaction
 * @param options - Options
 * @param options.verify - Verify transaction before broadcast, throw error if not
 * valid
 * @returns Transaction
 */
export declare function send(tx: Encoded.Transaction, options: SendOptions): Promise<SendReturnType>;
declare type SendOptionsType = Parameters<AccountBase['signTransaction']>[1] & Parameters<typeof sendTransaction>[1] & {
    onAccount: AccountBase;
};
export interface SendOptions extends SendOptionsType {
}
interface SendReturnType extends Awaited<ReturnType<typeof sendTransaction>> {
}
/**
 * Send coins to another account
 * @category chain
 * @param amount - Amount to spend
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
export declare function spend(amount: number | string, recipientIdOrName: Encoded.AccountAddress | AensName, options: SpendOptions): ReturnType<typeof send>;
declare type SpendOptionsType = BuildTxOptions<Tag.SpendTx, 'senderId' | 'recipientId' | 'amount'> & Parameters<typeof resolveName>[2] & {
    onAccount: AccountBase;
} & SendOptions;
interface SpendOptions extends SpendOptionsType {
}
/**
 * Send a fraction of coin balance to another account
 * @category chain
 * @param fraction - Fraction of balance to spend (between 0 and 1)
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
export declare function transferFunds(fraction: number | string, recipientIdOrName: AensName | Encoded.AccountAddress, options: TransferFundsOptions): ReturnType<typeof send>;
declare type TransferFundsOptionsType = BuildTxOptions<Tag.SpendTx, 'senderId' | 'recipientId' | 'amount'> & Parameters<typeof resolveName>[2] & {
    onAccount: AccountBase;
} & SendOptions;
interface TransferFundsOptions extends TransferFundsOptionsType {
}
/**
 * Submit transaction of another account paying for it (fee and gas)
 * @category chain
 * @param transaction - tx_<base64>-encoded transaction
 * @param options - Options
 * @returns Object Transaction
 */
export declare function payForTransaction(transaction: Encoded.Transaction, options: PayForTransactionOptions): ReturnType<typeof send>;
interface PayForTransactionOptions extends BuildTxOptions<Tag.PayingForTx, 'payerId' | 'tx'>, SendOptions {
    onAccount: AccountBase;
}
export {};
