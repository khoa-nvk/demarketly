{"version":3,"file":"chain.mjs","names":["AE_AMOUNT_FORMATS","formatAmount","verifyTransaction","pause","isNameValid","produceNameId","DRY_RUN_ACCOUNT","AensPointerContextError","DryRunError","InvalidAensNameError","TransactionError","TxTimedOutError","TxNotInChainError","InternalError","decode","_getPollInterval","type","_expectedMineRate","_microBlockCycle","_maxPollInterval","base","block","microblock","Math","min","InvalidTxError","constructor","message","validation","transaction","name","getHeight","onNode","getCurrentKeyBlockHeight","height","poll","th","blocks","interval","options","max","tx","getTransactionByHash","blockHeight","awaitHeight","currentHeight","waitForTxConfirm","txHash","confirm","newBlockHeight","sendTransaction","onAccount","verify","waitMined","length","map","v","join","__queue","address","error","postTransaction","requestOptions","customHeaders","pollResult","txData","hash","rawTx","c","undefined","confirmationHeight","Object","assign","verifyTx","getAccount","getAccountByPubkeyAndHeight","getAccountByPubkeyAndHash","getAccountByPubkey","getBalance","format","AETTOS","balance","catch","targetDenomination","getCurrentGeneration","getGeneration","hashOrHeight","getGenerationByHeight","getGenerationByHash","getMicroBlockTransactions","getMicroBlockTransactionsByHash","transactions","getKeyBlock","getKeyBlockByHeight","getKeyBlockByHash","getMicroBlockHeader","getMicroBlockHeaderByHash","txDryRunRequests","Map","txDryRunHandler","key","rs","get","delete","dryRunRes","protectedDryRunTxs","top","txEvents","txs","req","accounts","Array","from","Set","accountAddress","pubKey","amount","forEach","reject","results","idx","result","reason","resultPayload","resolve","txDryRun","combine","requests","set","Promise","push","timeout","setTimeout","getContractByteCode","contractId","getContractCode","getContract","getName","getNameEntryByName","resolveName","nameOrId","resolveByNode","pointer","pointers","find","p","id"],"sources":["../src/chain.ts"],"sourcesContent":["/*\n * ISC License (ISC)\n * Copyright (c) 2022 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\nimport { AE_AMOUNT_FORMATS, formatAmount } from './utils/amount-formatter';\nimport verifyTransaction, { ValidatorResult } from './tx/validator';\nimport { pause } from './utils/other';\nimport { isNameValid, produceNameId } from './tx/builder/helpers';\nimport { DRY_RUN_ACCOUNT } from './tx/builder/schema';\nimport { AensName } from './tx/builder/constants';\nimport {\n  AensPointerContextError, DryRunError, InvalidAensNameError, TransactionError,\n  TxTimedOutError, TxNotInChainError, InternalError,\n} from './utils/errors';\nimport Node, { TransformNodeType } from './Node';\nimport {\n  Account as AccountNode, ByteCode, ContractObject, DryRunResult, DryRunResults,\n  Generation, KeyBlock, MicroBlockHeader, NameEntry, SignedTx,\n} from './apis/node';\nimport { decode, Encoded, Encoding } from './utils/encoder';\nimport AccountBase from './account/Base';\n\n/**\n * @category chain\n */\nexport function _getPollInterval(\n  type: 'block' | 'microblock',\n  { _expectedMineRate = 180000, _microBlockCycle = 3000, _maxPollInterval = 5000 }:\n  { _expectedMineRate?: number; _microBlockCycle?: number; _maxPollInterval?: number },\n): number {\n  const base = {\n    block: _expectedMineRate,\n    microblock: _microBlockCycle,\n  }[type];\n  return Math.min(base / 3, _maxPollInterval);\n}\n\n/**\n * @category exception\n */\nexport class InvalidTxError extends TransactionError {\n  validation: ValidatorResult[];\n\n  transaction: Encoded.Transaction;\n\n  constructor(\n    message: string,\n    validation: ValidatorResult[],\n    transaction: Encoded.Transaction,\n  ) {\n    super(message);\n    this.name = 'InvalidTxError';\n    this.validation = validation;\n    this.transaction = transaction;\n  }\n}\n\n/**\n * Obtain current height of the chain\n * @category chain\n * @returns Current chain height\n */\nexport async function getHeight({ onNode }: { onNode: Node }): Promise<number> {\n  return (await onNode.getCurrentKeyBlockHeight()).height;\n}\n\n/**\n * Wait for a transaction to be mined\n * @category chain\n * @param th - The hash of transaction to poll\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.blocks - Number of blocks mined after which to fail\n * @param options.onNode - Node to use\n * @returns The transaction as it was mined\n */\nexport async function poll(\n  th: Encoded.TxHash,\n  {\n    blocks = 10, interval, onNode, ...options\n  }:\n  { blocks?: number; interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<TransformNodeType<SignedTx>> {\n  interval ??= _getPollInterval('microblock', options);\n  const max = await getHeight({ onNode }) + blocks;\n  do {\n    const tx = await onNode.getTransactionByHash(th);\n    if (tx.blockHeight !== -1) return tx;\n    await pause(interval);\n  } while (await getHeight({ onNode }) < max);\n  throw new TxTimedOutError(blocks, th);\n}\n\n/**\n * Wait for the chain to reach a specific height\n * @category chain\n * @param height - Height to wait for\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.onNode - Node to use\n * @returns Current chain height\n */\nexport async function awaitHeight(\n  height: number,\n  { interval, onNode, ...options }:\n  { interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<number> {\n  interval ??= _getPollInterval('block', options);\n  let currentHeight;\n  do {\n    if (currentHeight != null) await pause(interval);\n    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;\n  } while (currentHeight < height);\n  return currentHeight;\n}\n\n/**\n * Wait for transaction confirmation\n * @category chain\n * @param txHash - Transaction hash\n * @param options - Options\n * @param options.confirm - Number of micro blocks to wait for transaction confirmation\n * @param options.onNode - Node to use\n * @returns Current Height\n */\nexport async function waitForTxConfirm(\n  txHash: Encoded.TxHash,\n  { confirm = 3, onNode, ...options }:\n  { confirm?: number; onNode: Node } & Parameters<typeof awaitHeight>[1],\n): Promise<number> {\n  const { blockHeight } = await onNode.getTransactionByHash(txHash);\n  const height = await awaitHeight(blockHeight + confirm, { onNode, ...options });\n  const { blockHeight: newBlockHeight } = await onNode.getTransactionByHash(txHash);\n  switch (newBlockHeight) {\n    case -1:\n      throw new TxNotInChainError(txHash);\n    case blockHeight:\n      return height;\n    default:\n      return waitForTxConfirm(txHash, { onNode, confirm, ...options });\n  }\n}\n\n/**\n * Submit a signed transaction for mining\n * @category chain\n * @param tx - Transaction to submit\n * @param options - Options\n * @param options.onNode - Node to use\n * @param options.onAccount - Account to use\n * @param options.verify - Verify transaction before sending\n * @param options.waitMined - Ensure that transaction get into block\n * @param options.confirm - Number of micro blocks that should be mined after tx get included\n * @returns Transaction details\n */\nexport async function sendTransaction(\n  tx: Encoded.Transaction,\n  {\n    onNode, onAccount, verify = true, waitMined = true, confirm, ...options\n  }:\n  SendTransactionOptions,\n): Promise<SendTransactionReturnType> {\n  if (verify) {\n    const validation = await verifyTransaction(tx, onNode);\n    if (validation.length > 0) {\n      const message = `Transaction verification errors: ${\n        validation.map((v: { message: string }) => v.message).join(', ')}`;\n      throw new InvalidTxError(message, validation, tx);\n    }\n  }\n\n  try {\n    let __queue;\n    try {\n      __queue = onAccount != null ? `tx-${await onAccount.address(options)}` : null;\n    } catch (error) {\n      __queue = null;\n    }\n    const { txHash } = await onNode.postTransaction(\n      { tx },\n      __queue != null ? { requestOptions: { customHeaders: { __queue } } } : {},\n    );\n\n    if (waitMined) {\n      const pollResult = await poll(txHash, { onNode, ...options });\n      const txData = {\n        ...pollResult,\n        hash: pollResult.hash as Encoded.TxHash,\n        rawTx: tx,\n      };\n      // wait for transaction confirmation\n      if (confirm != null && (confirm === true || confirm > 0)) {\n        const c = typeof confirm === 'boolean' ? undefined : confirm;\n        return {\n          ...txData,\n          confirmationHeight: await waitForTxConfirm(txHash, { onNode, confirm: c, ...options }),\n        };\n      }\n      return txData;\n    }\n    return { hash: txHash, rawTx: tx };\n  } catch (error) {\n    throw Object.assign(error, {\n      rawTx: tx,\n      verifyTx: async () => verifyTransaction(tx, onNode),\n    });\n  }\n}\n\ntype SendTransactionOptionsType = {\n  onNode: Node;\n  onAccount?: AccountBase;\n  verify?: boolean;\n  waitMined?: boolean;\n  confirm?: boolean | number;\n} & Parameters<typeof poll>[1] & Omit<Parameters<typeof waitForTxConfirm>[1], 'confirm'>;\ninterface SendTransactionOptions extends SendTransactionOptionsType {}\ninterface SendTransactionReturnType extends Partial<TransformNodeType<SignedTx>> {\n  hash: Encoded.TxHash;\n  rawTx: Encoded.Transaction;\n  confirmationHeight?: number;\n}\n\n/**\n * Get account by account public key\n * @category chain\n * @param address - Account address (public key)\n * @param options - Options\n * @param options.height - Get account on specific block by block height\n * @param options.hash - Get account on specific block by micro block hash or key block hash\n * @param options.onNode - Node to use\n */\nexport async function getAccount(\n  address: Encoded.AccountAddress | Encoded.ContractAddress,\n  { height, hash, onNode }:\n  { height?: number; hash?: Encoded.KeyBlockHash | Encoded.MicroBlockHash; onNode: Node },\n): Promise<TransformNodeType<AccountNode>> {\n  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);\n  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);\n  return onNode.getAccountByPubkey(address);\n}\n\n/**\n * Request the balance of specified account\n * @category chain\n * @param address - The public account address to obtain the balance for\n * @param options - Options\n * @param options.format\n * @param options.height - The chain height at which to obtain the balance for\n * (default: top of chain)\n * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)\n */\nexport async function getBalance(\n  address: Encoded.AccountAddress | Encoded.ContractAddress,\n  { format = AE_AMOUNT_FORMATS.AETTOS, ...options }:\n  { format?: AE_AMOUNT_FORMATS } & Parameters<typeof getAccount>[1],\n): Promise<string> {\n  const { balance } = await getAccount(address, options).catch(() => ({ balance: 0n }));\n\n  return formatAmount(balance, { targetDenomination: format });\n}\n\n/**\n * Obtain current generation\n * @category chain\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Current Generation\n */\nexport async function getCurrentGeneration(\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<Generation>> {\n  return onNode.getCurrentGeneration();\n}\n\n/**\n * Get generation by hash or height\n * @category chain\n * @param hashOrHeight - Generation hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Generation\n */\nexport async function getGeneration(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<Generation>> {\n  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);\n  return onNode.getGenerationByHash(hashOrHeight);\n}\n\n/**\n * Get micro block transactions\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transactions\n */\nexport async function getMicroBlockTransactions(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<SignedTx[]>> {\n  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;\n}\n\n/**\n * Get key block\n * @category chain\n * @param hashOrHeight - Key block hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Key Block\n */\nexport async function getKeyBlock(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<KeyBlock>> {\n  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);\n  return onNode.getKeyBlockByHash(hashOrHeight);\n}\n\n/**\n * Get micro block header\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Micro block header\n */\nexport async function getMicroBlockHeader(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<MicroBlockHeader>> {\n  return onNode.getMicroBlockHeaderByHash(hash);\n}\n\ninterface TxDryRunArguments {\n  tx: Encoded.Transaction;\n  accountAddress: Encoded.AccountAddress;\n  top?: number;\n  txEvents?: any;\n  resolve: Function;\n  reject: Function;\n}\nconst txDryRunRequests: Map<string, TxDryRunArguments[] & { timeout?: NodeJS.Timeout }> = new Map();\n\nasync function txDryRunHandler(key: string, onNode: Node): Promise<void> {\n  const rs = txDryRunRequests.get(key);\n  txDryRunRequests.delete(key);\n  if (rs == null) throw new InternalError('Can\\'t get dry-run request');\n\n  let dryRunRes;\n  try {\n    dryRunRes = await onNode.protectedDryRunTxs({\n      top: rs[0].top,\n      txEvents: rs[0].txEvents,\n      txs: rs.map((req) => ({ tx: req.tx })),\n      accounts: Array.from(new Set(rs.map((req) => req.accountAddress)))\n        .map((pubKey) => ({ pubKey, amount: DRY_RUN_ACCOUNT.amount })),\n    });\n  } catch (error) {\n    rs.forEach(({ reject }) => reject(error));\n    return;\n  }\n\n  const { results, txEvents } = dryRunRes;\n  results.forEach(({ result, reason, ...resultPayload }, idx) => {\n    const {\n      resolve, reject, tx, accountAddress,\n    } = rs[idx];\n    if (result === 'ok') resolve({ ...resultPayload, txEvents });\n    else reject(Object.assign(new DryRunError(reason as string), { tx, accountAddress }));\n  });\n}\n\n/**\n * Transaction dry-run\n * @category chain\n * @param tx - transaction to execute\n * @param accountAddress - address that will be used to execute transaction\n * @param options - Options\n * @param options.top - hash of block on which to make dry-run\n * @param options.txEvents - collect and return on-chain tx events that would result from the call\n * @param options.combine - Enables combining of similar requests to a single dry-run call\n * @param options.onNode - Node to use\n */\nexport async function txDryRun(\n  tx: Encoded.Transaction,\n  accountAddress: Encoded.AccountAddress,\n  {\n    top, txEvents, combine, onNode,\n  }:\n  { top?: number; txEvents?: boolean; combine?: boolean; onNode: Node },\n): Promise<{\n    txEvents?: TransformNodeType<DryRunResults['txEvents']>;\n  } & TransformNodeType<DryRunResult>> {\n  const key = combine === true ? [top, txEvents].join() : 'immediate';\n  const requests = txDryRunRequests.get(key) ?? [];\n  txDryRunRequests.set(key, requests);\n  return new Promise((resolve, reject) => {\n    requests.push({\n      tx, accountAddress, top, txEvents, resolve, reject,\n    });\n    if (combine !== true) {\n      void txDryRunHandler(key, onNode);\n      return;\n    }\n    requests.timeout ??= setTimeout(() => { void txDryRunHandler(key, onNode); });\n  });\n}\n\n/**\n * Get contract byte code\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContractByteCode(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<ByteCode>> {\n  return onNode.getContractCode(contractId);\n}\n\n/**\n * Get contract entry\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContract(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<ContractObject>> {\n  return onNode.getContract(contractId);\n}\n\n/**\n * Get name entry\n * @category AENS\n * @param name - AENS name\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getName(\n  name: AensName,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<NameEntry>> {\n  return onNode.getNameEntryByName(name);\n}\n\n/**\n * Resolve AENS name and return name hash\n * @category AENS\n * @param nameOrId - AENS name or address\n * @param key - in AENS pointers record\n * @param options - Options\n * @param options.verify - To ensure that name exist and have a corresponding pointer\n * // TODO: avoid that to don't trust to current api gateway\n * @param options.resolveByNode - Enables pointer resolving using node\n * @param options.onNode - Node to use\n * @returns Address or AENS name hash\n */\nexport async function resolveName <\n  Type extends Encoding.AccountAddress | Encoding.ContractAddress,\n>(\n  nameOrId: AensName | Encoded.Generic<Type>,\n  key: string,\n  { verify = true, resolveByNode = false, onNode }:\n  { verify?: boolean; resolveByNode?: boolean; onNode: Node },\n): Promise<Encoded.Generic<Type | Encoding.Name>> {\n  if (isNameValid(nameOrId)) {\n    if (verify || resolveByNode) {\n      const name = await onNode.getNameEntryByName(nameOrId);\n      const pointer = name.pointers.find((p) => p.key === key);\n      if (pointer == null) throw new AensPointerContextError(nameOrId, key);\n      if (resolveByNode) return pointer.id as Encoded.Generic<Type>;\n    }\n    return produceNameId(nameOrId);\n  }\n  try {\n    decode(nameOrId);\n    return nameOrId;\n  } catch (error) {\n    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);\n  }\n}\n"],"mappings":"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"}