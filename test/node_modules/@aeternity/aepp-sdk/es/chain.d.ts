import { AE_AMOUNT_FORMATS } from './utils/amount-formatter';
import { ValidatorResult } from './tx/validator';
import { AensName } from './tx/builder/constants';
import { TransactionError } from './utils/errors';
import Node, { TransformNodeType } from './Node';
import { Account as AccountNode, ByteCode, ContractObject, DryRunResult, DryRunResults, Generation, KeyBlock, MicroBlockHeader, NameEntry, SignedTx } from './apis/node';
import { Encoded, Encoding } from './utils/encoder';
import AccountBase from './account/Base';
/**
 * @category chain
 */
export declare function _getPollInterval(type: 'block' | 'microblock', { _expectedMineRate, _microBlockCycle, _maxPollInterval }: {
    _expectedMineRate?: number;
    _microBlockCycle?: number;
    _maxPollInterval?: number;
}): number;
/**
 * @category exception
 */
export declare class InvalidTxError extends TransactionError {
    validation: ValidatorResult[];
    transaction: Encoded.Transaction;
    constructor(message: string, validation: ValidatorResult[], transaction: Encoded.Transaction);
}
/**
 * Obtain current height of the chain
 * @category chain
 * @returns Current chain height
 */
export declare function getHeight({ onNode }: {
    onNode: Node;
}): Promise<number>;
/**
 * Wait for a transaction to be mined
 * @category chain
 * @param th - The hash of transaction to poll
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.blocks - Number of blocks mined after which to fail
 * @param options.onNode - Node to use
 * @returns The transaction as it was mined
 */
export declare function poll(th: Encoded.TxHash, { blocks, interval, onNode, ...options }: {
    blocks?: number;
    interval?: number;
    onNode: Node;
} & Parameters<typeof _getPollInterval>[1]): Promise<TransformNodeType<SignedTx>>;
/**
 * Wait for the chain to reach a specific height
 * @category chain
 * @param height - Height to wait for
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.onNode - Node to use
 * @returns Current chain height
 */
export declare function awaitHeight(height: number, { interval, onNode, ...options }: {
    interval?: number;
    onNode: Node;
} & Parameters<typeof _getPollInterval>[1]): Promise<number>;
/**
 * Wait for transaction confirmation
 * @category chain
 * @param txHash - Transaction hash
 * @param options - Options
 * @param options.confirm - Number of micro blocks to wait for transaction confirmation
 * @param options.onNode - Node to use
 * @returns Current Height
 */
export declare function waitForTxConfirm(txHash: Encoded.TxHash, { confirm, onNode, ...options }: {
    confirm?: number;
    onNode: Node;
} & Parameters<typeof awaitHeight>[1]): Promise<number>;
/**
 * Submit a signed transaction for mining
 * @category chain
 * @param tx - Transaction to submit
 * @param options - Options
 * @param options.onNode - Node to use
 * @param options.onAccount - Account to use
 * @param options.verify - Verify transaction before sending
 * @param options.waitMined - Ensure that transaction get into block
 * @param options.confirm - Number of micro blocks that should be mined after tx get included
 * @returns Transaction details
 */
export declare function sendTransaction(tx: Encoded.Transaction, { onNode, onAccount, verify, waitMined, confirm, ...options }: SendTransactionOptions): Promise<SendTransactionReturnType>;
declare type SendTransactionOptionsType = {
    onNode: Node;
    onAccount?: AccountBase;
    verify?: boolean;
    waitMined?: boolean;
    confirm?: boolean | number;
} & Parameters<typeof poll>[1] & Omit<Parameters<typeof waitForTxConfirm>[1], 'confirm'>;
interface SendTransactionOptions extends SendTransactionOptionsType {
}
interface SendTransactionReturnType extends Partial<TransformNodeType<SignedTx>> {
    hash: Encoded.TxHash;
    rawTx: Encoded.Transaction;
    confirmationHeight?: number;
}
/**
 * Get account by account public key
 * @category chain
 * @param address - Account address (public key)
 * @param options - Options
 * @param options.height - Get account on specific block by block height
 * @param options.hash - Get account on specific block by micro block hash or key block hash
 * @param options.onNode - Node to use
 */
export declare function getAccount(address: Encoded.AccountAddress | Encoded.ContractAddress, { height, hash, onNode }: {
    height?: number;
    hash?: Encoded.KeyBlockHash | Encoded.MicroBlockHash;
    onNode: Node;
}): Promise<TransformNodeType<AccountNode>>;
/**
 * Request the balance of specified account
 * @category chain
 * @param address - The public account address to obtain the balance for
 * @param options - Options
 * @param options.format
 * @param options.height - The chain height at which to obtain the balance for
 * (default: top of chain)
 * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)
 */
export declare function getBalance(address: Encoded.AccountAddress | Encoded.ContractAddress, { format, ...options }: {
    format?: AE_AMOUNT_FORMATS;
} & Parameters<typeof getAccount>[1]): Promise<string>;
/**
 * Obtain current generation
 * @category chain
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Current Generation
 */
export declare function getCurrentGeneration({ onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<Generation>>;
/**
 * Get generation by hash or height
 * @category chain
 * @param hashOrHeight - Generation hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Generation
 */
export declare function getGeneration(hashOrHeight: Encoded.KeyBlockHash | number, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<Generation>>;
/**
 * Get micro block transactions
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transactions
 */
export declare function getMicroBlockTransactions(hash: Encoded.MicroBlockHash, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<SignedTx[]>>;
/**
 * Get key block
 * @category chain
 * @param hashOrHeight - Key block hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Key Block
 */
export declare function getKeyBlock(hashOrHeight: Encoded.KeyBlockHash | number, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<KeyBlock>>;
/**
 * Get micro block header
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Micro block header
 */
export declare function getMicroBlockHeader(hash: Encoded.MicroBlockHash, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<MicroBlockHeader>>;
/**
 * Transaction dry-run
 * @category chain
 * @param tx - transaction to execute
 * @param accountAddress - address that will be used to execute transaction
 * @param options - Options
 * @param options.top - hash of block on which to make dry-run
 * @param options.txEvents - collect and return on-chain tx events that would result from the call
 * @param options.combine - Enables combining of similar requests to a single dry-run call
 * @param options.onNode - Node to use
 */
export declare function txDryRun(tx: Encoded.Transaction, accountAddress: Encoded.AccountAddress, { top, txEvents, combine, onNode, }: {
    top?: number;
    txEvents?: boolean;
    combine?: boolean;
    onNode: Node;
}): Promise<{
    txEvents?: TransformNodeType<DryRunResults['txEvents']>;
} & TransformNodeType<DryRunResult>>;
/**
 * Get contract byte code
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */
export declare function getContractByteCode(contractId: Encoded.ContractAddress, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<ByteCode>>;
/**
 * Get contract entry
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */
export declare function getContract(contractId: Encoded.ContractAddress, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<ContractObject>>;
/**
 * Get name entry
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onNode - Node to use
 */
export declare function getName(name: AensName, { onNode }: {
    onNode: Node;
}): Promise<TransformNodeType<NameEntry>>;
/**
 * Resolve AENS name and return name hash
 * @category AENS
 * @param nameOrId - AENS name or address
 * @param key - in AENS pointers record
 * @param options - Options
 * @param options.verify - To ensure that name exist and have a corresponding pointer
 * // TODO: avoid that to don't trust to current api gateway
 * @param options.resolveByNode - Enables pointer resolving using node
 * @param options.onNode - Node to use
 * @returns Address or AENS name hash
 */
export declare function resolveName<Type extends Encoding.AccountAddress | Encoding.ContractAddress>(nameOrId: AensName | Encoded.Generic<Type>, key: string, { verify, resolveByNode, onNode }: {
    verify?: boolean;
    resolveByNode?: boolean;
    onNode: Node;
}): Promise<Encoded.Generic<Type | Encoding.Name>>;
export {};
