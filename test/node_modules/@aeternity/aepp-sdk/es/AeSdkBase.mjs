import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import * as chainMethods from "./chain.mjs";
import * as txMethods from "./tx/index.mjs";
import * as aensMethods from "./aens.mjs";
import * as spendMethods from "./spend.mjs";
import * as oracleMethods from "./oracle.mjs";
import * as contractMethods from "./contract/methods.mjs";
import * as contractGaMethods from "./contract/ga.mjs";
import * as deprecatedMethods from "./deprecated/methods.mjs";
import { _buildTx } from "./tx/index.mjs";
import { mapObject } from "./utils/other.mjs";
import { getNetworkId } from "./Node.mjs";
import { AE_AMOUNT_FORMATS } from "./utils/amount-formatter.mjs";
import { AMOUNT } from "./tx/builder/schema.mjs";
import MemoryAccount from "./account/Memory.mjs";
import { isAccountBase } from "./account/Base.mjs";
import { CompilerError, DuplicateNodeError, NodeNotFoundError, NotImplementedError, TypeError } from "./utils/errors.mjs";
import Compiler from "./contract/Compiler.mjs";

function getValueOrErrorProxy(valueCb) {
  try {
    return valueCb();
  } catch (error) {
    return new Proxy({}, Object.fromEntries(['get', 'set', 'has'].map(name => [name, () => {
      throw error;
    }])));
  }
}
/**
 * Basic AeSdk class
 *
 * AeSdkBase objects are the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 * Only by providing the joint functionality of them, most more advanced
 * operations, i.e. the ones with actual use value on the chain, become
 * available.
 */


class AeSdkBase {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   * @param options.compilerUrl - Url for compiler API
   * @param options.ignoreVersion - Don't check node or compiler version
   */
  constructor() {
    let {
      nodes = [],
      compilerUrl,
      ignoreVersion = false,
      ...options
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _defineProperty(this, "_options", {
      denomination: AE_AMOUNT_FORMATS.AETTOS,
      amount: AMOUNT
    });

    _defineProperty(this, "pool", new Map());

    _defineProperty(this, "getNetworkId", getNetworkId);

    Object.assign(this._options, options);
    nodes.forEach((_ref, i) => {
      let {
        name,
        instance
      } = _ref;
      return this.addNode(name, instance, i === 0);
    });

    if (compilerUrl == null) {
      this.compilerApi = getValueOrErrorProxy(() => {
        throw new CompilerError('You can\'t use Compiler API. Compiler is not ready!');
      });
    } else this.setCompilerUrl(compilerUrl, {
      ignoreVersion
    });
  }

  setCompilerUrl(compilerUrl) {
    let {
      ignoreVersion = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.compilerApi = new Compiler(compilerUrl, {
      ignoreVersion
    });
  }

  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }
  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */


  addNode(name, node) {
    let select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);

    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }
  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */


  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }
  /**
   * Get NetworkId of current Node
   * @example
   * nodePool.getNetworkId()
   */


  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }

  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError('You can\'t use Node API. Node is not connected or not defined!');
    }
  }
  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */


  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }
  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */


  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async _ref2 => {
      let [name, node] = _ref2;
      return {
        name,
        ...(await node.getNodeInfo())
      };
    }));
  } // eslint-disable-next-line class-methods-use-this


  addresses() {
    return [];
  }

  async address() {
    let {
      onAccount
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this._resolveAccount(onAccount).address();
  }

  async sign(data) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).sign(data, options);
  }

  async signTransaction(tx) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).signTransaction(tx, { ...options,
      networkId: await this.getNetworkId(options)
    });
  }

  async signMessage(message) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).signMessage(message, options);
  }

  async verifyMessage(message, signature) {
    let {
      onAccount,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this._resolveAccount(onAccount).verifyMessage(message, signature, options);
  }
  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  // eslint-disable-next-line class-methods-use-this


  _resolveAccount(account) {
    switch (account !== null && typeof account) {
      case 'string':
        throw new NotImplementedError('Address in AccountResolver');

      case 'object':
        return isAccountBase(account) ? account : new MemoryAccount({
          keypair: account
        });

      default:
        throw new TypeError('Account should be an address (ak-prefixed string), ' + `keypair, or instance of AccountBase, got ${String(account)} instead`);
    }
  }

  _getOptions() {
    return { ...this._options,
      onNode: getValueOrErrorProxy(() => this.api),
      onAccount: getValueOrErrorProxy(() => this._resolveAccount()),
      onCompiler: getValueOrErrorProxy(() => this.compilerApi)
    };
  }

  async buildTx(txType, options) {
    // @ts-expect-error TODO: need to figure out what's wrong here
    return _buildTx(txType, { ...this._getOptions(),
      ...options
    });
  }

}

const {
  _buildTx: _,
  ...txMethodsOther
} = txMethods;
const {
  InvalidTxError: _2,
  ...chainMethodsOther
} = chainMethods;
const methods = { ...chainMethodsOther,
  ...txMethodsOther,
  ...aensMethods,
  ...spendMethods,
  ...oracleMethods,
  ...contractMethods,
  ...contractGaMethods,
  ...deprecatedMethods
};
Object.assign(AeSdkBase.prototype, mapObject(methods, _ref3 => {
  let [name, handler] = _ref3;
  return [name, function methodWrapper() {
    const instanceOptions = this._getOptions();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    const lastArg = args[args.length - 1];

    if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
      args[args.length - 1] = { ...instanceOptions,
        ...lastArg,
        ...(lastArg.onAccount != null && {
          onAccount: this._resolveAccount(lastArg.onAccount)
        })
      };
    } else args.push(instanceOptions);

    return handler(...args);
  }];
}));
export default AeSdkBase;
//# sourceMappingURL=AeSdkBase.mjs.map