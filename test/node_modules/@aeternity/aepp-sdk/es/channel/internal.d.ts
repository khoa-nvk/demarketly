/// <reference types="node" />
import { EventEmitter } from 'events';
import BigNumber from 'bignumber.js';
import type Channel from '.';
import { Encoded } from '../utils/encoder';
import { BaseError } from '../utils/errors';
interface ChannelAction {
    guard: (channel: Channel, state?: ChannelFsm) => boolean;
    action: (channel: Channel, state?: ChannelFsm) => ChannelFsm;
}
export declare type SignTxWithTag = (tag: string, tx: Encoded.Transaction, options?: object) => (Promise<Encoded.Transaction>);
export declare type SignTx = (tx: Encoded.Transaction, options?: object) => (Promise<Encoded.Transaction | number | null>);
export interface ChannelOptions {
    existingFsmId?: string;
    url: string;
    role: 'initiator' | 'responder';
    initiatorId: Encoded.AccountAddress;
    responderId: Encoded.AccountAddress;
    pushAmount: number;
    initiatorAmount: BigNumber;
    responderAmount: BigNumber;
    channelReserve?: BigNumber | number;
    signedTx?: string;
    ttl?: number;
    host: string;
    port: number;
    lockPeriod: number;
    existingChannelId?: string;
    offChainTx?: string;
    reconnectTx?: string;
    timeoutIdle?: number;
    timeoutFundingCreate?: number;
    timeoutFundingSign?: number;
    timeoutFundingLock?: number;
    timeoutSign?: number;
    timeoutAccept?: number;
    timeoutInitialized?: number;
    timeoutAwaitingOpen?: number;
    statePassword?: string;
    debug: boolean;
    sign: SignTxWithTag;
    offchainTx?: string;
}
export interface ChannelHandler extends Function {
    enter?: Function;
}
export interface ChannelState {
    signedTx: any;
    resolve: (r?: any) => void;
    reject: (e: BaseError) => void;
    sign: SignTx;
    handler?: ChannelHandler;
    onOnChainTx?: (tx: Encoded.Transaction) => void;
    onOwnWithdrawLocked?: () => void;
    onWithdrawLocked?: () => void;
    onOwnDepositLocked?: () => void;
    onDepositLocked?: () => void;
    closeTx?: string;
}
export interface ChannelFsm {
    handler: ChannelHandler;
    state?: ChannelState | {
        resolve: Function;
        reject: Function;
    };
}
export interface ChannelMessage {
    id?: number;
    jsonrpc: string;
    method: string;
    params: any;
    payload?: any;
    data?: any;
    error?: ChannelMessageError;
}
interface ChannelMessageError {
    code: number;
    message: string;
    data: [
        {
            message: string;
            code: number;
        }
    ];
    request: ChannelMessage;
}
export declare const options: WeakMap<Channel, ChannelOptions>;
export declare const status: WeakMap<Channel, string>;
export declare const state: WeakMap<Channel, `tx_${string}`>;
export declare const eventEmitters: WeakMap<Channel, EventEmitter>;
export declare const channelId: WeakMap<Channel, string>;
export declare const fsmId: WeakMap<Channel, string>;
export declare function emit(channel: Channel, ...args: any[]): void;
export declare function changeStatus(channel: Channel, newStatus: string): void;
export declare function changeState(channel: Channel, newState: Encoded.Transaction): void;
export declare function send(channel: Channel, message: ChannelMessage): void;
export declare function enqueueAction(channel: Channel, guard: ChannelAction['guard'], action: ChannelAction['action']): void;
export declare function disconnect(channel: Channel): void;
export declare function call(channel: Channel, method: string, params: any): Promise<any>;
export declare function initialize(channel: Channel, connectionHandler: Function, openHandler: Function, { url, ...channelOptions }: ChannelOptions): Promise<void>;
export {};
