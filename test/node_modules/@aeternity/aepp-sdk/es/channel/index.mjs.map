{"version":3,"file":"index.mjs","names":["snakeToPascal","buildTx","unpackTx","MIN_GAS_PRICE","Tag","handlers","eventEmitters","status","channelStatus","state","channelState","initialize","enqueueAction","send","channelId","call","disconnect","channelDisconnect","fsmId","channelFsmId","UnknownChannelStateError","ChannelError","pause","snakeToPascalObjKeys","obj","Object","entries","reduce","result","key","val","Channel","options","channel","existingFsmId","awaitingReconnection","awaitingConnection","channelOpen","on","eventName","callback","eventEmitter","get","off","removeListener","round","txType","tx","SignedTx","encodedTx","ChannelCreateTx","ChannelOffChainTx","ChannelWithdrawTx","ChannelDepositTx","id","update","from","to","amount","sign","metadata","Promise","resolve","reject","_channel","handler","jsonrpc","method","params","meta","awaitingOffChainTx","poi","accounts","contracts","balances","fromEntries","map","item","account","balance","leave","awaitingLeave","shutdown","awaitingShutdownTx","withdraw","onOnChainTx","onOwnWithdrawLocked","onWithdrawLocked","awaitingWithdrawTx","deposit","onOwnDepositLocked","onDepositLocked","awaitingDepositTx","createContract","code","callData","vmVersion","abiVersion","call_data","vm_version","abi_version","awaitingNewContractTx","callContract","contract","contract_id","awaitingCallContractUpdateTx","forceProgress","gasLimit","gasPrice","gas_price","gas","awaitingCallContractForceProgressUpdate","callContractStatic","getContractCall","caller","caller_id","getContractState","pubkey","cleanContractCalls","awaitingCallsPruned","sendMessage","message","recipient","info","JSON","stringify","onStatusChanged","reconnect","txParams","reconnectTx","ChannelClientReconnectTx"],"sources":["../../src/channel/index.ts"],"sourcesContent":["/*\n * ISC License (ISC)\n * Copyright (c) 2018 aeternity developers\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n *  PERFORMANCE OF THIS SOFTWARE.\n */\nimport BigNumber from 'bignumber.js';\nimport { snakeToPascal } from '../utils/string';\nimport { buildTx, unpackTx } from '../tx/builder';\nimport { MIN_GAS_PRICE, Tag } from '../tx/builder/constants';\nimport * as handlers from './handlers';\nimport {\n  eventEmitters,\n  status as channelStatus,\n  state as channelState,\n  initialize,\n  enqueueAction,\n  send,\n  channelId,\n  call,\n  disconnect as channelDisconnect,\n  fsmId as channelFsmId,\n  SignTx,\n  ChannelOptions,\n  ChannelState,\n} from './internal';\nimport { UnknownChannelStateError, ChannelError } from '../utils/errors';\nimport { Encoded } from '../utils/encoder';\nimport { ContractCallReturnType } from '../apis/node';\nimport { pause } from '../utils/other';\n\nfunction snakeToPascalObjKeys<Type>(obj: object): Type {\n  return Object.entries(obj).reduce((result, [key, val]) => ({\n    ...result,\n    [snakeToPascal(key)]: val,\n  }), {}) as Type;\n}\n\ntype EventCallback = (...args: any[]) => void;\n\ninterface CallContractOptions {\n  amount?: number | BigNumber;\n  callData?: Encoded.ContractBytearray;\n  abiVersion?: number;\n  contract?: Encoded.ContractAddress;\n  returnValue?: any;\n  gasUsed?: number | BigNumber;\n  gasPrice?: number | BigNumber;\n  height?: number;\n  callerNonce?: number;\n  log?: any;\n  returnType?: ContractCallReturnType;\n}\n\ninterface Contract {\n  abiVersion: number;\n  active: boolean;\n  deposit: number | BigNumber;\n  id: string;\n  ownerId: string;\n  referrerIds: string[];\n  vmVersion: number;\n}\n\n/**\n * Channel\n * @example\n * ```js\n * await Channel.initialize({\n *   url: 'ws://localhost:3001',\n *   role: 'initiator'\n *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   initiatorAmount: 1e18,\n *   responderAmount: 1e18,\n *   pushAmount: 0,\n *   channelReserve: 0,\n *   ttl: 1000,\n *   host: 'localhost',\n *   port: 3002,\n *   lockPeriod: 10,\n *   async sign (tag, tx) => await account.signTransaction(tx)\n * })\n * ```\n */\nexport default class Channel {\n  /**\n   * @param options - Channel params\n   * @param options.url - Channel url (for example: \"ws://localhost:3001\")\n   * @param options.role - Participant role (\"initiator\" or \"responder\")\n   * @param options.initiatorId - Initiator's public key\n   * @param options.responderId - Responder's public key\n   * @param options.pushAmount - Initial deposit in favour of the responder by the initiator\n   * @param options.initiatorAmount - Amount of coins the initiator has committed to\n   * the channel\n   * @param options.responderAmount - Amount of coins the responder has committed to\n   * the channel\n   * @param options.channelReserve - The minimum amount both peers need to maintain\n   * @param options.ttl - Minimum block height to include the channel_create_tx\n   * @param options.host - Host of the responder's node\n   * @param options.port - The port of the responders node\n   * @param options.lockPeriod - Amount of blocks for disputing a solo close\n   * @param options.existingChannelId - Existing channel id (required if reestablishing a\n   * channel)\n   * @param options.offchainTx - Offchain transaction (required if reestablishing\n   * a channel)\n   * @param options.timeoutIdle - The time waiting for a new event to be initiated\n   * (default: 600000)\n   * @param options.timeoutFundingCreate - The time waiting for the initiator to produce\n   * the create channel transaction after the noise session had been established (default: 120000)\n   * @param options.timeoutFundingSign - The time frame the other client has to sign an\n   * off-chain update after our client had initiated and signed it. This applies only for double\n   * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.\n   * (default: 120000)\n   * @param options.timeoutFundingLock - The time frame the other client has to confirm an\n   * on-chain transaction reaching maturity (passing minimum depth) after the local node has\n   * detected this. This applies only for double signed on-chain intended updates: channel create\n   * transaction, deposit, withdrawal and etc. (default: 360000)\n   * @param options.timeoutSign - The time frame the client has to return a signed\n   * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)\n   * @param options.timeoutAccept - The time frame the other client has to react to an\n   * event. This applies for all off-chain updates that are not meant to land on-chain, as well as\n   * some special cases: opening a noise connection, mutual closing acknowledgement and\n   * reestablishing an existing channel (default: 120000)\n   * @param options.timeoutInitialized - the time frame the responder has to accept an\n   * incoming noise session. Applicable only for initiator (default: timeout_accept's value)\n   * @param options.timeoutAwaitingOpen - The time frame the initiator has to start an\n   * outgoing noise session to the responder's node. Applicable only for responder (default:\n   * timeout_idle's value)\n   * @param options.debug=false - Log websocket communication\n   * @param options.sign - Function which verifies and signs transactions\n   */\n  static async initialize(options: ChannelOptions): Promise<Channel> {\n    const channel = new Channel();\n    await initialize(\n      channel,\n      options.existingFsmId != null ? handlers.awaitingReconnection : handlers.awaitingConnection,\n      handlers.channelOpen,\n      options,\n    );\n    return channel;\n  }\n\n  /**\n   * Register event listener function\n   *\n   * Possible events:\n   *\n   *   - \"error\"\n   *   - \"onChainTx\"\n   *   - \"ownWithdrawLocked\"\n   *   - \"withdrawLocked\"\n   *   - \"ownDepositLocked\"\n   *   - \"depositLocked\"\n   *\n   * TODO: the event list looks outdated\n   *\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  // TODO define specific callback type depending on the event name\n  on(eventName: string, callback: EventCallback): void {\n    const eventEmitter = eventEmitters.get(this);\n    if (eventEmitter == null) throw new UnknownChannelStateError();\n    eventEmitter.on(eventName, callback);\n  }\n\n  /**\n   * Remove event listener function\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  off(eventName: string, callback: EventCallback): void {\n    const eventEmitter = eventEmitters.get(this);\n    if (eventEmitter == null) throw new UnknownChannelStateError();\n    eventEmitter.removeListener(eventName, callback);\n  }\n\n  /**\n   * Close the connection\n   */\n  disconnect(): void {\n    return channelDisconnect(this);\n  }\n\n  /**\n   * Get current status\n   *\n   */\n  status(): string {\n    const status = channelStatus.get(this);\n    if (status == null) throw new UnknownChannelStateError();\n    return status;\n  }\n\n  /**\n   * Get current state\n   */\n  async state(): Promise<ChannelState> {\n    return snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}));\n  }\n\n  /**\n   * Get current round\n   *\n   * If round cannot be determined (for example when channel has not been opened)\n   * it will return `null`.\n   *\n   */\n  round(): number | null {\n    const state = channelState.get(this);\n    if (state == null) {\n      return null;\n    }\n    const { txType, tx } = unpackTx(state, Tag.SignedTx).tx.encodedTx;\n    switch (txType) {\n      case Tag.ChannelCreateTx:\n        return 1;\n      case Tag.ChannelOffChainTx:\n      case Tag.ChannelWithdrawTx:\n      case Tag.ChannelDepositTx:\n        return tx.round;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get channel id\n   *\n   */\n  id(): string {\n    const id = channelId.get(this);\n    if (id == null) throw new ChannelError('Channel is not initialized');\n    return id;\n  }\n\n  /**\n   * Get channel's fsm id\n   *\n   */\n  fsmId(): string {\n    const id = channelFsmId.get(this);\n    if (id == null) throw new ChannelError('Channel is not initialized');\n    return id;\n  }\n\n  /**\n   * Trigger a transfer update\n   *\n   * The transfer update is moving coins from one channel account to another.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * Sender and receiver are the channel parties. Both the initiator and responder\n   * can take those roles. Any public key outside the channel is considered invalid.\n   *\n   * @param from - Sender's public address\n   * @param to - Receiver's public address\n   * @param amount - Transaction amount\n   * @param sign - Function which verifies and signs offchain transaction\n   * @param metadata - Metadata\n\n   * @example\n   * ```js\n   * channel.update(\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n   *   10,\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(({ accepted, signedTx }) =>\n   *   if (accepted) {\n   *     console.log('Update has been accepted')\n   *   }\n   * )\n   * ```\n   */\n  async update(\n    from: Encoded.AccountAddress,\n    to: Encoded.AccountAddress,\n    amount: number | BigNumber,\n    sign: SignTx,\n    metadata: string[] = [],\n  ): Promise<{\n      accepted: boolean;\n      signedTx?: Encoded.Transaction;\n      errorCode?: number;\n      errorMessage?: string;\n    }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, {\n            jsonrpc: '2.0',\n            method: 'channels.update.new',\n            params: {\n              from, to, amount, meta: metadata,\n            },\n          });\n          return {\n            handler: handlers.awaitingOffChainTx,\n            state: {\n              resolve,\n              reject,\n              sign,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Get proof of inclusion\n   *\n   * If a certain address of an account or a contract is not found\n   * in the state tree - the response is an error.\n   *\n   * @param addresses - Addresses\n   * @param addresses.accounts - List of account addresses to include in poi\n   * @param addresses.contracts - List of contract addresses to include in poi\n   * @example\n   * ```js\n   * channel.poi({\n   *   accounts: [\n   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   ],\n   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']\n   * }).then(poi => console.log(poi))\n   * ```\n   */\n  async poi(\n    { accounts, contracts }: {\n      accounts: Encoded.AccountAddress[];\n      contracts?: Encoded.ContractAddress[];\n    },\n  ): Promise<Encoded.Poi> {\n    return (await call(this, 'channels.get.poi', { accounts, contracts })).poi;\n  }\n\n  /**\n   * Get balances\n   *\n   * The accounts param contains a list of addresses to fetch balances of.\n   * Those can be either account balances or a contract ones, encoded as an account addresses.\n   *\n   * If a certain account address had not being found in the state tree - it is simply\n   * skipped in the response.\n   *\n   * @param accounts - List of addresses to fetch balances from\n   * @example\n   * ```js\n   * channel.balances([\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'\n   * ]).then(balances =>\n   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])\n   * )\n   * ```\n   */\n  async balances(\n    accounts: Encoded.AccountAddress[],\n  ): Promise<{ [key: Encoded.AccountAddress]: string }> {\n    return Object.fromEntries(\n      (await call(this, 'channels.get.balances', { accounts }))\n        .map((item: {\n          account: Encoded.AccountAddress;\n          balance: string;\n        }) => [item.account, item.balance]),\n    );\n  }\n\n  /**\n   * Leave channel\n   *\n   * It is possible to leave a channel and then later reestablish the channel\n   * off-chain state and continue operation. When a leave method is called,\n   * the channel fsm passes it on to the peer fsm, reports the current mutually\n   * signed state and then terminates.\n   *\n   * The channel can be reestablished by instantiating another Channel instance\n   * with two extra params: existingChannelId and offchainTx (returned from leave\n   * method as channelId and signedTx respectively).\n   *\n   * @example\n   * ```js\n   * channel.leave().then(({ channelId, signedTx }) => {\n   *   console.log(channelId)\n   *   console.log(signedTx)\n   * })\n   * ```\n   */\n  async leave(): Promise<{ channelId: string; signedTx: Encoded.Transaction }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, { jsonrpc: '2.0', method: 'channels.leave', params: {} });\n          return {\n            handler: handlers.awaitingLeave,\n            state: { resolve, reject },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Trigger mutual close\n   *\n   * At any moment after the channel is opened, a closing procedure can be triggered.\n   * This can be done by either of the parties. The process is similar to the off-chain updates.\n   *\n   * @param sign - Function which verifies and signs mutual close transaction\n   * @example\n   * ```js\n   * channel.shutdown(\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(tx => console.log('on_chain_tx', tx))\n   * ```\n   */\n  async shutdown(sign: Function): Promise<Encoded.Transaction> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, { jsonrpc: '2.0', method: 'channels.shutdown', params: {} });\n          return {\n            handler: handlers.awaitingShutdownTx,\n            state: {\n              sign,\n              resolve,\n              reject,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Withdraw coins from the channel\n   *\n   * After the channel had been opened any of the participants can initiate a withdrawal.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a withdrawal. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the withdraw transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onWithdrawLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to withdraw\n   * @param sign - Function which verifies and signs withdraw transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when withdraw transaction has been posted\n   * on chain\n   * @param callbacks.onOwnWithdrawLocked\n   * @param callbacks.onWithdrawLocked\n   * @example\n   * ```js\n   * channel.withdraw(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Withdrawal has been accepted')\n   *   } else {\n   *     console.log('Withdrawal has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async withdraw(\n    amount: number | BigNumber,\n    sign: SignTx,\n    { onOnChainTx, onOwnWithdrawLocked, onWithdrawLocked }:\n    Pick<ChannelState, 'onOnChainTx' | 'onOwnWithdrawLocked' | 'onWithdrawLocked'> = {},\n  ): Promise<{ accepted: boolean; signedTx: Encoded.Transaction }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, { jsonrpc: '2.0', method: 'channels.withdraw', params: { amount } });\n          return {\n            handler: handlers.awaitingWithdrawTx,\n            state: {\n              sign,\n              resolve,\n              reject,\n              onOnChainTx,\n              onOwnWithdrawLocked,\n              onWithdrawLocked,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Deposit coins into the channel\n   *\n   * After the channel had been opened any of the participants can initiate a deposit.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_deposit_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a deposit. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The deposit amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the deposit transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnDepositLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onDepositLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to deposit\n   * @param sign - Function which verifies and signs deposit transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when deposit transaction has been posted\n   * on chain\n   * @param callbacks.onOwnDepositLocked\n   * @param callbacks.onDepositLocked\n   * @example\n   * ```js\n   * channel.deposit(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, state }) => {\n   *   if (accepted) {\n   *     console.log('Deposit has been accepted')\n   *     console.log('The new state is:', state)\n   *   } else {\n   *     console.log('Deposit has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async deposit(\n    amount: number | BigNumber,\n    sign: SignTx,\n    { onOnChainTx, onOwnDepositLocked, onDepositLocked }:\n    Pick<ChannelState, 'onOnChainTx' | 'onOwnDepositLocked' | 'onDepositLocked'> = {},\n  ): Promise<{ accepted: boolean; state: ChannelState }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, { jsonrpc: '2.0', method: 'channels.deposit', params: { amount } });\n          return {\n            handler: handlers.awaitingDepositTx,\n            state: {\n              sign,\n              resolve,\n              reject,\n              onOnChainTx,\n              onOwnDepositLocked,\n              onDepositLocked,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Trigger create contract update\n   *\n   * The create contract update is creating a contract inside the channel's internal state tree.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * That would create a contract with the poster being the owner of it. Poster commits initially\n   * a deposit amount of coins to the new contract.\n   *\n   * @param options - Options\n   * @param options.code - Api encoded compiled AEVM byte code\n   * @param options.callData - Api encoded compiled AEVM call data for the code\n   * @param options.deposit - Initial amount the owner of the contract commits to it\n   * @param options.vmVersion - Version of the Virtual Machine\n   * @param options.abiVersion - Version of the Application Binary Interface\n   * @param sign - Function which verifies and signs create contract transaction\n   * @example\n   * ```js\n   * channel.createContract({\n   *   code: 'cb_HKtpipK4aCgYb17wZ...',\n   *   callData: 'cb_1111111111111111...',\n   *   deposit: 10,\n   *   vmVersion: 3,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx, address }) => {\n   *   if (accepted) {\n   *     console.log('New contract has been created')\n   *     console.log('Contract address:', address)\n   *   } else {\n   *     console.log('New contract has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async createContract(\n    {\n      code, callData, deposit, vmVersion, abiVersion,\n    }: {\n      code: Encoded.ContractBytearray;\n      callData: Encoded.ContractBytearray;\n      deposit: number | BigNumber;\n      vmVersion: number;\n      abiVersion: number;\n    },\n    sign: SignTx,\n  ): Promise<{\n      accepted: boolean; signedTx: Encoded.Transaction; address: Encoded.ContractAddress;\n    }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, {\n            jsonrpc: '2.0',\n            method: 'channels.update.new_contract',\n            params: {\n              code,\n              call_data: callData,\n              deposit,\n              vm_version: vmVersion,\n              abi_version: abiVersion,\n            },\n          });\n          return {\n            handler: handlers.awaitingNewContractTx,\n            state: {\n              sign,\n              resolve,\n              reject,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Trigger call a contract update\n   *\n   * The call contract update is calling a preexisting contract inside the channel's\n   * internal state tree. The update is a change to be applied on top of the latest state.\n   *\n   * That would call a contract with the poster being the caller of it. Poster commits\n   * an amount of coins to the contract.\n   *\n   * The call would also create a call object inside the channel state tree. It contains\n   * the result of the contract call.\n   *\n   * It is worth mentioning that the gas is not consumed, because this is an off-chain\n   * contract call. It would be consumed if it were an on-chain one. This could happen\n   * if a call with a similar computation amount is to be forced on-chain.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param sign - Function which verifies and signs contract call transaction\n   * @example\n   * ```js\n   * channel.callContract({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract called succesfully')\n   *   } else {\n   *     console.log('Contract call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async callContract(\n    {\n      amount, callData, contract, abiVersion,\n    }: CallContractOptions,\n    sign: SignTx,\n  ): Promise<{ accepted: boolean; signedTx: Encoded.Transaction }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, {\n            jsonrpc: '2.0',\n            method: 'channels.update.call_contract',\n            params: {\n              amount,\n              call_data: callData,\n              contract_id: contract,\n              abi_version: abiVersion,\n            },\n          });\n          return {\n            handler: handlers.awaitingCallContractUpdateTx,\n            state: { resolve, reject, sign },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Trigger a force progress contract call\n   * This call is going on-chain\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param options.gasPrice=1000000000]\n   * @param options.gasLimit=1000000]\n   * @param sign - Function which verifies and signs contract force progress transaction\n   * @param callbacks - Callbacks\n   * @example\n   * ```js\n   * channel.forceProgress({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1,\n   *   gasPrice: 1000005554\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract force progress call successful')\n   *   } else {\n   *     console.log('Contract force progress call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async forceProgress(\n    {\n      amount, callData, contract, abiVersion, gasLimit = 1000000, gasPrice = MIN_GAS_PRICE,\n    }: {\n      amount: number;\n      callData: Encoded.ContractBytearray;\n      contract: Encoded.ContractAddress;\n      abiVersion: number;\n      gasLimit?: number;\n      gasPrice?: number;\n    },\n    sign: SignTx,\n    { onOnChainTx }: Pick<ChannelState, 'onOnChainTx'> = {},\n  ): Promise<{\n      accepted: boolean;\n      signedTx: Encoded.Transaction;\n      tx: Encoded.Transaction | Uint8Array;\n    }> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, {\n            jsonrpc: '2.0',\n            method: 'channels.force_progress',\n            params: {\n              amount,\n              call_data: callData,\n              contract_id: contract,\n              abi_version: abiVersion,\n              gas_price: gasPrice,\n              gas: gasLimit,\n            },\n          });\n          return {\n            handler: handlers.awaitingCallContractForceProgressUpdate,\n            state: {\n              resolve, reject, sign, onOnChainTx,\n            },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Call contract using dry-run\n   *\n   * In order to get the result of a potential contract call, one might need to\n   * dry-run a contract call. It takes the exact same arguments as a call would\n   * and returns the call object.\n   *\n   * The call is executed in the channel's state, but it does not impact the state\n   * whatsoever. It uses as an environment the latest channel's state and the current\n   * top of the blockchain as seen by the node.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @example\n   * ```js\n   * channel.callContractStatic({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ returnValue, gasUsed }) => {\n   *   console.log('Returned value:', returnValue)\n   *   console.log('Gas used:', gasUsed)\n   * })\n   * ```\n   */\n  async callContractStatic(\n    {\n      amount, callData, contract, abiVersion,\n    }: {\n      amount: number;\n      callData: Encoded.ContractBytearray;\n      contract: Encoded.ContractAddress;\n      abiVersion: number;\n    },\n  ): Promise<CallContractOptions> {\n    return snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {\n      amount,\n      call_data: callData,\n      contract_id: contract,\n      abi_version: abiVersion,\n    }));\n  }\n\n  /**\n   * Get contract call result\n   *\n   * The combination of a caller, contract and a round of execution determines the\n   * contract call. Providing an incorrect set of those results in an error response.\n   *\n   * @param options - Options\n   * @param options.caller - Address of contract caller\n   * @param options.contract - Address of the contract\n   * @param options.round - Round when contract was called\n   * @example\n   * ```js\n   * channel.getContractCall({\n   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   round: 3\n   * }).then(({ returnType, returnValue }) => {\n   *   if (returnType === 'ok') console.log(returnValue)\n   * })\n   * ```\n   */\n  async getContractCall(\n    { caller, contract, round }: {\n      caller: Encoded.AccountAddress;\n      contract: Encoded.ContractAddress;\n      round: number;\n    },\n  ): Promise<{\n      returnType: ContractCallReturnType;\n      returnValue: string;\n      gasPrice: number | BigNumber;\n      gasUsed: number | BigNumber;\n      height: number;\n      log: string;\n    }> {\n    return snakeToPascalObjKeys(\n      await call(this, 'channels.get.contract_call', {\n        caller_id: caller,\n        contract_id: contract,\n        round,\n      }),\n    );\n  }\n\n  /**\n   * Get the latest contract state\n   *\n   * @param contract - Address of the contract\n   * @example\n   * ```js\n   * channel.getContractState(\n   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'\n   * ).then(({ contract }) => {\n   *   console.log('deposit:', contract.deposit)\n   * })\n   * ```\n   */\n  async getContractState(\n    contract: Encoded.ContractAddress,\n  ): Promise<{ contract: Contract; contractState: object }> {\n    const result = await call(this, 'channels.get.contract', { pubkey: contract });\n    return snakeToPascalObjKeys({\n      ...result,\n      contract: snakeToPascalObjKeys(result.contract),\n    });\n  }\n\n  /**\n   * Clean up all locally stored contract calls\n   *\n   * Contract calls are kept locally in order for the participant to be able to look them up.\n   * They consume memory and in order for the participant to free it - one can prune all messages.\n   * This cleans up all locally stored contract calls and those will no longer be available for\n   * fetching and inspection.\n   */\n  async cleanContractCalls(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      enqueueAction(\n        this,\n        (_channel, state) => state?.handler === handlers.channelOpen,\n        (channel) => {\n          send(channel, {\n            jsonrpc: '2.0',\n            method: 'channels.clean_contract_calls',\n            params: {},\n          });\n          return {\n            handler: handlers.awaitingCallsPruned,\n            state: { resolve, reject },\n          };\n        },\n      );\n    });\n  }\n\n  /**\n   * Send generic message\n   *\n   * If message is an object it will be serialized into JSON string\n   * before sending.\n   *\n   * If there is ongoing update that has not yet been finished the message\n   * will be sent after that update is finalized.\n   *\n   * @param message - Message\n   * @param recipient - Address of the recipient\n   * @example\n   * ```js\n   * channel.sendMessage(\n   *   'hello world',\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'\n   * )\n   * ```\n   */\n  async sendMessage(\n    message: string | object,\n    recipient: Encoded.AccountAddress,\n  ): Promise<void> {\n    const info = typeof message === 'object' ? JSON.stringify(message) : message;\n    if (this.status() === 'connecting') {\n      await new Promise<void>((resolve) => {\n        const onStatusChanged = (status: string): void => {\n          if (status === 'connecting') return;\n          resolve();\n          this.off('statusChanged', onStatusChanged);\n        };\n        this.on('statusChanged', onStatusChanged);\n      });\n      // For some reason we can't immediately send a message when connection is\n      // established. Thus we wait 500ms which seems to work.\n      await pause(500);\n    }\n    send(this, {\n      jsonrpc: '2.0',\n      method: 'channels.message',\n      params: { info, to: recipient },\n    });\n  }\n\n  static async reconnect(options: ChannelOptions, txParams: any): Promise<Channel> {\n    const { sign } = options;\n\n    return Channel.initialize({\n      ...options,\n      reconnectTx: await sign('reconnect', buildTx(txParams, Tag.ChannelClientReconnectTx).tx),\n    });\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;SAESA,a;SACAC,O,EAASC,Q;SACTC,a,EAAeC,G;OACjB,KAAKC,Q;SAEVC,a,EACAC,MAAM,IAAIC,a,EACVC,KAAK,IAAIC,Y,EACTC,U,EACAC,a,EACAC,I,EACAC,S,EACAC,I,EACAC,UAAU,IAAIC,iB,EACdC,KAAK,IAAIC,Y;SAKFC,wB,EAA0BC,Y;SAG1BC,K;;AAET,SAASC,oBAAT,CAAoCC,GAApC,EAAuD;EACrD,OAAOC,MAAM,CAACC,OAAP,CAAeF,GAAf,EAAoBG,MAApB,CAA2B,CAACC,MAAD;IAAA,IAAS,CAACC,GAAD,EAAMC,GAAN,CAAT;IAAA,OAAyB,EACzD,GAAGF,MADsD;MAEzD,CAAC5B,aAAa,CAAC6B,GAAD,CAAd,GAAsBC;IAFmC,CAAzB;EAAA,CAA3B,EAGH,EAHG,CAAP;AAID;;AA4BD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,OAAN,CAAc;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACyB,aAAVpB,UAAU,CAACqB,OAAD,EAA4C;IACjE,MAAMC,OAAO,GAAG,IAAIF,OAAJ,EAAhB;IACA,MAAMpB,UAAU,CACdsB,OADc,EAEdD,OAAO,CAACE,aAAR,IAAyB,IAAzB,GAAgC7B,QAAQ,CAAC8B,oBAAzC,GAAgE9B,QAAQ,CAAC+B,kBAF3D,EAGd/B,QAAQ,CAACgC,WAHK,EAIdL,OAJc,CAAhB;IAMA,OAAOC,OAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA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"}