import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";

/*
 * ISC License (ISC)
 * Copyright (c) 2018 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */
import _websocket from 'websocket';
const {
  w3cwebsocket: W3CWebSocket
} = _websocket;
import _events from 'events';
const {
  EventEmitter
} = _events;
import JsonBig from "../utils/json-big.mjs";
import { pascalToSnake } from "../utils/string.mjs";
import { ChannelCallError, ChannelPingTimedOutError, UnknownChannelStateError } from "../utils/errors.mjs";
// Send ping message every 10 seconds
const PING_TIMEOUT_MS = 10000; // Close connection if pong message is not received within 5 seconds

const PONG_TIMEOUT_MS = 5000; // TODO: move to Channel instance to avoid is-null checks and for easier debugging

export const options = new WeakMap();
export const status = new WeakMap();
export const state = new WeakMap();
const fsm = new WeakMap();
const websockets = new WeakMap();
export const eventEmitters = new WeakMap();
const messageQueue = new WeakMap();
const messageQueueLocked = new WeakMap();
const actionQueue = new WeakMap();
const actionQueueLocked = new WeakMap();
const sequence = new WeakMap();
export const channelId = new WeakMap();
const rpcCallbacks = new WeakMap();
const pingTimeoutId = new WeakMap();
const pongTimeoutId = new WeakMap();
export const fsmId = new WeakMap();
export function emit(channel) {
  var _eventEmitters$get;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  const [eventName, ...rest] = args;
  (_eventEmitters$get = eventEmitters.get(channel)) === null || _eventEmitters$get === void 0 ? void 0 : _eventEmitters$get.emit(eventName, ...rest);
}

function enterState(channel, nextState) {
  var _nextState$handler;

  if (nextState == null) {
    throw new UnknownChannelStateError();
  }

  fsm.set(channel, nextState);

  if ((nextState === null || nextState === void 0 ? void 0 : (_nextState$handler = nextState.handler) === null || _nextState$handler === void 0 ? void 0 : _nextState$handler.enter) != null) {
    nextState.handler.enter(channel);
  } // eslint-disable-next-line @typescript-eslint/no-use-before-define


  void dequeueAction(channel);
}

export function changeStatus(channel, newStatus) {
  const prevStatus = status.get(channel);

  if (newStatus !== prevStatus) {
    status.set(channel, newStatus);
    emit(channel, 'statusChanged', newStatus);
  }
}
export function changeState(channel, newState) {
  state.set(channel, newState);
  emit(channel, 'stateChanged', newState);
}
export function send(channel, message) {
  var _options$get$debug, _options$get, _websockets$get;

  const debug = (_options$get$debug = (_options$get = options.get(channel)) === null || _options$get === void 0 ? void 0 : _options$get.debug) !== null && _options$get$debug !== void 0 ? _options$get$debug : false;
  if (debug) console.log('Send message: ', message);
  (_websockets$get = websockets.get(channel)) === null || _websockets$get === void 0 ? void 0 : _websockets$get.send(JsonBig.stringify(message));
}

async function dequeueAction(channel) {
  var _actionQueue$get;

  const locked = actionQueueLocked.get(channel);
  const queue = (_actionQueue$get = actionQueue.get(channel)) !== null && _actionQueue$get !== void 0 ? _actionQueue$get : [];

  if (Boolean(locked) || queue.length === 0) {
    return;
  }

  const singleFsm = fsm.get(channel);
  if (singleFsm == null) return;
  const index = queue.findIndex(action => action.guard(channel, singleFsm));

  if (index === -1) {
    return;
  }

  actionQueue.set(channel, queue.filter((_, i) => index !== i));
  actionQueueLocked.set(channel, true);
  const nextState = await Promise.resolve(queue[index].action(channel, singleFsm));
  actionQueueLocked.set(channel, false);
  enterState(channel, nextState);
}

export function enqueueAction(channel, guard, action) {
  var _actionQueue$get2;

  const queue = (_actionQueue$get2 = actionQueue.get(channel)) !== null && _actionQueue$get2 !== void 0 ? _actionQueue$get2 : [];
  actionQueue.set(channel, [...queue, {
    guard,
    action
  }]);
  void dequeueAction(channel);
}

async function handleMessage(channel, message) {
  const fsmState = fsm.get(channel);
  if (fsmState == null) throw new UnknownChannelStateError();
  const {
    handler,
    state: st
  } = fsmState;
  enterState(channel, await Promise.resolve(handler(channel, message, st)));
}

async function dequeueMessage(channel) {
  var _messageQueueLocked$g, _messageQueue$get;

  const locked = (_messageQueueLocked$g = messageQueueLocked.get(channel)) !== null && _messageQueueLocked$g !== void 0 ? _messageQueueLocked$g : false;
  if (locked) return;
  const messages = (_messageQueue$get = messageQueue.get(channel)) !== null && _messageQueue$get !== void 0 ? _messageQueue$get : [];
  if (messages.length === 0) return;
  messageQueueLocked.set(channel, true);

  while (messages.length > 0) {
    var _messages$shift;

    const message = (_messages$shift = messages.shift()) !== null && _messages$shift !== void 0 ? _messages$shift : '';

    try {
      await handleMessage(channel, message);
    } catch (error) {
      console.error('Error handling incoming message:');
      console.error(message);
      console.error(error);
    }
  }

  messageQueueLocked.set(channel, false);
}

export function disconnect(channel) {
  var _websockets$get2;

  (_websockets$get2 = websockets.get(channel)) === null || _websockets$get2 === void 0 ? void 0 : _websockets$get2.close();
  const pingTimeoutIdValue = pingTimeoutId.get(channel);
  const pongTimeoutIdValue = pongTimeoutId.get(channel);
  if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
  if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
}

function ping(channel) {
  const pingTimeoutIdValue = pingTimeoutId.get(channel);
  const pongTimeoutIdValue = pongTimeoutId.get(channel);
  if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
  if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
  pingTimeoutId.set(channel, setTimeout(() => {
    send(channel, {
      jsonrpc: '2.0',
      method: 'channels.system',
      params: {
        action: 'ping'
      }
    });
    pongTimeoutId.set(channel, setTimeout(() => {
      disconnect(channel);
      emit(channel, 'error', new ChannelPingTimedOutError());
    }, PONG_TIMEOUT_MS));
  }, PING_TIMEOUT_MS));
}

function onMessage(channel, data) {
  var _options$get$debug2, _options$get2, _messageQueue$get2;

  const message = JsonBig.parse(data);
  const debug = (_options$get$debug2 = (_options$get2 = options.get(channel)) === null || _options$get2 === void 0 ? void 0 : _options$get2.debug) !== null && _options$get$debug2 !== void 0 ? _options$get$debug2 : false;
  if (debug) console.log('Receive message: ', message);

  if (message.id != null) {
    var _rpcCallbacks$get;

    const callback = (_rpcCallbacks$get = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get === void 0 ? void 0 : _rpcCallbacks$get.get(message.id);

    try {
      callback === null || callback === void 0 ? void 0 : callback(message);
    } finally {
      var _rpcCallbacks$get2;

      (_rpcCallbacks$get2 = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get2 === void 0 ? void 0 : _rpcCallbacks$get2.delete(message.id);
    }

    return;
  }

  if (message.method === 'channels.message') {
    emit(channel, 'message', message.params.data.message);
    return;
  }

  if (message.method === 'channels.system.pong') {
    if (message.params.channel_id === channelId.get(channel) // Skip channelId check if channelId is not known yet
    || channelId.get(channel) == null) {
      ping(channel);
    }

    return;
  }

  (_messageQueue$get2 = messageQueue.get(channel)) === null || _messageQueue$get2 === void 0 ? void 0 : _messageQueue$get2.push(message);
  void dequeueMessage(channel);
}

export async function call(channel, method, params) {
  return new Promise((resolve, reject) => {
    var _sequence$get, _sequence$set$get, _rpcCallbacks$get3;

    const currentSequence = (_sequence$get = sequence.get(channel)) !== null && _sequence$get !== void 0 ? _sequence$get : 0;
    const id = (_sequence$set$get = sequence.set(channel, currentSequence + 1).get(channel)) !== null && _sequence$set$get !== void 0 ? _sequence$set$get : 1;
    (_rpcCallbacks$get3 = rpcCallbacks.get(channel)) === null || _rpcCallbacks$get3 === void 0 ? void 0 : _rpcCallbacks$get3.set(id, message => {
      if (message.error != null) {
        var _message$error$data;

        const [{
          message: details
        } = {
          message: ''
        }] = (_message$error$data = message.error.data) !== null && _message$error$data !== void 0 ? _message$error$data : [];
        return reject(new ChannelCallError(message.error.message + details));
      }

      return resolve(message.result);
    });
    send(channel, {
      jsonrpc: '2.0',
      method,
      id,
      params
    });
  });
}
export async function initialize(channel, connectionHandler, openHandler, _ref) {
  let {
    url,
    ...channelOptions
  } = _ref;
  options.set(channel, {
    url,
    ...channelOptions
  });
  fsm.set(channel, {
    handler: connectionHandler
  });
  eventEmitters.set(channel, new EventEmitter());
  sequence.set(channel, 0);
  rpcCallbacks.set(channel, new Map());
  messageQueue.set(channel, []);
  const wsUrl = new URL(url);
  Object.entries(channelOptions).filter(_ref2 => {
    var _context;

    let [key] = _ref2;
    return !_includesInstanceProperty(_context = ['sign', 'debug']).call(_context, key);
  }).forEach(_ref3 => {
    let [key, value] = _ref3;
    return wsUrl.searchParams.set(pascalToSnake(key), value);
  });
  wsUrl.searchParams.set('protocol', 'json-rpc');
  changeStatus(channel, 'connecting');
  const ws = new W3CWebSocket(wsUrl.toString());
  await new Promise((resolve, reject) => {
    Object.assign(ws, {
      onerror: reject,
      onopen: async () => {
        resolve();
        changeStatus(channel, 'connected');

        if (channelOptions.reconnectTx != null) {
          enterState(channel, {
            handler: openHandler
          });
          const signedTx = (await call(channel, 'channels.get.offchain_state', {})).signed_tx;
          changeState(channel, signedTx);
        }

        ping(channel);
      },
      onclose: () => {
        changeStatus(channel, 'disconnected');
        const pingTimeoutIdValue = pingTimeoutId.get(channel);
        const pongTimeoutIdValue = pongTimeoutId.get(channel);
        if (pingTimeoutIdValue != null) clearTimeout(pingTimeoutIdValue);
        if (pongTimeoutIdValue != null) clearTimeout(pongTimeoutIdValue);
      },
      onmessage: _ref4 => {
        let {
          data
        } = _ref4;
        return onMessage(channel, data);
      }
    });
  });
  websockets.set(channel, ws);
}
//# sourceMappingURL=internal.mjs.map