import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import { v4 as uuid } from '@aeternity/uuid';
import AeSdk from "./AeSdk.mjs";
import verifyTransaction from "./tx/validator.mjs";
import RpcClient from "./aepp-wallet-communication/rpc/RpcClient.mjs";
import { METHODS, RPC_STATUS, SUBSCRIPTION_TYPES, RpcBroadcastError, RpcInvalidTransactionError, RpcNotAuthorizeError, RpcPermissionDenyError, RpcUnsupportedProtocolError } from "./aepp-wallet-communication/schema.mjs";
import { InternalError, UnknownRpcClientError } from "./utils/errors.mjs";
import { RPC_VERSION } from "./aepp-wallet-communication/rpc/types.mjs";
import jsonBig from "./utils/json-big.mjs";

/**
 * Contain functionality for aepp interaction and managing multiple aepps
 * @category aepp wallet communication
 */
export default class AeSdkWallet extends AeSdk {
  /**
   * @param options - Options
   * @param options.name - Wallet name
   * @param options.id - Wallet id
   * @param options.type - Wallet type
   * @param options.onConnection - Call-back function for incoming AEPP connection
   * @param options.onSubscription - Call-back function for incoming AEPP account subscription
   * @param options.onSign - Call-back function for incoming AEPP sign request
   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request
   * @param options.onMessageSign - Call-back function for incoming AEPP sign message request
   * @param options.onDisconnect - Call-back function for disconnect event
   */
  constructor(_ref) {
    let {
      name,
      id,
      type,
      onConnection,
      onSubscription,
      onSign,
      onDisconnect,
      onAskAccounts,
      onMessageSign,
      ...options
    } = _ref;
    super(options);
    this.onConnection = onConnection;
    this.onSubscription = onSubscription;
    this.onSign = onSign;
    this.onDisconnect = onDisconnect;
    this.onAskAccounts = onAskAccounts;
    this.onMessageSign = onMessageSign;
    this._clients = new Map();
    this.name = name;
    this.id = id;
    this._type = type;
  }

  _pushAccountsToApps() {
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientSubscribed(clientId)).map(clientId => this._getClient(clientId).rpc).forEach(client => client.notify(METHODS.updateAddress, this.getAccounts()));
  }

  selectAccount(address) {
    super.selectAccount(address);

    this._pushAccountsToApps();
  }

  async addAccount(account, options) {
    await super.addAccount(account, options);

    this._pushAccountsToApps();
  }

  _getNode() {
    this.ensureNodeConnected();
    return {
      node: {
        url: this.api.url,
        name: this.selectedNodeName
      }
    };
  }

  async selectNode(name) {
    super.selectNode(name);
    const networkId = await this.getNetworkId();
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {
      client.rpc.notify(METHODS.updateNetwork, {
        networkId,
        ...(client.connectNode && this._getNode())
      });
    });
  }

  _getClient(clientId) {
    const client = this._clients.get(clientId);

    if (client == null) throw new UnknownRpcClientError(clientId);
    return client;
  }

  _isRpcClientSubscribed(clientId) {
    return this._isRpcClientConnected(clientId) && this._getClient(clientId).addressSubscription.size !== 0;
  }

  _isRpcClientConnected(clientId) {
    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();
  }

  _disconnectRpcClient(clientId) {
    const client = this._getClient(clientId);

    client.rpc.connection.disconnect();
    client.status = RPC_STATUS.DISCONNECTED;
    client.addressSubscription = new Set();
  }
  /**
   * Remove specific RpcClient by ID
   * @param id - Client ID
   */


  removeRpcClient(id) {
    this._disconnectRpcClient(id);

    this._clients.delete(id);
  }
  /**
   * Add new client by AEPP connection
   * @param clientConnection - AEPP connection object
   * @returns Client ID
   */


  addRpcClient(clientConnection) {
    // @TODO  detect if aepp has some history based on origin????
    // if yes use this instance for connection
    const id = uuid();
    let disconnectParams;
    const client = {
      id,
      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,
      addressSubscription: new Set(),
      connectNode: false,
      rpc: new RpcClient(clientConnection, () => {
        this._clients.delete(id);

        this.onDisconnect(id, disconnectParams); // also related info
      }, {
        [METHODS.closeConnection]: params => {
          disconnectParams = params;

          this._disconnectRpcClient(id);
        },
        // Store client info and prepare two fn for each client `connect` and `denyConnection`
        // which automatically prepare and send response for that client
        [METHODS.connect]: async (_ref2, origin) => {
          let {
            name,
            version,
            icons,
            connectNode
          } = _ref2;
          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();
          await this.onConnection(id, {
            name,
            icons,
            connectNode
          }, origin);
          client.status = RPC_STATUS.CONNECTED;
          client.connectNode = connectNode;
          return { ...(await this.getWalletInfo()),
            ...(connectNode && this._getNode())
          };
        },
        [METHODS.subscribeAddress]: async (_ref3, origin) => {
          let {
            type,
            value
          } = _ref3;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onSubscription(id, {
            type,
            value
          }, origin);

          switch (type) {
            case SUBSCRIPTION_TYPES.subscribe:
              client.addressSubscription.add(value);
              break;

            case SUBSCRIPTION_TYPES.unsubscribe:
              client.addressSubscription.delete(value);
              break;

            default:
              throw new InternalError(`Unknown subscription type: ${type}`);
          }

          return {
            subscription: Array.from(client.addressSubscription),
            address: this.getAccounts()
          };
        },
        [METHODS.address]: async (params, origin) => {
          if (!this._isRpcClientSubscribed(id)) throw new RpcNotAuthorizeError();
          await this.onAskAccounts(id, params, origin);
          return this.addresses();
        },
        [METHODS.sign]: async (_ref4, origin) => {
          var _onAccount, _context, _overrides$onAccount, _overrides$tx;

          let {
            tx,
            onAccount,
            returnSigned
          } = _ref4;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          (_onAccount = onAccount) !== null && _onAccount !== void 0 ? _onAccount : onAccount = await this.address();

          if (!_includesInstanceProperty(_context = this.addresses()).call(_context, onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }

          const overrides = await this.onSign(id, {
            tx,
            returnSigned,
            onAccount
          }, origin);
          onAccount = (_overrides$onAccount = overrides === null || overrides === void 0 ? void 0 : overrides.onAccount) !== null && _overrides$onAccount !== void 0 ? _overrides$onAccount : onAccount;
          tx = (_overrides$tx = overrides === null || overrides === void 0 ? void 0 : overrides.tx) !== null && _overrides$tx !== void 0 ? _overrides$tx : tx;

          if (returnSigned) {
            return {
              signedTransaction: await this.signTransaction(tx, {
                onAccount
              })
            };
          }

          try {
            return jsonBig.parse(jsonBig.stringify({
              transactionHash: await this.send(tx, {
                onAccount,
                verify: false
              })
            }));
          } catch (error) {
            const validation = await verifyTransaction(tx, this.api);
            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);
            throw new RpcBroadcastError(error.message);
          }
        },
        [METHODS.signMessage]: async (_ref5, origin) => {
          var _onAccount2, _context2, _overrides$onAccount2;

          let {
            message,
            onAccount
          } = _ref5;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          (_onAccount2 = onAccount) !== null && _onAccount2 !== void 0 ? _onAccount2 : onAccount = await this.address();

          if (!_includesInstanceProperty(_context2 = this.addresses()).call(_context2, onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }

          const overrides = await this.onMessageSign(id, {
            message,
            onAccount
          }, origin);
          onAccount = (_overrides$onAccount2 = overrides === null || overrides === void 0 ? void 0 : overrides.onAccount) !== null && _overrides$onAccount2 !== void 0 ? _overrides$onAccount2 : onAccount;
          return {
            // TODO: fix signMessage return type
            signature: await this.signMessage(message, {
              onAccount,
              returnHex: true
            })
          };
        }
      })
    };

    this._clients.set(id, client);

    return id;
  }
  /**
   * Send shareWalletInfo message to notify AEPP about wallet
   * @param clientId - ID of RPC client send message to
   */


  async shareWalletInfo(clientId) {
    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());
  }
  /**
   * Get Wallet info object
   * @returns Object with wallet information
   */


  async getWalletInfo() {
    return {
      id: this.id,
      name: this.name,
      networkId: await this.getNetworkId(),
      origin: window.location.origin,
      type: this._type
    };
  }
  /**
   * Get Wallet accounts
   * @returns Object with accounts information (\{ connected: Object, current: Object \})
   */


  getAccounts() {
    return {
      current: this.selectedAddress != null ? {
        [this.selectedAddress]: {}
      } : {},
      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({ ...acc,
        [a]: {}
      }), {})
    };
  }

}
//# sourceMappingURL=AeSdkWallet.mjs.map