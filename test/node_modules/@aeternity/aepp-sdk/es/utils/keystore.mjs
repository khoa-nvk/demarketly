import nacl from 'tweetnacl';
import { v4 as uuid } from '@aeternity/uuid'; // js extension is required for mjs build
// eslint-disable-next-line import/extensions

import _aeternityArgon2BrowserDistArgon2BundledMinJs from '@aeternity/argon2-browser/dist/argon2-bundled.min.js';
const {
  ArgonType,
  hash
} = _aeternityArgon2BrowserDistArgon2BundledMinJs;
import { getAddressFromPriv } from "./crypto.mjs";
import { bytesToHex, hexToBytes } from "./bytes.mjs";
import { InvalidPasswordError } from "./errors.mjs";
const DERIVED_KEY_FUNCTIONS = {
  async argon2id(pass, salt, params) {
    const {
      memlimit_kib: mem,
      opslimit: time
    } = params;
    return (await hash({
      hashLen: 32,
      pass,
      salt,
      time,
      mem,
      type: ArgonType.Argon2id
    })).hash;
  }

};
const CRYPTO_FUNCTIONS = {
  'xsalsa20-poly1305': {
    encrypt: nacl.secretbox,

    decrypt() {
      const res = nacl.secretbox.open(...arguments);
      if (res == null) throw new InvalidPasswordError();
      return res;
    }

  }
};
const CRYPTO_DEFAULTS = {
  secret_type: 'ed25519',
  symmetric_alg: 'xsalsa20-poly1305',
  kdf: 'argon2id',
  kdf_params: {
    memlimit_kib: 65536,
    opslimit: 3,
    parallelism: 1
  }
};
/**
 * Symmetric private key encryption using secret (derived) key.
 * @param plaintext - Data to be encrypted.
 * @param key - Secret key.
 * @param nonce - Randomly generated nonce.
 * @param algo - Encryption algorithm.
 * @returns Encrypted data.
 */

function encrypt(plaintext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].encrypt(plaintext, nonce, key);
}
/**
 * Symmetric private key decryption using secret (derived) key.
 * @param ciphertext - Data to be decrypted.
 * @param key - Secret key.
 * @param nonce - Nonce from key-object.
 * @param algo - Encryption algorithm.
 * @returns Decrypted data.
 */


function decrypt(ciphertext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].decrypt(ciphertext, nonce, key);
}
/**
 * Derive secret key from password with key derivation function.
 * @param password - User-supplied password.
 * @param nonce - Randomly generated nonce.
 * @param kdf - Key derivation function.
 * @param kdfParams - KDF parameters.
 * @returns Secret key derived from password.
 */


async function deriveKey(password, nonce, kdf, kdfParams) {
  return DERIVED_KEY_FUNCTIONS[kdf](password, nonce, kdfParams);
}
/**
 * Recover plaintext private key from secret-storage key object.
 * @param password - Keystore object password.
 * @param keystore - Keystore object.
 * @returns Plaintext private key.
 */


export async function recover(password, _ref) {
  let {
    crypto
  } = _ref;
  const salt = hexToBytes(crypto.kdf_params.salt);
  return bytesToHex(decrypt(hexToBytes(crypto.ciphertext), await deriveKey(password, salt, crypto.kdf, crypto.kdf_params), hexToBytes(crypto.cipher_params.nonce), crypto.symmetric_alg));
}
/**
 * Export private key to keystore secret-storage format.
 * @param name - Key name.
 * @param password - User-supplied password.
 * @param privateKey - Private key as hex-string or a Buffer.
 * @param nonce - Randomly generated 24byte nonce.
 * @param salt - Randomly generated 16byte salt.
 * @param options - Encryption parameters.
 * @param options.kdf - Key derivation function.
 * @param options.kdf_params - KDF parameters.
 */

export async function dump(name, password, privateKey) {
  let nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nacl.randomBytes(24);
  let salt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nacl.randomBytes(16);
  let options = arguments.length > 5 ? arguments[5] : undefined;
  const opt = { ...CRYPTO_DEFAULTS,
    ...options
  };
  const derivedKey = await deriveKey(password, salt, opt.kdf, opt.kdf_params);
  const payload = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
  return {
    name,
    version: 1,
    public_key: getAddressFromPriv(payload),
    id: uuid(),
    crypto: {
      secret_type: opt.secret_type,
      symmetric_alg: opt.symmetric_alg,
      ciphertext: bytesToHex(encrypt(payload, derivedKey, nonce, opt.symmetric_alg)),
      cipher_params: {
        nonce: bytesToHex(nonce)
      },
      kdf: opt.kdf,
      kdf_params: { ...opt.kdf_params,
        salt: bytesToHex(salt)
      }
    }
  };
}
//# sourceMappingURL=keystore.mjs.map