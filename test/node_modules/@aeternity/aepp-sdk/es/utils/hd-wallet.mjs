import _buffer from "buffer";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
const {
  Buffer: _Buffer
} = _buffer;
import nacl from 'tweetnacl';
import _tweetnaclAuth from 'tweetnacl-auth';
const {
  full: hmac
} = _tweetnaclAuth;
import _bip32Path from 'bip32-path';
const {
  fromString
} = _bip32Path;
import aesjs from 'aes-js';
import { sha256hash, encode, Encoding } from "./encoder.mjs";
import { CryptographyError } from "./errors.mjs";
import { bytesToHex } from "./bytes.mjs";
import { concatBuffers } from "./other.mjs";
const Ecb = aesjs.ModeOfOperation.ecb; // TODO: at least don't export `encryptKey` and `decryptKey`

/**
 * Encrypt given data using `password`
 * @param password - Password to encrypt with
 * @param binaryData - Data to encrypt
 * @returns Encrypted data
 * @deprecated use 'sha.js' and 'aes-js' packages directly instead
 */

export function encryptKey(password, binaryData) {
  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.encrypt(binaryData);
}
/**
 * Decrypt given data using `password`
 * @param password - Password to decrypt with
 * @param encrypted - Data to decrypt
 * @returns Decrypted data
 * @deprecated use 'sha.js' and 'aes-js' packages directly instead
 */

export function decryptKey(password, encrypted) {
  const encryptedBytes = _Buffer.from(encrypted);

  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.decrypt(encryptedBytes);
}
/**
 * @category exception
 */

export class DerivationError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'DerivationError';
  }

}

const ED25519_CURVE = _Buffer.from('ed25519 seed');

const HARDENED_OFFSET = 0x80000000;
export function deriveChild(_ref, index) {
  let {
    secretKey,
    chainCode
  } = _ref;

  if (index < HARDENED_OFFSET) {
    throw new DerivationError(`Segment ${index} is not hardened`);
  }

  const indexBuffer = _Buffer.allocUnsafe(4);

  indexBuffer.writeUInt32BE(index, 0);
  const data = concatBuffers([_Buffer.alloc(1, 0), secretKey, indexBuffer]);
  const I = hmac(data, chainCode);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
export function derivePathFromKey(path, key) {
  const segments = path === '' ? [] : fromString(path).toPathArray();
  segments.forEach((segment, i) => {
    if (segment < HARDENED_OFFSET) {
      throw new DerivationError(`Segment #${i + 1} is not hardened`);
    }
  });
  return segments.reduce((parentKey, segment) => deriveChild(parentKey, segment), key);
}
export function getMasterKeyFromSeed(seed) {
  const I = hmac(seed, ED25519_CURVE);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
export function derivePathFromSeed(path, seed) {
  var _context;

  if (!_includesInstanceProperty(_context = ['m', 'm/']).call(_context, path.slice(0, 2))) {
    throw new DerivationError('Root element is required');
  }

  const masterKey = getMasterKeyFromSeed(seed);
  return derivePathFromKey(path.slice(2), masterKey);
}

function formatAccount(keys) {
  const {
    secretKey,
    publicKey
  } = keys;
  return {
    secretKey: bytesToHex(secretKey),
    publicKey: encode(publicKey, Encoding.AccountAddress)
  };
}

export function getKeyPair(secretKey) {
  return nacl.sign.keyPair.fromSeed(secretKey);
}
export function generateSaveHDWalletFromSeed(seed, password) {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  return {
    secretKey: bytesToHex(encryptKey(password, walletKey.secretKey)),
    chainCode: bytesToHex(encryptKey(password, walletKey.chainCode))
  };
}
export function getSaveHDWalletAccounts(saveHDWallet, password, accountCount) {
  const walletKey = {
    secretKey: decryptKey(password, _Buffer.from(saveHDWallet.secretKey, 'hex')),
    chainCode: decryptKey(password, _Buffer.from(saveHDWallet.chainCode, 'hex'))
  };
  return new Array(accountCount).fill(undefined).map((_, idx) => formatAccount(getKeyPair(derivePathFromKey(`${idx}h/0h/0h`, walletKey).secretKey)));
}
export const getHdWalletAccountFromSeed = (seed, accountIdx) => {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  const derived = derivePathFromKey(`${accountIdx}h/0h/0h`, walletKey);
  const keyPair = getKeyPair(derived.secretKey);
  return { ...formatAccount(keyPair),
    idx: accountIdx
  };
};
//# sourceMappingURL=hd-wallet.mjs.map