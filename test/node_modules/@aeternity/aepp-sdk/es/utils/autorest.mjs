import { RestError } from '@azure/core-rest-pipeline';
import { pause } from "./other.mjs";
import semverSatisfies from "./semver-satisfies.mjs";
import { UnsupportedVersionError } from "./errors.mjs";
export const genRequestQueuesPolicy = () => {
  const requestQueues = new Map();
  return {
    policy: {
      name: 'request-queues',

      async sendRequest(request, next) {
        var _requestQueues$get;

        const key = request.headers.get('__queue');
        request.headers.delete('__queue');

        const getResponse = async () => next(request);

        if (key == null) return getResponse();
        const req = ((_requestQueues$get = requestQueues.get(key)) !== null && _requestQueues$get !== void 0 ? _requestQueues$get : Promise.resolve()).then(getResponse, getResponse); // TODO: remove after fixing https://github.com/aeternity/aeternity/issues/3803
        // gap to ensure that node won't reject the nonce

        requestQueues.set(key, req.then(async () => pause(750)));
        return req;
      }

    },
    position: 'perCall'
  };
};
export const genCombineGetRequestsPolicy = () => {
  const pendingGetRequests = new Map();
  return {
    policy: {
      name: 'combine-requests',

      async sendRequest(request, next) {
        var _pendingGetRequests$g;

        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_pendingGetRequests$g = pendingGetRequests.get(key)) !== null && _pendingGetRequests$g !== void 0 ? _pendingGetRequests$g : next(request);
        pendingGetRequests.set(key, response);

        try {
          return await response;
        } finally {
          pendingGetRequests.delete(key);
        }
      }

    },
    position: 'perCall'
  };
};
export const genErrorFormatterPolicy = getMessage => ({
  policy: {
    name: 'error-formatter',

    async sendRequest(request, next) {
      try {
        return await next(request);
      } catch (error) {
        var _error$response;

        if (!(error instanceof RestError) || error.request == null) throw error;
        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;
        let body;

        try {
          body = JSON.parse(error.response.bodyAsText);
        } catch (e) {
          throw error;
        }

        error.message = `${new URL(error.request.url).pathname.slice(1)} error`;
        const message = getMessage(body);
        if (message !== '') error.message += `:${message}`;
        throw error;
      }
    }

  },
  position: 'perCall'
});
export const genVersionCheckPolicy = (name, ignorePath, versionPromise, geVersion, ltVersion) => ({
  name: 'version-check',

  async sendRequest(request, next) {
    if (new URL(request.url).pathname === ignorePath) return next(request);
    const args = [await versionPromise, geVersion, ltVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError(name, ...args);
    return next(request);
  }

});
//# sourceMappingURL=autorest.mjs.map