import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import AeSdkBase from "./AeSdkBase.mjs";
import AccountRpc from "./account/Rpc.mjs";
import { decode } from "./utils/encoder.mjs";
import { RPC_VERSION } from "./aepp-wallet-communication/rpc/types.mjs";
import RpcClient from "./aepp-wallet-communication/rpc/RpcClient.mjs";
import { METHODS } from "./aepp-wallet-communication/schema.mjs";
import { AlreadyConnectedError, NoWalletConnectedError, UnsubscribedAccountError, UnAuthorizedAccountError, RpcConnectionError } from "./utils/errors.mjs";
import Node from "./Node.mjs";

/**
 * RPC handler for AEPP side
 * Contain functionality for wallet interaction and connect it to sdk
 * @category aepp wallet communication
 */
export default class AeSdkAepp extends AeSdkBase {
  /**
   * @param options - Options
   * @param options.name - Aepp name
   * @param options.onAddressChange - Call-back function for update address event
   * @param options.onDisconnect - Call-back function for disconnect event
   * @param options.onNetworkChange - Call-back function for update network event
   */
  constructor(_ref) {
    let {
      name,
      onAddressChange = () => {},
      onDisconnect = () => {},
      onNetworkChange = () => {},
      ...other
    } = _ref;
    super(other);
    this.onAddressChange = onAddressChange;
    this.onDisconnect = onDisconnect;
    this.onNetworkChange = onNetworkChange;
    this.name = name;
  }

  _resolveAccount() {
    let account = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.addresses()[0];

    if (typeof account === 'string') {
      var _context;

      const address = account;
      decode(address);
      if (!_includesInstanceProperty(_context = this.addresses()).call(_context, address)) throw new UnAuthorizedAccountError(address);
      account = new AccountRpc({
        rpcClient: this.rpcClient,
        address
      });
    }

    if (account == null) this._ensureAccountAccess();
    return super._resolveAccount(account);
  }

  addresses() {
    if (this._accounts == null) return [];
    const current = Object.keys(this._accounts.current)[0];
    return [...(current != null ? [current] : []), ...Object.keys(this._accounts.connected)];
  }
  /**
   * Connect to wallet
   * @param connection - Wallet connection object
   * @param options - Options
   * @param options.connectNode - Request wallet to bind node
   * @param options.name - Node name
   * @param options.select - Select this node as current
   */


  async connectToWallet(connection) {
    let {
      connectNode = false,
      name = 'wallet-node',
      select = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (this.rpcClient != null) throw new AlreadyConnectedError('You are already connected to wallet');
    let disconnectParams;
    const client = new RpcClient(connection, () => {
      delete this.rpcClient;
      delete this._accounts;
      this.onDisconnect(disconnectParams);
    }, {
      [METHODS.updateAddress]: params => {
        this._accounts = params;
        this.onAddressChange(params);
      },
      [METHODS.updateNetwork]: params => {
        const {
          node
        } = params;
        if (node != null) this.addNode(node.name, new Node(node.url), true);
        this.onNetworkChange(params);
      },
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    const {
      node,
      ...walletInfo
    } = await client.request(METHODS.connect, {
      name: this.name,
      version: RPC_VERSION,
      connectNode
    });

    if (connectNode) {
      if (node == null) throw new RpcConnectionError('Missing URLs of the Node');
      this.addNode(name, new Node(node.url), select);
    }

    this.rpcClient = client;
    return walletInfo;
  }
  /**
   * Disconnect from wallet
   */


  disconnectWallet() {
    this._ensureConnected();

    this.rpcClient.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    this.rpcClient.connection.disconnect();
  }
  /**
   * Ask addresses from wallet
   * @returns Addresses from wallet
   */


  async askAddresses() {
    this._ensureAccountAccess();

    return this.rpcClient.request(METHODS.address, undefined);
  }
  /**
   * Subscribe for addresses from wallet
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */


  async subscribeAddress(type, value) {
    this._ensureConnected();

    const result = await this.rpcClient.request(METHODS.subscribeAddress, {
      type,
      value
    });
    this._accounts = result.address;
    return result;
  }

  _ensureConnected() {
    if (this.rpcClient != null) return;
    throw new NoWalletConnectedError('You are not connected to Wallet');
  }

  _ensureAccountAccess() {
    this._ensureConnected();

    if (this.addresses().length !== 0) return;
    throw new UnsubscribedAccountError();
  }

}
//# sourceMappingURL=AeSdkAepp.mjs.map