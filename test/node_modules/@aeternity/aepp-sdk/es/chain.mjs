/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */
import { AE_AMOUNT_FORMATS, formatAmount } from "./utils/amount-formatter.mjs";
import verifyTransaction from "./tx/validator.mjs";
import { pause } from "./utils/other.mjs";
import { isNameValid, produceNameId } from "./tx/builder/helpers.mjs";
import { DRY_RUN_ACCOUNT } from "./tx/builder/schema.mjs";
import { AensPointerContextError, DryRunError, InvalidAensNameError, TransactionError, TxTimedOutError, TxNotInChainError, InternalError } from "./utils/errors.mjs";
import { decode } from "./utils/encoder.mjs";

/**
 * @category chain
 */
export function _getPollInterval(type, _ref) {
  let {
    _expectedMineRate = 180000,
    _microBlockCycle = 3000,
    _maxPollInterval = 5000
  } = _ref;
  const base = {
    block: _expectedMineRate,
    microblock: _microBlockCycle
  }[type];
  return Math.min(base / 3, _maxPollInterval);
}
/**
 * @category exception
 */

export class InvalidTxError extends TransactionError {
  constructor(message, validation, transaction) {
    super(message);
    this.name = 'InvalidTxError';
    this.validation = validation;
    this.transaction = transaction;
  }

}
/**
 * Obtain current height of the chain
 * @category chain
 * @returns Current chain height
 */

export async function getHeight(_ref2) {
  let {
    onNode
  } = _ref2;
  return (await onNode.getCurrentKeyBlockHeight()).height;
}
/**
 * Wait for a transaction to be mined
 * @category chain
 * @param th - The hash of transaction to poll
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.blocks - Number of blocks mined after which to fail
 * @param options.onNode - Node to use
 * @returns The transaction as it was mined
 */

export async function poll(th, _ref3) {
  var _interval;

  let {
    blocks = 10,
    interval,
    onNode,
    ...options
  } = _ref3;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const max = (await getHeight({
    onNode
  })) + blocks;

  do {
    const tx = await onNode.getTransactionByHash(th);
    if (tx.blockHeight !== -1) return tx;
    await pause(interval);
  } while ((await getHeight({
    onNode
  })) < max);

  throw new TxTimedOutError(blocks, th);
}
/**
 * Wait for the chain to reach a specific height
 * @category chain
 * @param height - Height to wait for
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.onNode - Node to use
 * @returns Current chain height
 */

export async function awaitHeight(height, _ref4) {
  var _interval2;

  let {
    interval,
    onNode,
    ...options
  } = _ref4;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('block', options);
  let currentHeight;

  do {
    if (currentHeight != null) await pause(interval);
    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;
  } while (currentHeight < height);

  return currentHeight;
}
/**
 * Wait for transaction confirmation
 * @category chain
 * @param txHash - Transaction hash
 * @param options - Options
 * @param options.confirm - Number of micro blocks to wait for transaction confirmation
 * @param options.onNode - Node to use
 * @returns Current Height
 */

export async function waitForTxConfirm(txHash, _ref5) {
  let {
    confirm = 3,
    onNode,
    ...options
  } = _ref5;
  const {
    blockHeight
  } = await onNode.getTransactionByHash(txHash);
  const height = await awaitHeight(blockHeight + confirm, {
    onNode,
    ...options
  });
  const {
    blockHeight: newBlockHeight
  } = await onNode.getTransactionByHash(txHash);

  switch (newBlockHeight) {
    case -1:
      throw new TxNotInChainError(txHash);

    case blockHeight:
      return height;

    default:
      return waitForTxConfirm(txHash, {
        onNode,
        confirm,
        ...options
      });
  }
}
/**
 * Submit a signed transaction for mining
 * @category chain
 * @param tx - Transaction to submit
 * @param options - Options
 * @param options.onNode - Node to use
 * @param options.onAccount - Account to use
 * @param options.verify - Verify transaction before sending
 * @param options.waitMined - Ensure that transaction get into block
 * @param options.confirm - Number of micro blocks that should be mined after tx get included
 * @returns Transaction details
 */

export async function sendTransaction(tx, _ref6) {
  let {
    onNode,
    onAccount,
    verify = true,
    waitMined = true,
    confirm,
    ...options
  } = _ref6;

  if (verify) {
    const validation = await verifyTransaction(tx, onNode);

    if (validation.length > 0) {
      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;
      throw new InvalidTxError(message, validation, tx);
    }
  }

  try {
    let __queue;

    try {
      __queue = onAccount != null ? `tx-${await onAccount.address(options)}` : null;
    } catch (error) {
      __queue = null;
    }

    const {
      txHash
    } = await onNode.postTransaction({
      tx
    }, __queue != null ? {
      requestOptions: {
        customHeaders: {
          __queue
        }
      }
    } : {});

    if (waitMined) {
      const pollResult = await poll(txHash, {
        onNode,
        ...options
      });
      const txData = { ...pollResult,
        hash: pollResult.hash,
        rawTx: tx
      }; // wait for transaction confirmation

      if (confirm != null && (confirm === true || confirm > 0)) {
        const c = typeof confirm === 'boolean' ? undefined : confirm;
        return { ...txData,
          confirmationHeight: await waitForTxConfirm(txHash, {
            onNode,
            confirm: c,
            ...options
          })
        };
      }

      return txData;
    }

    return {
      hash: txHash,
      rawTx: tx
    };
  } catch (error) {
    throw Object.assign(error, {
      rawTx: tx,
      verifyTx: async () => verifyTransaction(tx, onNode)
    });
  }
}

/**
 * Get account by account public key
 * @category chain
 * @param address - Account address (public key)
 * @param options - Options
 * @param options.height - Get account on specific block by block height
 * @param options.hash - Get account on specific block by micro block hash or key block hash
 * @param options.onNode - Node to use
 */
export async function getAccount(address, _ref7) {
  let {
    height,
    hash,
    onNode
  } = _ref7;
  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);
  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);
  return onNode.getAccountByPubkey(address);
}
/**
 * Request the balance of specified account
 * @category chain
 * @param address - The public account address to obtain the balance for
 * @param options - Options
 * @param options.format
 * @param options.height - The chain height at which to obtain the balance for
 * (default: top of chain)
 * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)
 */

export async function getBalance(address, _ref8) {
  let {
    format = AE_AMOUNT_FORMATS.AETTOS,
    ...options
  } = _ref8;
  const {
    balance
  } = await getAccount(address, options).catch(() => ({
    balance: 0n
  }));
  return formatAmount(balance, {
    targetDenomination: format
  });
}
/**
 * Obtain current generation
 * @category chain
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Current Generation
 */

export async function getCurrentGeneration(_ref9) {
  let {
    onNode
  } = _ref9;
  return onNode.getCurrentGeneration();
}
/**
 * Get generation by hash or height
 * @category chain
 * @param hashOrHeight - Generation hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Generation
 */

export async function getGeneration(hashOrHeight, _ref10) {
  let {
    onNode
  } = _ref10;
  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);
  return onNode.getGenerationByHash(hashOrHeight);
}
/**
 * Get micro block transactions
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transactions
 */

export async function getMicroBlockTransactions(hash, _ref11) {
  let {
    onNode
  } = _ref11;
  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;
}
/**
 * Get key block
 * @category chain
 * @param hashOrHeight - Key block hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Key Block
 */

export async function getKeyBlock(hashOrHeight, _ref12) {
  let {
    onNode
  } = _ref12;
  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);
  return onNode.getKeyBlockByHash(hashOrHeight);
}
/**
 * Get micro block header
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Micro block header
 */

export async function getMicroBlockHeader(hash, _ref13) {
  let {
    onNode
  } = _ref13;
  return onNode.getMicroBlockHeaderByHash(hash);
}
const txDryRunRequests = new Map();

async function txDryRunHandler(key, onNode) {
  const rs = txDryRunRequests.get(key);
  txDryRunRequests.delete(key);
  if (rs == null) throw new InternalError('Can\'t get dry-run request');
  let dryRunRes;

  try {
    dryRunRes = await onNode.protectedDryRunTxs({
      top: rs[0].top,
      txEvents: rs[0].txEvents,
      txs: rs.map(req => ({
        tx: req.tx
      })),
      accounts: Array.from(new Set(rs.map(req => req.accountAddress))).map(pubKey => ({
        pubKey,
        amount: DRY_RUN_ACCOUNT.amount
      }))
    });
  } catch (error) {
    rs.forEach(_ref14 => {
      let {
        reject
      } = _ref14;
      return reject(error);
    });
    return;
  }

  const {
    results,
    txEvents
  } = dryRunRes;
  results.forEach((_ref15, idx) => {
    let {
      result,
      reason,
      ...resultPayload
    } = _ref15;
    const {
      resolve,
      reject,
      tx,
      accountAddress
    } = rs[idx];
    if (result === 'ok') resolve({ ...resultPayload,
      txEvents
    });else reject(Object.assign(new DryRunError(reason), {
      tx,
      accountAddress
    }));
  });
}
/**
 * Transaction dry-run
 * @category chain
 * @param tx - transaction to execute
 * @param accountAddress - address that will be used to execute transaction
 * @param options - Options
 * @param options.top - hash of block on which to make dry-run
 * @param options.txEvents - collect and return on-chain tx events that would result from the call
 * @param options.combine - Enables combining of similar requests to a single dry-run call
 * @param options.onNode - Node to use
 */


export async function txDryRun(tx, accountAddress, _ref16) {
  var _txDryRunRequests$get;

  let {
    top,
    txEvents,
    combine,
    onNode
  } = _ref16;
  const key = combine === true ? [top, txEvents].join() : 'immediate';
  const requests = (_txDryRunRequests$get = txDryRunRequests.get(key)) !== null && _txDryRunRequests$get !== void 0 ? _txDryRunRequests$get : [];
  txDryRunRequests.set(key, requests);
  return new Promise((resolve, reject) => {
    var _requests$timeout;

    requests.push({
      tx,
      accountAddress,
      top,
      txEvents,
      resolve,
      reject
    });

    if (combine !== true) {
      void txDryRunHandler(key, onNode);
      return;
    }

    (_requests$timeout = requests.timeout) !== null && _requests$timeout !== void 0 ? _requests$timeout : requests.timeout = setTimeout(() => {
      void txDryRunHandler(key, onNode);
    });
  });
}
/**
 * Get contract byte code
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */

export async function getContractByteCode(contractId, _ref17) {
  let {
    onNode
  } = _ref17;
  return onNode.getContractCode(contractId);
}
/**
 * Get contract entry
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */

export async function getContract(contractId, _ref18) {
  let {
    onNode
  } = _ref18;
  return onNode.getContract(contractId);
}
/**
 * Get name entry
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onNode - Node to use
 */

export async function getName(name, _ref19) {
  let {
    onNode
  } = _ref19;
  return onNode.getNameEntryByName(name);
}
/**
 * Resolve AENS name and return name hash
 * @category AENS
 * @param nameOrId - AENS name or address
 * @param key - in AENS pointers record
 * @param options - Options
 * @param options.verify - To ensure that name exist and have a corresponding pointer
 * // TODO: avoid that to don't trust to current api gateway
 * @param options.resolveByNode - Enables pointer resolving using node
 * @param options.onNode - Node to use
 * @returns Address or AENS name hash
 */

export async function resolveName(nameOrId, key, _ref20) {
  let {
    verify = true,
    resolveByNode = false,
    onNode
  } = _ref20;

  if (isNameValid(nameOrId)) {
    if (verify || resolveByNode) {
      const name = await onNode.getNameEntryByName(nameOrId);
      const pointer = name.pointers.find(p => p.key === key);
      if (pointer == null) throw new AensPointerContextError(nameOrId, key);
      if (resolveByNode) return pointer.id;
    }

    return produceNameId(nameOrId);
  }

  try {
    decode(nameOrId);
    return nameOrId;
  } catch (error) {
    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);
  }
}
//# sourceMappingURL=chain.mjs.map