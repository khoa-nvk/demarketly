import * as chainMethods from './chain';
import * as txMethods from './tx';
import * as aensMethods from './aens';
import * as spendMethods from './spend';
import * as oracleMethods from './oracle';
import * as contractMethods from './contract/methods';
import * as contractGaMethods from './contract/ga';
import * as deprecatedMethods from './deprecated/methods';
import { _buildTx } from './tx';
import Node, { getNetworkId } from './Node';
import { AE_AMOUNT_FORMATS } from './utils/amount-formatter';
import { Tag } from './tx/builder/constants';
import { Keypair } from './account/Memory';
import AccountBase from './account/Base';
import { Encoded } from './utils/encoder';
import Compiler from './contract/Compiler';
export declare type Account = Keypair | AccountBase | any;
declare type NodeInfo = Awaited<ReturnType<Node['getNodeInfo']>> & {
    name: string;
};
/**
 * Basic AeSdk class
 *
 * AeSdkBase objects are the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 * Only by providing the joint functionality of them, most more advanced
 * operations, i.e. the ones with actual use value on the chain, become
 * available.
 */
declare class AeSdkBase {
    _options: {
        denomination: AE_AMOUNT_FORMATS;
        amount: number;
        [key: string]: any;
    };
    pool: Map<string, Node>;
    selectedNodeName?: string;
    compilerApi: Compiler;
    /**
     * @param options - Options
     * @param options.nodes - Array of nodes
     * @param options.compilerUrl - Url for compiler API
     * @param options.ignoreVersion - Don't check node or compiler version
     */
    constructor({ nodes, compilerUrl, ignoreVersion, ...options }?: {
        nodes?: Array<{
            name: string;
            instance: Node;
        }>;
        compilerUrl?: string;
        ignoreVersion?: boolean;
        [key: string]: any;
    });
    setCompilerUrl(compilerUrl: string, { ignoreVersion }?: {
        ignoreVersion?: boolean;
    }): void;
    get api(): Node;
    /**
     * Add Node
     * @param name - Node name
     * @param node - Node instance
     * @param select - Select this node as current
     * @example
     * ```js
     * // add and select new node with name 'testNode'
     * aeSdkBase.addNode('testNode', new Node({ url }), true)
     * ```
     */
    addNode(name: string, node: Node, select?: boolean): void;
    /**
     * Select Node
     * @param name - Node name
     * @example
     * nodePool.selectNode('testNode')
     */
    selectNode(name: string): void;
    /**
     * Get NetworkId of current Node
     * @example
     * nodePool.getNetworkId()
     */
    readonly getNetworkId: typeof getNetworkId;
    /**
     * Check if you have selected node
     * @example
     * nodePool.isNodeConnected()
     */
    isNodeConnected(): this is AeSdkBase & {
        selectedNodeName: string;
    };
    protected ensureNodeConnected(): asserts this is AeSdkBase & {
        selectedNodeName: string;
    };
    /**
     * Get information about node
     * @example
     * ```js
     * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
     * ```
     */
    getNodeInfo(): Promise<NodeInfo>;
    /**
     * Get array of available nodes
     * @example
     * nodePool.getNodesInPool()
     */
    getNodesInPool(): Promise<NodeInfo[]>;
    addresses(): Encoded.AccountAddress[];
    address({ onAccount }?: {
        onAccount?: Account;
    }): Promise<Encoded.AccountAddress>;
    sign(data: string | Uint8Array, { onAccount, ...options }?: {
        onAccount?: Account;
    }): Promise<Uint8Array>;
    signTransaction(tx: Encoded.Transaction, { onAccount, ...options }?: {
        onAccount?: Account;
    } & Parameters<AccountBase['signTransaction']>[1]): Promise<Encoded.Transaction>;
    signMessage(message: string, { onAccount, ...options }?: {
        onAccount?: Account;
    } & Parameters<AccountBase['signMessage']>[1]): Promise<string | Uint8Array>;
    verifyMessage(message: string, signature: string | Uint8Array, { onAccount, ...options }?: {
        onAccount?: Account;
    } & Parameters<AccountBase['verifyMessage']>[2]): Promise<boolean>;
    /**
     * Resolves an account
     * @param account - ak-address, instance of AccountBase, or keypair
     */
    _resolveAccount(account?: Account): AccountBase;
    _getOptions(): {
        onNode: Node;
        onAccount: AccountBase;
        onCompiler: Compiler;
    };
    buildTx<TxType extends Tag>(txType: TxType, options: Omit<Parameters<typeof _buildTx<TxType>>[1], 'onNode'> & {
        onNode?: Node;
    }): Promise<Encoded.Transaction>;
}
declare const methods: {
    readonly signUsingGA: typeof deprecatedMethods.signUsingGA;
    readonly height: typeof deprecatedMethods.height;
    readonly isGA: typeof contractGaMethods.isGA;
    readonly createGeneralizedAccount: typeof contractGaMethods.createGeneralizedAccount;
    readonly createMetaTx: typeof contractGaMethods.createMetaTx;
    readonly buildAuthTxHash: typeof contractGaMethods.buildAuthTxHash;
    readonly createAensDelegationSignature: typeof contractMethods.createAensDelegationSignature;
    readonly createOracleDelegationSignature: typeof contractMethods.createOracleDelegationSignature;
    readonly getContractInstance: typeof contractMethods.getContractInstance;
    readonly pollForQueries: typeof oracleMethods.pollForQueries;
    readonly pollForQueryResponse: typeof oracleMethods.pollForQueryResponse;
    readonly getQueryObject: typeof oracleMethods.getQueryObject;
    readonly postQueryToOracle: typeof oracleMethods.postQueryToOracle;
    readonly extendOracleTtl: typeof oracleMethods.extendOracleTtl;
    readonly respondToQuery: typeof oracleMethods.respondToQuery;
    readonly getOracleObject: typeof oracleMethods.getOracleObject;
    readonly registerOracle: typeof oracleMethods.registerOracle;
    readonly send: typeof spendMethods.send;
    readonly spend: typeof spendMethods.spend;
    readonly transferFunds: typeof spendMethods.transferFunds;
    readonly payForTransaction: typeof spendMethods.payForTransaction;
    readonly aensRevoke: typeof aensMethods.aensRevoke;
    readonly aensUpdate: typeof aensMethods.aensUpdate;
    readonly aensTransfer: typeof aensMethods.aensTransfer;
    readonly aensQuery: typeof aensMethods.aensQuery;
    readonly aensClaim: typeof aensMethods.aensClaim;
    readonly aensPreclaim: typeof aensMethods.aensPreclaim;
    readonly aensBid: typeof aensMethods.aensBid;
    readonly getVmVersion: typeof txMethods.getVmVersion;
    readonly prepareTxParams: typeof txMethods.prepareTxParams;
    readonly _getPollInterval: typeof chainMethods._getPollInterval;
    readonly getHeight: typeof chainMethods.getHeight;
    readonly poll: typeof chainMethods.poll;
    readonly awaitHeight: typeof chainMethods.awaitHeight;
    readonly waitForTxConfirm: typeof chainMethods.waitForTxConfirm;
    readonly sendTransaction: typeof chainMethods.sendTransaction;
    readonly getAccount: typeof chainMethods.getAccount;
    readonly getBalance: typeof chainMethods.getBalance;
    readonly getCurrentGeneration: typeof chainMethods.getCurrentGeneration;
    readonly getGeneration: typeof chainMethods.getGeneration;
    readonly getMicroBlockTransactions: typeof chainMethods.getMicroBlockTransactions;
    readonly getKeyBlock: typeof chainMethods.getKeyBlock;
    readonly getMicroBlockHeader: typeof chainMethods.getMicroBlockHeader;
    readonly txDryRun: typeof chainMethods.txDryRun;
    readonly getContractByteCode: typeof chainMethods.getContractByteCode;
    readonly getContract: typeof chainMethods.getContract;
    readonly getName: typeof chainMethods.getName;
    readonly resolveName: typeof chainMethods.resolveName;
};
declare type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
declare type OptionalIfNotRequired<T extends [any]> = RequiredKeys<T[0]> extends never ? T | [] : T;
declare type MakeOptional<Args extends any[]> = Args extends [infer Head, ...infer Tail] ? Tail extends [] ? Head extends object ? OptionalIfNotRequired<[
    Omit<Head, 'onNode' | 'onCompiler' | 'onAccount'> & {
        onNode?: Node;
        onCompiler?: Compiler;
        onAccount?: AccountBase | Encoded.AccountAddress | Keypair;
    }
]> : [Head] : [Head, ...MakeOptional<Tail>] : never;
declare type TransformMethods<Methods extends {
    [key: string]: Function;
}> = {
    [Name in keyof Methods]: Methods[Name] extends (...args: infer Args) => infer Ret ? (...args: MakeOptional<Args>) => Ret : never;
};
interface AeSdkBaseMethods extends TransformMethods<typeof methods> {
}
declare const _default: new (options?: ConstructorParameters<typeof AeSdkBase>[0]) => AeSdkBase & AeSdkBaseMethods;
export default _default;
