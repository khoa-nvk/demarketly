/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Oracle methods - routines to interact with the Ã¦ternity oracle system
 *
 * The high-level description of the oracle system is
 * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol
 * repository.
 */
import { send } from "./spend.mjs";
import { mapObject, pause } from "./utils/other.mjs";
import { oracleQueryId } from "./tx/builder/helpers.mjs";
import { unpackTx } from "./tx/builder/index.mjs";
import { ORACLE_TTL, QUERY_FEE, QUERY_TTL, RESPONSE_TTL } from "./tx/builder/schema.mjs";
import { Tag } from "./tx/builder/constants.mjs";
import { RequestTimedOutError } from "./utils/errors.mjs";
import { decode, encode, Encoding } from "./utils/encoder.mjs";
import { _getPollInterval } from "./chain.mjs";
import { _buildTx } from "./tx/index.mjs";

/**
 * Poll for oracle queries
 * @category oracle
 * @param oracleId - Oracle public key
 * @param onQuery - OnQuery callback
 * @param options - Options object
 * @param options.interval - Poll interval(default: 5000)
 * @param options.onNode - Node to use
 * @returns Callback to stop polling function
 */
export function pollForQueries(oracleId, onQuery, _ref) {
  var _interval;

  let {
    interval,
    onNode,
    ...options
  } = _ref;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const knownQueryIds = new Set();

  const checkNewQueries = async () => {
    var _await$onNode$getOrac;

    const queries = ((_await$onNode$getOrac = (await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries) !== null && _await$onNode$getOrac !== void 0 ? _await$onNode$getOrac : []).filter(_ref2 => {
      let {
        id
      } = _ref2;
      return !knownQueryIds.has(id);
    });
    queries.forEach(_ref3 => {
      let {
        id
      } = _ref3;
      return knownQueryIds.add(id);
    });
    if (queries.length > 0) onQuery(queries);
  };

  let stopped = false; // eslint-disable-next-line @typescript-eslint/no-floating-promises

  (async () => {
    while (!stopped) {
      // eslint-disable-line no-unmodified-loop-condition
      // TODO: allow to handle this error somehow
      await checkNewQueries().catch(console.error);
      await pause(interval);
    }
  })();

  return () => {
    stopped = true;
  };
}
/**
 * Poll for oracle query response
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options object
 * @param options.interval - Poll interval
 * @param options.onNode - Node to use
 * @returns OracleQuery object
 */

export async function pollForQueryResponse(oracleId, queryId, _ref4) {
  var _interval2;

  let {
    interval,
    onNode,
    ...options
  } = _ref4;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('microblock', options);
  let height;
  let ttl;
  let response;

  do {
    if (height != null) await pause(interval);
    ({
      response,
      ttl
    } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));
    const responseBuffer = decode(response);
    if (responseBuffer.length > 0) return responseBuffer.toString();
    height = await this.getHeight();
  } while (ttl >= height);

  throw new RequestTimedOutError(height);
}
/**
 * Constructor for OracleQuery Object (helper object for using OracleQuery)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options
 * @returns OracleQuery object
 */

export async function getQueryObject(oracleId, queryId, options) {
  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);
  return { ...record,
    decodedQuery: decode(record.query).toString(),
    decodedResponse: decode(record.response).toString(),
    respond: async (response, opt) => // eslint-disable-next-line @typescript-eslint/no-use-before-define
    respondToQuery(oracleId, queryId, response, { ...options,
      ...opt
    }),
    pollForResponse: async opt => pollForQueryResponse(oracleId, queryId, { ...options,
      ...opt
    })
  };
}

/**
 * Post query to oracle
 * @category oracle
 * @param oracleId - Oracle public key
 * @param query - Oracle query object
 * @param options - Options object
 * @param options.queryTtl - queryTtl Oracle query time to leave
 * @param options.responseTtl - queryFee Oracle query response time to leave
 * @param options.queryFee - queryFee Oracle query fee
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Query object
 */
export async function postQueryToOracle(oracleId, query, options) {
  var _options$queryFee;

  (_options$queryFee = options.queryFee) !== null && _options$queryFee !== void 0 ? _options$queryFee : options.queryFee = (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();
  const senderId = await options.onAccount.address(options);
  const oracleQueryTx = await _buildTx(Tag.OracleQueryTx, {
    queryTtlType: QUERY_TTL.type,
    queryTtlValue: QUERY_TTL.value,
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    oracleId,
    senderId,
    query
  });
  const {
    nonce
  } = unpackTx(oracleQueryTx, Tag.OracleQueryTx).tx;
  const queryId = oracleQueryId(senderId, nonce, oracleId);
  return { ...(await send(oracleQueryTx, options)),
    ...(await getQueryObject(oracleId, queryId, options))
  };
}

/**
 * Extend oracle ttl
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options object
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @param options.oracleTtlType - Oracle time to leave for extend
 * @param options.oracleTtlValue - Oracle time to leave for extend
 * @returns Oracle object
 */
export async function extendOracleTtl(oracleId, options) {
  const oracleExtendTx = await _buildTx(Tag.OracleExtendTx, {
    oracleTtlType: ORACLE_TTL.type,
    oracleTtlValue: ORACLE_TTL.value,
    ...options,
    callerId: await options.onAccount.address(options),
    oracleId
  });
  return { ...(await send(oracleExtendTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}

/**
 * Extend oracle ttl
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle query id
 * @param response - Oracle query response
 * @param options - Options object
 * @param options.responseTtl - responseTtl Query response time to leave
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
export async function respondToQuery(oracleId, queryId, response, options) {
  const oracleRespondTx = await _buildTx(Tag.OracleResponseTx, {
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    callerId: await options.onAccount.address(options),
    oracleId,
    queryId,
    response
  });
  return { ...(await send(oracleRespondTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}

/**
 * Constructor for Oracle Object (helper object for using Oracle)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options
 * @returns Oracle object
 */
export async function getOracleObject(oracleId, options) {
  return { ...(await options.onNode.getOracleByPubkey(oracleId)),
    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,
    ...mapObject({
      pollQueries: pollForQueries,
      postQuery: postQueryToOracle,
      respondToQuery,
      extendOracle: extendOracleTtl,
      getQuery: getQueryObject
    }, _ref5 => {
      let [name, handler] = _ref5;
      return [name, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        const lastArg = args[args.length - 1];

        if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
          Object.assign(lastArg, { ...options,
            ...lastArg
          });
        } else args.push(options);

        return handler(oracleId, ...args);
      }];
    })
  };
}

/**
 * Register oracle
 * @category oracle
 * @param queryFormat - Format of query
 * @param responseFormat - Format of query response
 * @param options - Options
 * @param options.queryFee - Oracle query Fee
 * @param options - Options object
 * @param options.abiVersion - Always 0 (do not use virtual machine)
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
export async function registerOracle(queryFormat, responseFormat, options) {
  const accountId = await options.onAccount.address(options);
  const oracleRegisterTx = await _buildTx(Tag.OracleRegisterTx, {
    queryFee: QUERY_FEE,
    oracleTtlValue: ORACLE_TTL.value,
    oracleTtlType: ORACLE_TTL.type,
    ...options,
    accountId,
    queryFormat,
    responseFormat
  });
  return { ...(await send(oracleRegisterTx, options)),
    ...(await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options))
  };
}
//# sourceMappingURL=oracle.mjs.map