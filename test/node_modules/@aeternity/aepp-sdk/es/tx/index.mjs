import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";

/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * Transaction methods
 *
 * This is implementation of [Tx](api/tx.md) relays
 * the creation of transactions to {@link Node}.
 * These methods provide ability to create native transactions.
 */
import { ABI_VERSIONS, PROTOCOL_VM_ABI, TX_TTL } from "./builder/schema.mjs";
import { Tag } from "./builder/constants.mjs";
import { ArgumentError, UnsupportedProtocolError, UnknownTxError, InvalidTxParamsError } from "../utils/errors.mjs";
import { buildTx as syncBuildTx, unpackTx } from "./builder/index.mjs";
import { isKeyOfObject } from "../utils/other.mjs";
export async function getVmVersion(txType, _ref) {
  var _abiVersion, _vmVersion;

  let {
    vmVersion,
    abiVersion,
    onNode
  } = _ref;
  const {
    consensusProtocolVersion
  } = await onNode.getNodeInfo();

  if (!isKeyOfObject(consensusProtocolVersion, PROTOCOL_VM_ABI)) {
    throw new UnsupportedProtocolError('Not supported consensus protocol version');
  }

  const supportedProtocol = PROTOCOL_VM_ABI[consensusProtocolVersion];

  if (!isKeyOfObject(txType, supportedProtocol)) {
    throw new UnknownTxError('Not supported tx type');
  }

  const protocolForTX = supportedProtocol[txType];
  (_abiVersion = abiVersion) !== null && _abiVersion !== void 0 ? _abiVersion : abiVersion = protocolForTX.abiVersion[0];
  (_vmVersion = vmVersion) !== null && _vmVersion !== void 0 ? _vmVersion : vmVersion = protocolForTX.vmVersion[0];
  return {
    vmVersion,
    abiVersion
  };
}
/**
 * Calculate fee, get absolute ttl (ttl + height), get account nonce
 * @category transaction builder
 * @param txType - Type of transaction
 * @param params - Object which contains all tx data
 * @returns Object with account nonce, absolute ttl and transaction fee
 */

export async function prepareTxParams(txType, _ref2) {
  var _nonce;

  let {
    senderId,
    nonce,
    ttl = TX_TTL,
    absoluteTtl,
    strategy,
    onNode
  } = _ref2;
  (_nonce = nonce) !== null && _nonce !== void 0 ? _nonce : nonce = (await onNode.getAccountNextNonce(senderId, {
    strategy
  }).catch(() => ({
    nextNonce: 1
  }))).nextNonce;

  if (ttl !== 0) {
    if (ttl < 0) throw new ArgumentError('ttl', 'greater or equal to 0', ttl);
    ttl += absoluteTtl === true ? 0 : (await onNode.getCurrentKeyBlock()).height;
  }

  return {
    ttl,
    nonce
  };
}
// TODO: find a better name or rearrange methods

/**
 * @category transaction builder
 */
export async function _buildTx(txType, _ref3) {
  var _context;

  let {
    denomination,
    absoluteTtl,
    ..._params
  } = _ref3;
  // TODO: avoid this assertion
  const params = _params;
  let senderKey;

  switch (txType) {
    case Tag.SpendTx:
    case Tag.OracleQueryTx:
      senderKey = 'senderId';
      break;

    case Tag.NameClaimTx:
    case Tag.NameUpdateTx:
    case Tag.NameRevokeTx:
    case Tag.NameTransferTx:
    case Tag.NamePreclaimTx:
    case Tag.OracleRegisterTx:
      senderKey = 'accountId';
      break;

    case Tag.ContractCreateTx:
    case Tag.GaAttachTx:
      senderKey = 'ownerId';
      break;

    case Tag.ContractCallTx:
    case Tag.OracleExtendTx:
    case Tag.OracleResponseTx:
      senderKey = 'callerId';
      break;

    case Tag.ChannelCloseSoloTx:
    case Tag.ChannelSlashTx:
    case Tag.ChannelSettleTx:
    case Tag.ChannelSnapshotSoloTx:
      senderKey = 'fromId';
      break;

    case Tag.PayingForTx:
      senderKey = 'payerId';
      break;

    default:
      throw new ArgumentError('txType', 'valid transaction type', txType);
  } // TODO: move specific cases to field-types


  if (_includesInstanceProperty(_context = [Tag.ContractCreateTx, Tag.GaAttachTx]).call(_context, txType)) {
    params.ctVersion = await getVmVersion(Tag.ContractCreateTx, { ...params,
      ...params.ctVersion
    });
  }

  if (txType === Tag.ContractCallTx) {
    params.abiVersion = (await getVmVersion(Tag.ContractCallTx, params)).abiVersion;
  }

  if (txType === Tag.OracleRegisterTx) {
    var _params$abiVersion;

    (_params$abiVersion = params.abiVersion) !== null && _params$abiVersion !== void 0 ? _params$abiVersion : params.abiVersion = ABI_VERSIONS.NO_ABI;
  }

  if (txType === Tag.PayingForTx) {
    params.tx = unpackTx(params.tx);
  }

  const senderId = params[senderKey]; // TODO: do this check on TypeScript level

  if (senderId == null) throw new InvalidTxParamsError(`Transaction field ${senderKey} is missed`);
  const extraParams = await prepareTxParams(txType, { ...params,
    senderId,
    absoluteTtl
  });
  return syncBuildTx({ ...params,
    ...extraParams
  }, txType, {
    denomination
  }).tx;
}
//# sourceMappingURL=index.mjs.map