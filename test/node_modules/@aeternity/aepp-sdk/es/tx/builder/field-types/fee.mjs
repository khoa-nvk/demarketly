import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import BigNumber from 'bignumber.js';
import { IllegalArgumentError } from "../../../utils/errors.mjs";
import { MIN_GAS_PRICE, Tag } from "../constants.mjs";
import coinAmount from "./coin-amount.mjs";
import { isKeyOfObject } from "../../../utils/other.mjs";
const BASE_GAS = 15000;
const GAS_PER_BYTE = 20;
const KEY_BLOCK_INTERVAL = 3;
/**
 * Calculate the Base fee gas
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @returns The base fee
 * @example
 * ```js
 * TX_FEE_BASE('channelForceProgress') => new BigNumber(30 * 15000)
 * ```
 */

const TX_FEE_BASE_GAS = txType => {
  var _feeFactors;

  const feeFactors = {
    [Tag.ChannelForceProgressTx]: 30,
    [Tag.ChannelOffChainTx]: 0,
    [Tag.ChannelOffChainUpdateCallContract]: 0,
    [Tag.ChannelOffChainUpdateCreateContract]: 0,
    [Tag.ChannelOffChainUpdateDeposit]: 0,
    [Tag.ChannelOffChainUpdateWithdraw]: 0,
    [Tag.ChannelOffChainUpdateTransfer]: 0,
    [Tag.ContractCreateTx]: 5,
    [Tag.ContractCallTx]: 12,
    [Tag.GaAttachTx]: 5,
    [Tag.GaMetaTx]: 5,
    [Tag.PayingForTx]: 1 / 5
  };
  const factor = (_feeFactors = feeFactors[txType]) !== null && _feeFactors !== void 0 ? _feeFactors : 1;
  return new BigNumber(factor * BASE_GAS);
};
/**
 * Calculate fee for Other types of transactions
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @param txSize - The transaction size
 * @returns parameters - The transaction parameters
 * @returns parameters.relativeTtl - The relative ttl
 * @returns parameters.innerTxSize - The size of the inner transaction
 * @returns The Other fee
 * @example
 * ```js
 * TX_FEE_OTHER_GAS('oracleResponse',10, { relativeTtl: 10, innerTxSize: 10 })
 *  => new BigNumber(10).times(20).plus(Math.ceil(32000 * 10 / Math.floor(60 * 24 * 365 / 2)))
 * ```
 */


const TX_FEE_OTHER_GAS = (txType, txSize, _ref) => {
  let {
    relativeTtl,
    innerTxSize
  } = _ref;

  switch (txType) {
    case Tag.OracleRegisterTx:
    case Tag.OracleExtendTx:
    case Tag.OracleQueryTx:
    case Tag.OracleResponseTx:
      return new BigNumber(txSize).times(GAS_PER_BYTE).plus(Math.ceil(32000 * relativeTtl / Math.floor(60 * 24 * 365 / KEY_BLOCK_INTERVAL)));

    case Tag.GaMetaTx:
    case Tag.PayingForTx:
      return new BigNumber(txSize).minus(innerTxSize).times(GAS_PER_BYTE);

    default:
      return new BigNumber(txSize).times(GAS_PER_BYTE);
  }
};

function getOracleRelativeTtl(params, txType) {
  const ttlKeys = {
    [Tag.OracleRegisterTx]: 'oracleTtlValue',
    [Tag.OracleExtendTx]: 'oracleTtlValue',
    [Tag.OracleQueryTx]: 'queryTtlValue',
    [Tag.OracleResponseTx]: 'responseTtlValue'
  };
  if (!isKeyOfObject(txType, ttlKeys)) return 1;
  return params[ttlKeys[txType]];
}
/**
 * Calculate fee based on tx type and params
 */


export function buildFee(txType, buildTx) {
  var _context;

  const {
    rlpEncoded: {
      length
    },
    txObject
  } = buildTx;
  return TX_FEE_BASE_GAS(txType).plus(TX_FEE_OTHER_GAS(txType, length, {
    relativeTtl: getOracleRelativeTtl(txObject, txType),
    innerTxSize: _includesInstanceProperty(_context = [Tag.GaMetaTx, Tag.PayingForTx]).call(_context, txType) ? txObject.tx.tx.encodedTx.rlpEncoded.length : 0
  })).times(MIN_GAS_PRICE);
}
/**
 * Calculate min fee
 * @category transaction builder
 * @param txType - Transaction type
 * @param rebuildTx - Callback to get built transaction with specific fee
 */

export function calculateMinFee(txType, rebuildTx) {
  let fee = new BigNumber(0);
  let previousFee;

  do {
    previousFee = fee;
    fee = buildFee(txType, rebuildTx(fee));
  } while (!fee.eq(previousFee));

  return fee;
}
export default { ...coinAmount,

  serializeAettos(_value, _ref2) {
    let {
      txType,
      rebuildTx,
      _computingMinFee
    } = _ref2;
    if (_computingMinFee != null) return _computingMinFee;
    const minFee = calculateMinFee(txType, fee => rebuildTx({
      _computingMinFee: fee
    }));
    const value = new BigNumber(_value !== null && _value !== void 0 ? _value : minFee);

    if (minFee.gt(value)) {
      throw new IllegalArgumentError(`Fee ${value.toString()} must be bigger then ${minFee}`);
    }

    return value.toFixed();
  },

  serialize: coinAmount.serializeOptional
};
//# sourceMappingURL=fee.mjs.map