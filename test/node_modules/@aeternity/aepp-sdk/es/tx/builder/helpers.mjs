import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import BigNumber from 'bignumber.js';
import { genSalt, hash } from "../../utils/crypto.mjs";
import { decode, encode, Encoding } from "../../utils/encoder.mjs";
import { toBytes } from "../../utils/bytes.mjs";
import { concatBuffers } from "../../utils/other.mjs";
import { NAME_BID_RANGES, NAME_BID_TIMEOUT_BLOCKS, NAME_FEE_BID_INCREMENT, NAME_MAX_LENGTH_FEE } from "./constants.mjs";
import { ceil } from "../../utils/bignumber.mjs";
import { ArgumentError, IllegalBidFeeError } from "../../utils/errors.mjs";
import { readId, writeId } from "./address.mjs";
/**
 * JavaScript-based Transaction builder helper function's
 */

/**
 * Build a contract public key
 * @category contract
 * @param ownerId - The public key of the owner account
 * @param nonce - the nonce of the transaction
 * @returns Contract public key
 */

export function buildContractId(ownerId, nonce) {
  const ownerIdAndNonce = _Buffer.from([...decode(ownerId), ...toBytes(nonce)]);

  const b2bHash = hash(ownerIdAndNonce);
  return encode(b2bHash, Encoding.ContractAddress);
}
/**
 * Build a oracle query id
 * @category oracle
 * @param senderId - The public key of the sender account
 * @param nonce - the nonce of the transaction
 * @param oracleId - The oracle public key
 * @returns Contract public key
 */

export function oracleQueryId(senderId, nonce, oracleId) {
  function _int32(val) {
    const nonceBE = toBytes(val, true);
    return concatBuffers([_Buffer.alloc(32 - nonceBE.length), nonceBE]);
  }

  const b2bHash = hash(_Buffer.from([...decode(senderId), ..._int32(nonce), ...decode(oracleId)]));
  return encode(b2bHash, Encoding.OracleQueryId);
}
/**
 * Format the salt into a 64-byte hex string
 * @category transaction builder
 * @param salt - Random number
 * @returns Zero-padded hex string of salt
 */

export function formatSalt(salt) {
  return _Buffer.from(salt.toString(16).padStart(64, '0'), 'hex');
}
/**
 * Encode an AENS name
 * @category AENS
 * @param name - Name to encode
 * @returns `nm_` prefixed encoded AENS name
 */

export function produceNameId(name) {
  return encode(hash(name.toLowerCase()), Encoding.Name);
}
/**
 * Generate the commitment hash by hashing the formatted salt and
 * name, base 58 encoding the result and prepending 'cm_'
 * @category transaction builder
 * @param name - Name to be registered
 * @param salt - Random salt
 * @returns Commitment hash
 */

export function commitmentHash(name) {
  let salt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : genSalt();
  return encode(hash(concatBuffers([_Buffer.from(name.toLowerCase()), formatSalt(salt)])), Encoding.Commitment);
}
/**
 * Utility function to convert int to bytes
 * @category transaction builder
 * @param val - Value
 * @returns Buffer Buffer from number(BigEndian)
 */

export function writeInt(val) {
  return toBytes(val, true);
}
/**
 * Utility function to convert bytes to int
 * @category transaction builder
 * @param buf - Value
 * @returns Buffer Buffer from number(BigEndian)
 */

export function readInt() {
  let buf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Buffer.from([]);
  return new BigNumber(_Buffer.from(buf).toString('hex'), 16).toString(10);
}
/**
 * Helper function to build pointers for name update TX
 * @category transaction builder
 * @param pointers - Array of pointers
 * `([ { key: 'account_pubkey', id: 'ak_32klj5j23k23j5423l434l2j3423'} ])`
 * @returns Serialized pointers array
 */

export function buildPointers(pointers) {
  return pointers.map(p => [toBytes(p.key), writeId(p.id)]);
}
/**
 * Helper function to read pointers from name update TX
 * @category transaction builder
 * @param pointers - Array of pointers
 * @returns Deserialize pointer array
 */

export function readPointers(pointers) {
  return pointers.map(_ref => {
    let [key, id] = _ref;
    return {
      key: key.toString(),
      id: readId(id)
    };
  });
}
const AENS_SUFFIX = '.chain';
/**
 * Is AENS name valid
 * @category AENS
 * @param name - AENS name
 */

export function isNameValid(name) {
  // TODO: probably there are stronger requirements
  return name.endsWith(AENS_SUFFIX);
}
const encodingToPointerKey = [[Encoding.AccountAddress, 'account_pubkey'], [Encoding.OracleAddress, 'oracle_pubkey'], [Encoding.ContractAddress, 'contract_pubkey'], [Encoding.Channel, 'channel']];
/**
 * @category AENS
 * @param identifier - account/oracle/contract address, or channel
 * @returns default AENS pointer key
 */

export function getDefaultPointerKey(identifier) {
  var _encodingToPointerKey;

  decode(identifier);
  const encoding = identifier.substring(0, 2);
  const result = (_encodingToPointerKey = encodingToPointerKey.find(_ref2 => {
    let [e] = _ref2;
    return e === encoding;
  })) === null || _encodingToPointerKey === void 0 ? void 0 : _encodingToPointerKey[1];
  if (result != null) return result;
  throw new ArgumentError('identifier', `prefixed with one of ${encodingToPointerKey.map(_ref3 => {
    let [e] = _ref3;
    return `${e}_`;
  }).join(', ')}`, identifier);
}
/**
 * Get the minimum AENS name fee
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @returns the minimum fee for the AENS name auction
 */

export function getMinimumNameFee(name) {
  const nameLength = name.length - AENS_SUFFIX.length;
  return NAME_BID_RANGES[Math.min(nameLength, NAME_MAX_LENGTH_FEE)];
}
/**
 * Compute bid fee for AENS auction
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @param options - Options
 * @param options.startFee - Auction start fee
 * @param options.increment - Bid multiplier(In percentage, must be between 0 and 1)
 * @returns Bid fee
 */

export function computeBidFee(name) {
  let {
    startFee,
    increment = NAME_FEE_BID_INCREMENT
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!(Number(increment) === increment && increment % 1 !== 0)) throw new IllegalBidFeeError(`Increment must be float. Current increment ${increment}`);
  if (increment < NAME_FEE_BID_INCREMENT) throw new IllegalBidFeeError(`minimum increment percentage is ${NAME_FEE_BID_INCREMENT}`); // FIXME: increment should be used somehow here

  return ceil(new BigNumber(startFee !== null && startFee !== void 0 ? startFee : getMinimumNameFee(name)).times(new BigNumber(NAME_FEE_BID_INCREMENT).plus(1)));
}
/**
 * Compute auction end height
 * @category AENS
 * @param name - Name to compute auction end for
 * @param claimHeight - Auction starting height
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L273}
 * @returns Auction end height
 */

export function computeAuctionEndBlock(name, claimHeight) {
  const length = name.length - AENS_SUFFIX.length;
  const h = length <= 4 && 62 * NAME_BID_TIMEOUT_BLOCKS || length <= 8 && 31 * NAME_BID_TIMEOUT_BLOCKS || length <= 12 && NAME_BID_TIMEOUT_BLOCKS || 0;
  return h + claimHeight;
}
/**
 * Is name accept going to auction
 * @category AENS
 */

export function isAuctionName(name) {
  return name.length < 13 + AENS_SUFFIX.length;
}
//# sourceMappingURL=helpers.mjs.map