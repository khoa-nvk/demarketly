{"version":3,"file":"address.mjs","names":["ArgumentError","PrefixNotFoundError","TagNotFoundError","toBytes","decode","encode","Encoding","isItemOfArray","idTagToEncoding","AccountAddress","Name","Commitment","OracleAddress","ContractAddress","Channel","writeId","hashId","encoding","slice","idTag","indexOf","from","readId","buf","readUIntBE","length"],"sources":["../../../src/tx/builder/address.ts"],"sourcesContent":["import { ArgumentError, PrefixNotFoundError, TagNotFoundError } from '../../utils/errors';\nimport { toBytes } from '../../utils/bytes';\nimport {\n  decode, encode, Encoded, Encoding,\n} from '../../utils/encoder';\nimport { isItemOfArray } from '../../utils/other';\n\n/**\n * Map of prefix to ID tag constant\n * @see {@link https://github.com/aeternity/protocol/blob/master/serializations.md#the-id-type}\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_id.erl#L97-L102}\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L163-L168}\n */\nconst idTagToEncoding = [\n  Encoding.AccountAddress,\n  Encoding.Name,\n  Encoding.Commitment,\n  Encoding.OracleAddress,\n  Encoding.ContractAddress,\n  Encoding.Channel,\n] as const;\n\ntype AddressEncodings = typeof idTagToEncoding[number];\n\n/**\n * Utility function to create and _id type\n * @category transaction builder\n * @param hashId - Encoded hash\n * @returns Buffer Buffer with ID tag and decoded HASh\n */\nexport function writeId(hashId: Encoded.Generic<AddressEncodings>): Buffer {\n  if (typeof hashId !== 'string') throw new ArgumentError('hashId', 'a string', hashId);\n  const encoding = hashId.slice(0, 2);\n  if (!isItemOfArray(encoding, idTagToEncoding)) throw new TagNotFoundError(encoding);\n  const idTag = idTagToEncoding.indexOf(encoding) + 1;\n  return Buffer.from([...toBytes(idTag), ...decode(hashId)]);\n}\n\n/**\n * Utility function to read and _id type\n * @category transaction builder\n * @param buf - Data\n * @returns Encoided hash string with prefix\n */\nexport function readId(buf: Buffer): Encoded.Generic<AddressEncodings> {\n  const idTag = Buffer.from(buf).readUIntBE(0, 1);\n  const encoding = idTagToEncoding[idTag - 1];\n  if (encoding == null) throw new PrefixNotFoundError(idTag);\n  return encode(buf.slice(1, buf.length), encoding);\n}\n"],"mappings":";;;;SAASA,a,EAAeC,mB,EAAqBC,gB;SACpCC,O;SAEPC,M,EAAQC,M,EAAiBC,Q;SAElBC,a;AAET;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,eAAe,GAAG,CACtBF,QAAQ,CAACG,cADa,EAEtBH,QAAQ,CAACI,IAFa,EAGtBJ,QAAQ,CAACK,UAHa,EAItBL,QAAQ,CAACM,aAJa,EAKtBN,QAAQ,CAACO,eALa,EAMtBP,QAAQ,CAACQ,OANa,CAAxB;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAT,CAAiBC,MAAjB,EAAoE;EACzE,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,MAAM,IAAIhB,aAAJ,CAAkB,QAAlB,EAA4B,UAA5B,EAAwCgB,MAAxC,CAAN;EAChC,MAAMC,QAAQ,GAAGD,MAAM,CAACE,KAAP,CAAa,CAAb,EAAgB,CAAhB,CAAjB;EACA,IAAI,CAACX,aAAa,CAACU,QAAD,EAAWT,eAAX,CAAlB,EAA+C,MAAM,IAAIN,gBAAJ,CAAqBe,QAArB,CAAN;EAC/C,MAAME,KAAK,GAAGX,eAAe,CAACY,OAAhB,CAAwBH,QAAxB,IAAoC,CAAlD;EACA,OAAO,QAAOI,IAAP,CAAY,CAAC,GAAGlB,OAAO,CAACgB,KAAD,CAAX,EAAoB,GAAGf,MAAM,CAACY,MAAD,CAA7B,CAAZ,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,MAAT,CAAgBC,GAAhB,EAAgE;EACrE,MAAMJ,KAAK,GAAG,QAAOE,IAAP,CAAYE,GAAZ,EAAiBC,UAAjB,CAA4B,CAA5B,EAA+B,CAA/B,CAAd;;EACA,MAAMP,QAAQ,GAAGT,eAAe,CAACW,KAAK,GAAG,CAAT,CAAhC;EACA,IAAIF,QAAQ,IAAI,IAAhB,EAAsB,MAAM,IAAIhB,mBAAJ,CAAwBkB,KAAxB,CAAN;EACtB,OAAOd,MAAM,CAACkB,GAAG,CAACL,KAAJ,CAAU,CAAV,EAAaK,GAAG,CAACE,MAAjB,CAAD,EAA2BR,QAA3B,CAAb;AACD"}