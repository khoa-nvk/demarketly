import _buffer from "buffer";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
const {
  Buffer: _Buffer
} = _buffer;
import _rlp from 'rlp';
const {
  decode: rlpDecode,
  encode: rlpEncode
} = _rlp;
import { decode, encode, Encoding } from "../../utils/encoder.mjs";
import { AE_AMOUNT_FORMATS } from "../../utils/amount-formatter.mjs";
import { hash } from "../../utils/crypto.mjs";
import { FIELD_TYPES, TX_SCHEMA } from "./schema.mjs";
import { Tag } from "./constants.mjs";
import { buildContractId, buildPointers, readInt, readPointers, writeInt } from "./helpers.mjs";
import { readId, writeId } from "./address.mjs";
import { toBytes } from "../../utils/bytes.mjs";
import MPTree from "../../utils/mptree.mjs";
import { ArgumentError, DecodeError, InvalidTxParamsError, SchemaNotFoundError } from "../../utils/errors.mjs";
import { isKeyOfObject } from "../../utils/other.mjs";

/**
 * JavaScript-based Transaction builder
 */
// SERIALIZE AND DESERIALIZE PART
function deserializeField(value, type, prefix) {
  if (value == null) return '';

  switch (type) {
    case FIELD_TYPES.ctVersion:
      {
        const [vm,, abi] = value;
        return {
          vmVersion: readInt(_Buffer.from([vm])),
          abiVersion: readInt(_Buffer.from([abi]))
        };
      }

    case FIELD_TYPES.abiVersion:
    case FIELD_TYPES.ttlType:
      return readInt(value);

    case FIELD_TYPES.id:
      return readId(value);

    case FIELD_TYPES.ids:
      return value.map(readId);

    case FIELD_TYPES.bool:
      return value[0] === 1;

    case FIELD_TYPES.binary:
      return encode(value, prefix);

    case FIELD_TYPES.stateTree:
      return encode(value, Encoding.StateTrees);

    case FIELD_TYPES.string:
      return value.toString();

    case FIELD_TYPES.payload:
      return encode(value, Encoding.Bytearray);

    case FIELD_TYPES.pointers:
      return readPointers(value);

    case FIELD_TYPES.rlpBinary:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return unpackTx(encode(value, Encoding.Transaction));

    case FIELD_TYPES.rlpBinaries:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return value.map(v => unpackTx(encode(v, Encoding.Transaction)));

    case FIELD_TYPES.rawBinary:
      return value;

    case FIELD_TYPES.hex:
      return value.toString('hex');

    case FIELD_TYPES.offChainUpdates:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return value.map(v => unpackTx(encode(v, Encoding.Transaction)));

    case FIELD_TYPES.callStack:
      // TODO: fix this
      return [readInt(value)];

    case FIELD_TYPES.mptrees:
      return value.map(t => new MPTree(t));

    case FIELD_TYPES.callReturnType:
      switch (readInt(value)) {
        case '0':
          return 'ok';

        case '1':
          return 'error';

        case '2':
          return 'revert';

        default:
          return value;
      }

    case FIELD_TYPES.sophiaCodeTypeInfo:
      return value.reduce((acc, _ref) => {
        let [funHash, fnName, argType, outType] = _ref;
        return { ...acc,
          [fnName.toString()]: {
            funHash,
            argType,
            outType
          }
        };
      }, {});

    default:
      if (typeof type === 'number') return value;
      return type.deserialize(value);
  }
}

function serializeField(value, type, params) {
  var _value$rlpEncoded;

  switch (type) {
    case FIELD_TYPES.abiVersion:
    case FIELD_TYPES.ttlType:
      return writeInt(value);

    case FIELD_TYPES.id:
      return writeId(value);

    case FIELD_TYPES.ids:
      return value.map(writeId);

    case FIELD_TYPES.bool:
      return _Buffer.from([value === true ? 1 : 0]);

    case FIELD_TYPES.binary:
      return decode(value);

    case FIELD_TYPES.stateTree:
      return decode(value);

    case FIELD_TYPES.hex:
      return _Buffer.from(value, 'hex');

    case FIELD_TYPES.signatures:
      return value.map(_Buffer.from);

    case FIELD_TYPES.payload:
      return typeof value === 'string' && value.split('_')[0] === 'ba' ? decode(value) : toBytes(value);

    case FIELD_TYPES.string:
      return toBytes(value);

    case FIELD_TYPES.pointers:
      return buildPointers(value);

    case FIELD_TYPES.rlpBinary:
      return (_value$rlpEncoded = value.rlpEncoded) !== null && _value$rlpEncoded !== void 0 ? _value$rlpEncoded : value;

    case FIELD_TYPES.mptrees:
      return value.map(t => t.serialize());

    case FIELD_TYPES.ctVersion:
      return _Buffer.from([...toBytes(value.vmVersion), 0, ...toBytes(value.abiVersion)]);

    case FIELD_TYPES.callReturnType:
      switch (value) {
        case 'ok':
          return writeInt(0);

        case 'error':
          return writeInt(1);

        case 'revert':
          return writeInt(2);

        default:
          return value;
      }

    default:
      if (typeof type === 'number') return value; // @ts-expect-error will be solved after removing the whole serializeField function

      return type.serialize(value, params);
  }
}

function validateField(value, type, prefix) {
  // All fields are required
  if (value == null) return 'Field is required'; // Validate type of value

  switch (type) {
    case FIELD_TYPES.id:
      {
        const prefixes = Array.isArray(prefix) ? prefix : [prefix];

        if (!_includesInstanceProperty(prefixes).call(prefixes, value.split('_')[0])) {
          if (prefix == null) {
            return `'${String(value)}' prefix doesn't exist'`;
          }

          return `'${String(value)}' prefix doesn't match expected prefix '${prefix.toString()}'`;
        }

        return undefined;
      }

    case FIELD_TYPES.ctVersion:
      if (!(Boolean(value.abiVersion) && Boolean(value.vmVersion))) {
        return 'Value must be an object with "vmVersion" and "abiVersion" fields';
      }

      return undefined;

    case FIELD_TYPES.pointers:
      if (!Array.isArray(value)) return 'Value must be of type Array';

      if (value.some(p => !(Boolean(p.key) && Boolean(p.id)))) {
        return 'Value must contains only object\'s like \'{key: "account_pubkey", id: "ak_lkamsflkalsdalksdlasdlasdlamd"}\'';
      }

      if (value.length > 32) {
        return `Expected 32 pointers or less, got ${value.length} instead`;
      }

      return undefined;

    default:
      return undefined;
  }
}
/**
 * Validate transaction params
 * @category transaction builder
 * @param params - Object with tx params
 * @param schema - Transaction schema
 * @param excludeKeys - Array of keys to exclude for validation
 * @returns Object with validation errors
 */


export function validateParams(params, schema, _ref2) {
  let {
    excludeKeys = []
  } = _ref2;
  return Object.fromEntries(schema // TODO: allow optional keys in schema
  .filter(_ref3 => {
    var _context;

    let [key] = _ref3;
    return !_includesInstanceProperty(excludeKeys).call(excludeKeys, key) && !_includesInstanceProperty(_context = ['payload', 'nameFee', 'deposit', 'gasPrice', 'fee', 'gasLimit']).call(_context, key);
  }).map(_ref4 => {
    let [key, type, prefix] = _ref4;
    return [key, validateField(params[key], type, prefix)];
  }).filter(_ref5 => {
    let [, message] = _ref5;
    return message;
  }));
}
/**
 * Unpack binary transaction
 * @category transaction builder
 * @param binary - Array with binary transaction field's
 * @param schema - Transaction schema
 * @returns Object with transaction field's
 */

export function unpackRawTx(binary, schema) {
  return schema.reduce((acc, _ref6, index) => {
    let [key, fieldType, prefix] = _ref6;
    return Object.assign(acc, {
      [key]: deserializeField(binary[index], fieldType, prefix)
    });
  }, {});
}
/**
 * @category transaction builder
 */

/**
 * Build transaction hash
 * @category transaction builder
 * @param _params - Object with tx params
 * @param type - Transaction type
 * @param options - options
 * @param options.excludeKeys - Array of keys to exclude for validation and build
 * @param options.denomination - Denomination of amounts
 * @param options.prefix - Prefix of transaction
 * @throws {@link InvalidTxParamsError}
 * @returns object
 * @returns object.tx Base64Check transaction hash with 'tx_' prefix
 * @returns object.rlpEncoded rlp encoded transaction
 * @returns object.binary binary transaction
 */
export function buildTx(_params, type) {
  var _vsn;

  let {
    excludeKeys = [],
    prefix = Encoding.Transaction,
    vsn,
    denomination = AE_AMOUNT_FORMATS.AETTOS
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const schemas = TX_SCHEMA[type];
  (_vsn = vsn) !== null && _vsn !== void 0 ? _vsn : vsn = Math.max(...Object.keys(schemas).map(a => +a));
  if (!isKeyOfObject(vsn, schemas)) throw new SchemaNotFoundError('serialization', Tag[type], vsn);
  const schema = schemas[vsn];
  const params = _params;
  params.VSN = vsn;
  params.tag = type;
  params.denomination = denomination;
  const filteredSchema = schema.filter(_ref7 => {
    let [key] = _ref7;
    return !_includesInstanceProperty(excludeKeys).call(excludeKeys, key);
  }); // Validation

  const valid = validateParams(params, schema, {
    excludeKeys
  });

  if (Object.keys(valid).length > 0) {
    throw new InvalidTxParamsError(`Transaction build error. ${JSON.stringify(valid)}`);
  }

  const binary = filteredSchema.map(_ref8 => {
    let [key, fieldType] = _ref8;
    return serializeField(params[key], fieldType, { ...params,
      txType: type,
      rebuildTx: overrideParams => buildTx({ ...params,
        ...overrideParams
      }, type, {
        excludeKeys,
        prefix: Encoding.Transaction,
        vsn,
        denomination
      })
    });
  }).filter(e => e !== undefined);
  const rlpEncoded = rlpEncode(binary);
  const tx = encode(rlpEncoded, prefix);
  return {
    tx,
    rlpEncoded,
    binary,
    txObject: unpackRawTx(binary, schema)
  };
}
/**
 * @category transaction builder
 */

/**
 * Unpack transaction hash
 * @category transaction builder
 * @param encodedTx - Transaction to unpack
 * @param txType - Expected transaction type
 * @returns object
 * @returns object.tx Object with transaction param's
 * @returns object.txType Transaction type
 */
export function unpackTx(encodedTx, txType) {
  const rlpEncoded = decode(encodedTx);
  const binary = rlpDecode(rlpEncoded);
  const objId = +readInt(binary[0]);
  if (!isKeyOfObject(objId, TX_SCHEMA)) throw new DecodeError(`Unknown transaction tag: ${objId}`);
  if (txType != null && txType !== objId) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[objId]} instead`);
  const vsn = +readInt(binary[1]);
  if (!isKeyOfObject(vsn, TX_SCHEMA[objId])) throw new SchemaNotFoundError('deserialization', `tag ${objId}`, vsn);
  const schema = TX_SCHEMA[objId][vsn];
  return {
    txType: objId,
    tx: unpackRawTx(binary, schema),
    rlpEncoded
  };
}
/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */

export function buildTxHash(rawTx) {
  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;
  return encode(hash(data), Encoding.TxHash);
}
/**
 * Build a contract public key by contractCreateTx or gaAttach
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */

export function buildContractIdByContractTx(contractTx) {
  var _context2;

  const {
    txType,
    tx
  } = unpackTx(contractTx);

  if (!_includesInstanceProperty(_context2 = [Tag.ContractCreateTx, Tag.GaAttachTx]).call(_context2, txType)) {
    throw new ArgumentError('contractCreateTx', 'a contractCreateTx or gaAttach', txType);
  }

  return buildContractId(tx.ownerId, +tx.nonce);
}
//# sourceMappingURL=index.mjs.map