import _buffer from "buffer";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
const {
  Buffer: _Buffer
} = _buffer;
import BigNumber from 'bignumber.js';
import { hash, verify } from "../utils/crypto.mjs";
import { PROTOCOL_VM_ABI } from "./builder/schema.mjs";
import { Tag } from "./builder/constants.mjs";
import { unpackTx } from "./builder/index.mjs";
import { UnsupportedProtocolError } from "../utils/errors.mjs";
import { concatBuffers, isKeyOfObject } from "../utils/other.mjs";
import { decode, encode, Encoding } from "../utils/encoder.mjs";
const validators = [];

const getSenderAddress = tx => ['senderId', 'accountId', 'ownerId', 'callerId', 'oracleId', 'fromId', 'initiator', 'gaId', 'payerId'].map(key => tx[key]).filter(a => a).map(a => a === null || a === void 0 ? void 0 : a.toString().replace(/^ok_/, 'ak_'))[0];
/**
 * Transaction Validator
 * This function validates some of transaction properties,
 * to make sure it can be posted it to the chain
 * @category transaction builder
 * @param transaction - Base64Check-encoded transaction
 * @param node - Node to validate transaction against
 * @param parentTxTypes - Types of parent transactions
 * @returns Array with verification errors
 * @example const errors = await verifyTransaction(transaction, node)
 */


export default async function verifyTransaction(transaction, node) {
  var _getSenderAddress;

  let parentTxTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const {
    tx,
    txType
  } = unpackTx(transaction);
  const address = (_getSenderAddress = getSenderAddress(tx)) !== null && _getSenderAddress !== void 0 ? _getSenderAddress : txType === Tag.SignedTx ? getSenderAddress(tx.encodedTx.tx) : undefined;
  const [account, {
    height
  }, {
    consensusProtocolVersion,
    nodeNetworkId
  }] = await Promise.all([address == null ? undefined : node.getAccountByPubkey(address).catch(() => ({
    id: address,
    balance: 0n,
    nonce: 0
  })) // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537
  .then(acc => ({ ...acc,
    id: acc.id
  })), node.getCurrentKeyBlockHeight(), node.getNodeInfo()]);
  return (await Promise.all(validators.map(v => v(tx, {
    txType,
    node,
    account,
    height,
    consensusProtocolVersion,
    nodeNetworkId,
    parentTxTypes
  })))).flat();
}
validators.push((_ref, _ref2) => {
  let {
    encodedTx,
    signatures
  } = _ref;
  let {
    account,
    nodeNetworkId,
    parentTxTypes
  } = _ref2;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : signatures) === undefined) return [];
  if (account == null) return [];
  if (signatures.length !== 1) return []; // TODO: Support multisignature?

  const prefix = _Buffer.from([nodeNetworkId, ...(_includesInstanceProperty(parentTxTypes).call(parentTxTypes, Tag.PayingForTx) ? ['inner_tx'] : [])].join('-'));

  const txWithNetworkId = concatBuffers([prefix, encodedTx.rlpEncoded]);
  const txHashWithNetworkId = concatBuffers([prefix, hash(encodedTx.rlpEncoded)]);
  const decodedPub = decode(account.id);
  if (verify(txWithNetworkId, signatures[0], decodedPub) || verify(txHashWithNetworkId, signatures[0], decodedPub)) return [];
  return [{
    message: 'Signature cannot be verified, please ensure that you transaction have' + ' the correct prefix and the correct private key for the sender address',
    key: 'InvalidSignature',
    checkedKeys: ['encodedTx', 'signatures']
  }];
}, async (_ref3, _ref4) => {
  let {
    encodedTx,
    tx
  } = _ref3;
  let {
    node,
    parentTxTypes,
    txType
  } = _ref4;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : tx) === undefined) return [];
  return verifyTransaction(encode((encodedTx !== null && encodedTx !== void 0 ? encodedTx : tx).rlpEncoded, Encoding.Transaction), node, [...parentTxTypes, txType]);
}, (_ref5, _ref6) => {
  let {
    ttl
  } = _ref5;
  let {
    height
  } = _ref6;
  if (ttl === undefined) return [];
  ttl = +ttl;
  if (ttl === 0 || ttl >= height) return [];
  return [{
    message: `TTL ${ttl} is already expired, current height is ${height}`,
    key: 'ExpiredTTL',
    checkedKeys: ['ttl']
  }];
}, (_ref7, _ref8) => {
  var _ref9, _fee;

  let {
    amount,
    fee,
    nameFee,
    tx
  } = _ref7;
  let {
    account,
    parentTxTypes,
    txType
  } = _ref8;
  if (account == null) return [];
  if (((_ref9 = amount !== null && amount !== void 0 ? amount : fee) !== null && _ref9 !== void 0 ? _ref9 : nameFee) === undefined) return [];
  (_fee = fee) !== null && _fee !== void 0 ? _fee : fee = 0;
  const cost = new BigNumber(fee).plus(nameFee !== null && nameFee !== void 0 ? nameFee : 0).plus(amount !== null && amount !== void 0 ? amount : 0).plus(txType === Tag.PayingForTx ? tx.tx.encodedTx.tx.fee : 0).minus(_includesInstanceProperty(parentTxTypes).call(parentTxTypes, Tag.PayingForTx) ? fee : 0);
  if (cost.lte(account.balance.toString())) return [];
  return [{
    message: `Account balance ${account.balance.toString()} is not enough to execute the transaction that costs ${cost.toFixed()}`,
    key: 'InsufficientBalance',
    checkedKeys: ['amount', 'fee', 'nameFee']
  }];
}, (_ref10, _ref11) => {
  let {
    nonce
  } = _ref10;
  let {
    account,
    parentTxTypes
  } = _ref11;
  if (nonce == null || account == null || _includesInstanceProperty(parentTxTypes).call(parentTxTypes, Tag.GaMetaTx)) return [];
  nonce = +nonce;
  const validNonce = account.nonce + 1;
  if (nonce === validNonce) return [];
  return [{ ...(nonce < validNonce ? {
      message: `Nonce ${nonce} is already used, valid nonce is ${validNonce}`,
      key: 'NonceAlreadyUsed'
    } : {
      message: `Nonce ${nonce} is too high, valid nonce is ${validNonce}`,
      key: 'NonceHigh'
    }),
    checkedKeys: ['nonce']
  }];
}, (_ref12, _ref13) => {
  let {
    ctVersion,
    abiVersion
  } = _ref12;
  let {
    txType,
    consensusProtocolVersion
  } = _ref13;

  if (!isKeyOfObject(consensusProtocolVersion, PROTOCOL_VM_ABI)) {
    throw new UnsupportedProtocolError(`Unsupported protocol: ${consensusProtocolVersion}`);
  }

  const protocol = PROTOCOL_VM_ABI[consensusProtocolVersion]; // If not contract create tx

  if (ctVersion == null) ctVersion = {
    abiVersion
  };
  const txProtocol = protocol[txType];
  if (txProtocol == null) return [];

  if (Object.entries(ctVersion).some(_ref14 => {
    var _context;

    let [key, value] = _ref14;
    return !_includesInstanceProperty(_context = txProtocol[key]).call(_context, +value);
  })) {
    return [{
      message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(txProtocol)}`,
      key: 'VmAndAbiVersionMismatch',
      checkedKeys: ['ctVersion', 'abiVersion']
    }];
  }

  return [];
}, async (_ref15, _ref16) => {
  let {
    contractId
  } = _ref15;
  let {
    txType,
    node
  } = _ref16;
  if (Tag.ContractCallTx !== txType) return [];
  contractId = contractId;

  try {
    const {
      active
    } = await node.getContract(contractId);
    if (active) return [];
    return [{
      message: `Contract ${contractId} is not active`,
      key: 'ContractNotActive',
      checkedKeys: ['contractId']
    }];
  } catch (error) {
    var _error$response, _error$response$parse;

    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$parse = _error$response.parsedBody) === null || _error$response$parse === void 0 ? void 0 : _error$response$parse.reason) == null) throw error;
    return [{
      message: error.response.parsedBody.reason,
      key: 'ContractNotFound',
      checkedKeys: ['contractId']
    }];
  }
});
//# sourceMappingURL=validator.mjs.map