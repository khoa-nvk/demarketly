import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";

/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */
import { messageToHash, verifyMessage as verifyMessageCrypto, hash } from "../utils/crypto.mjs";
import { buildTx } from "../tx/builder/index.mjs";
import { decode } from "../utils/encoder.mjs";
import { Tag } from "../tx/builder/constants.mjs";
import { getNetworkId } from "../Node.mjs";
import { concatBuffers } from "../utils/other.mjs";

/**
 * Check is provided object looks like an instance of AccountBase
 * @param acc - Object to check
 */
export const isAccountBase = acc => !['sign', 'address', 'signTransaction', 'signMessage'].some(f => typeof acc[f] !== 'function');
/**
 * Account is one of the three basic building blocks of an
 * {@link AeSdk} and provides access to a signing key pair.
 */

export default class AccountBase {
  /**
   * @param options - Options
   * @param options.networkId - Using for signing transactions
   */
  constructor() {
    var _this$networkId;

    let {
      networkId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _defineProperty(this, "getNetworkId", getNetworkId);

    (_this$networkId = this.networkId) !== null && _this$networkId !== void 0 ? _this$networkId : this.networkId = networkId;
  }
  /**
   * Sign encoded transaction
   * @param tx - Transaction to sign
   * @param opt - Options
   * @param opt.innerTx - Sign as inner transaction for PayingFor
   * @returns Signed transaction
   */


  async signTransaction(tx) {
    let {
      innerTx,
      networkId,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const prefixes = [await this.getNetworkId({
      networkId
    })];
    if (innerTx === true) prefixes.push('inner_tx');
    const rlpBinaryTx = decode(tx);
    const txWithNetworkId = concatBuffers([_Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
    const signatures = [await this.sign(txWithNetworkId, options)];
    return buildTx({
      encodedTx: rlpBinaryTx,
      signatures
    }, Tag.SignedTx).tx;
  }
  /**
   * Get network Id
   * @returns Network Id
   */


  /**
   * Sign message
   * @param message - Message to sign
   * @param opt - Options
   * @returns Signature as hex string of Uint8Array
   */
  async signMessage(message) {
    let {
      returnHex = false,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const sig = await this.sign(messageToHash(message), options);
    return returnHex ? _Buffer.from(sig).toString('hex') : sig;
  }
  /**
   * Verify message
   * @param message - Message to verify
   * @param signature - Signature
   * @param options - Options
   */


  async verifyMessage(message, signature, options) {
    return verifyMessageCrypto(message, typeof signature === 'string' ? _Buffer.from(signature, 'hex') : signature, decode(await this.address(options)));
  }
  /**
   * Sign data blob
   * @param data - Data blob to sign
   * @param options - Options
   * @returns Signed data blob
   */


}
//# sourceMappingURL=Base.mjs.map