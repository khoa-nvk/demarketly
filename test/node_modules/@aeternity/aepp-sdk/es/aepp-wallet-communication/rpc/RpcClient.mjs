import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

import { RpcError, RpcInternalError, RpcMethodNotFoundError } from "../schema.mjs";
import { InvalidRpcMessageError, MissingCallbackError } from "../../utils/errors.mjs";

var _callbacks = /*#__PURE__*/new WeakMap();

var _messageId = /*#__PURE__*/new WeakMap();

var _methods = /*#__PURE__*/new WeakMap();

var _handleMessage = /*#__PURE__*/new WeakSet();

var _sendRequest = /*#__PURE__*/new WeakSet();

var _sendResponse = /*#__PURE__*/new WeakSet();

var _processResponse = /*#__PURE__*/new WeakSet();

/**
 * Contain functionality for using RPC conection
 * @category aepp wallet communication
 * @param connection - Connection object
 * @param onDisconnect - Disconnect callback
 * @param methods - Object containing handlers for each request by name
 */
export default class RpcClient {
  constructor(connection, onDisconnect, methods) {
    _classPrivateMethodInitSpec(this, _processResponse);

    _classPrivateMethodInitSpec(this, _sendResponse);

    _classPrivateMethodInitSpec(this, _sendRequest);

    _classPrivateMethodInitSpec(this, _handleMessage);

    _classPrivateFieldInitSpec(this, _callbacks, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _messageId, {
      writable: true,
      value: 0
    });

    _classPrivateFieldInitSpec(this, _methods, {
      writable: true,
      value: void 0
    });

    this.connection = connection;

    _classPrivateFieldSet(this, _methods, methods);

    connection.connect(_classPrivateMethodGet(this, _handleMessage, _handleMessage2).bind(this), onDisconnect);
  }

  /**
   * Make a request
   * @param name - Method name
   * @param params - Method params
   * @returns Promise which will be resolved after receiving response message
   */
  async request(name, params) {
    _classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, _classPrivateFieldSet(this, _messageId, _classPrivateFieldGet(this, _messageId) + 1), name, params);

    return new Promise((resolve, reject) => {
      _classPrivateFieldGet(this, _callbacks).set(_classPrivateFieldGet(this, _messageId), {
        resolve,
        reject
      });
    });
  }
  /**
   * Make a notification
   * @param name - Method name
   * @param params - Method params
   */


  notify(name, params) {
    _classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, undefined, name, params);
  }
  /**
   * Process response message
   * @param msg - Message object
   */


}

async function _handleMessage2(msg, origin) {
  if ((msg === null || msg === void 0 ? void 0 : msg.jsonrpc) !== '2.0') throw new InvalidRpcMessageError(JSON.stringify(msg));

  if ('result' in msg || 'error' in msg) {
    _classPrivateMethodGet(this, _processResponse, _processResponse2).call(this, msg);

    return;
  }

  const request = msg;
  let result;
  let error;

  try {
    if (!(request.method in _classPrivateFieldGet(this, _methods))) throw new RpcMethodNotFoundError();
    const methodName = request.method;
    result = await _classPrivateFieldGet(this, _methods)[methodName](request.params, origin);
  } catch (e) {
    error = e instanceof RpcError ? e : new RpcInternalError();
  }

  if (request.id != null) {
    _classPrivateMethodGet(this, _sendResponse, _sendResponse2).call(this, request.id, request.method, result, error);
  }
}

function _sendRequest2(id, method, params) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    ...(id != null ? {
      id
    } : {}),
    method,
    ...(params != null ? {
      params
    } : {})
  });
}

function _sendResponse2(id, method, // TODO: remove as far it is not required in JSON RPC
result, error) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    id,
    method,
    ...(error != null ? {
      error
    } : {
      result
    })
  });
}

function _processResponse2(_ref) {
  let {
    id,
    error,
    result
  } = _ref;

  const callbacks = _classPrivateFieldGet(this, _callbacks).get(id);

  if (callbacks == null) throw new MissingCallbackError(id);
  if (error != null) callbacks.reject(RpcError.deserialize(error));else callbacks.resolve(result);

  _classPrivateFieldGet(this, _callbacks).delete(id);
}
//# sourceMappingURL=RpcClient.mjs.map