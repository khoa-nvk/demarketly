import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

/*
 * ISC License (ISC)
 * Copyright (c) 2022 aeternity developers
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 *  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 *  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 *  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 *  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 *  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *  PERFORMANCE OF THIS SOFTWARE.
 */
import BrowserConnection from "./Browser.mjs";
import { MESSAGE_DIRECTION } from "../schema.mjs";
import { InternalError, RpcConnectionError } from "../../utils/errors.mjs";

var _onDisconnect = /*#__PURE__*/new WeakMap();

var _target = /*#__PURE__*/new WeakMap();

var _self = /*#__PURE__*/new WeakMap();

/**
 * Browser window Post Message connector module
 * @category aepp wallet communication
 */
export default class BrowserWindowMessageConnection extends BrowserConnection {
  /**
   * @param options - Options
   * @param options.target Target window for message
   * @param options.self Host window for message
   * @param options.origin Origin of receiver
   * @param options.sendDirection Wrapping messages into additional struct
   * `({ type: 'to_aepp' || 'to_waellet', data })`
   * Used for handling messages between content script and page
   * @param options.receiveDirection Unwrapping messages from additional struct
   */
  constructor() {
    let {
      target,
      self = window,
      origin,
      sendDirection,
      receiveDirection = MESSAGE_DIRECTION.to_aepp,
      ...options
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(options);

    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _target, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _self, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _target, target);

    _classPrivateFieldSet(this, _self, self);

    this.origin = origin;
    this.sendDirection = sendDirection;
    this.receiveDirection = receiveDirection;
  }

  isConnected() {
    return this.listener != null;
  }

  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);

    this.listener = message => {
      var _message$data$jsonrpc, _message$data$data;

      // TODO: strict validate origin and source instead of checking message structure
      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : (_message$data$data = message.data.data) === null || _message$data$data === void 0 ? void 0 : _message$data$data.jsonrpc) !== '2.0') return;
      if (this.origin != null && this.origin !== message.origin) return;
      if (_classPrivateFieldGet(this, _target) != null && _classPrivateFieldGet(this, _target) !== message.source) return;
      this.receiveMessage(message);
      let {
        data
      } = message;

      if (data.type != null) {
        if (message.data.type !== this.receiveDirection) return;
        data = data.data;
      }

      onMessage(data, message.origin, message.source);
    };

    _classPrivateFieldGet(this, _self).addEventListener('message', this.listener);

    _classPrivateFieldSet(this, _onDisconnect, onDisconnect);
  }

  disconnect() {
    super.disconnect();

    if (this.listener == null || _classPrivateFieldGet(this, _onDisconnect) == null) {
      throw new InternalError('Expected to not happen, required for TS');
    }

    _classPrivateFieldGet(this, _self).removeEventListener('message', this.listener);

    delete this.listener;

    _classPrivateFieldGet(this, _onDisconnect).call(this);

    _classPrivateFieldSet(this, _onDisconnect, undefined);
  }

  sendMessage(msg) {
    var _this$origin;

    if (_classPrivateFieldGet(this, _target) == null) throw new RpcConnectionError('Can\'t send messages without target');
    const message = this.sendDirection != null ? {
      type: this.sendDirection,
      data: msg
    } : msg;
    super.sendMessage(message);

    _classPrivateFieldGet(this, _target).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');
  }

}
//# sourceMappingURL=BrowserWindowMessage.mjs.map